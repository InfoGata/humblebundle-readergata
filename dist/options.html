<html>
<head>
  <meta charset="utf-8">
  <title>Options</title>
  <style>*, :before, :after {
  box-sizing: border-box;
  border: 0 solid #e5e7eb;
}

:before, :after {
  --tw-content: "";
}

html, :host {
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-feature-settings: normal;
  font-variation-settings: normal;
  -webkit-tap-highlight-color: transparent;
  font-family: Inter, ui-sans-serif, system-ui, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;
  line-height: 1.5;
}

body {
  line-height: inherit;
  margin: 0;
}

hr {
  height: 0;
  color: inherit;
  border-top-width: 1px;
}

abbr:where([title]) {
  text-decoration: underline dotted;
}

h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

a {
  color: inherit;
  text-decoration: inherit;
}

b, strong {
  font-weight: bolder;
}

code, kbd, samp, pre {
  font-feature-settings: normal;
  font-variation-settings: normal;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
  font-size: 1em;
}

small {
  font-size: 80%;
}

sub, sup {
  vertical-align: baseline;
  font-size: 75%;
  line-height: 0;
  position: relative;
}

sub {
  bottom: -.25em;
}

sup {
  top: -.5em;
}

table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

button, input, optgroup, select, textarea {
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-family: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, [type="button"], [type="reset"], [type="submit"] {
  -webkit-appearance: button;
  background-color: #0000;
  background-image: none;
}

:-moz-focusring {
  outline: auto;
}

:-moz-ui-invalid {
  box-shadow: none;
}

progress {
  vertical-align: baseline;
}

::-webkit-inner-spin-button, ::-webkit-outer-spin-button {
  height: auto;
}

[type="search"] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}

::-webkit-search-decoration {
  -webkit-appearance: none;
}

::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

summary {
  display: list-item;
}

blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol, ul, menu {
  margin: 0;
  padding: 0;
  list-style: none;
}

dialog {
  padding: 0;
}

textarea {
  resize: vertical;
}

input::placeholder, textarea::placeholder {
  opacity: 1;
  color: #9ca3af;
}

button, [role="button"] {
  cursor: pointer;
}

:disabled {
  cursor: default;
}

img, svg, video, canvas, audio, iframe, embed, object {
  vertical-align: middle;
  display: block;
}

img, video {
  max-width: 100%;
  height: auto;
}

[hidden] {
  display: none;
}

:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 210 40% 98%;
  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;
  --muted: 210 40% 96.1%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --accent: 210 40% 96.1%;
  --accent-foreground: 222.2 47.4% 11.2%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 221.2 83.2% 53.3%;
  --radius: .75rem;
}

[data-kb-theme="dark"] {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;
  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;
  --primary: 217.2 91.2% 59.8%;
  --primary-foreground: 222.2 47.4% 11.2%;
  --secondary: 217.2 32.6% 17.5%;
  --secondary-foreground: 210 40% 98%;
  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;
  --accent: 217.2 32.6% 17.5%;
  --accent-foreground: 210 40% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 210 40% 98%;
  --border: 217.2 32.6% 17.5%;
  --input: 217.2 32.6% 17.5%;
  --ring: 224.3 76.3% 48%;
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
  font-feature-settings: "rlig" 1, "calt" 1;
}

a {
  --tw-text-opacity: 1;
  color: rgb(37 99 235 / var(--tw-text-opacity));
  text-decoration-line: underline;
}

a:visited {
  color: #9333ea;
}

a:hover {
  --tw-text-opacity: 1;
  color: rgb(30 64 175 / var(--tw-text-opacity));
}

*, :before, :after, ::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #3b82f680;
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
}

.flex {
  display: flex;
}

.inline-flex {
  display: inline-flex;
}

.h-10 {
  height: 2.5rem;
}

.h-11 {
  height: 2.75rem;
}

.h-9 {
  height: 2.25rem;
}

.w-10 {
  width: 2.5rem;
}

.w-full {
  width: 100%;
}

.list-inside {
  list-style-position: inside;
}

.list-decimal {
  list-style-type: decimal;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.gap-2 {
  gap: .5rem;
}

.space-y-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(.25rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(.25rem * var(--tw-space-y-reverse));
}

.rounded-md {
  border-radius: calc(var(--radius)  - 2px);
}

.border {
  border-width: 1px;
}

.border-input {
  border-color: hsl(var(--input));
}

.bg-destructive {
  background-color: hsl(var(--destructive));
}

.bg-primary {
  background-color: hsl(var(--primary));
}

.bg-secondary {
  background-color: hsl(var(--secondary));
}

.bg-transparent {
  background-color: #0000;
}

.px-3 {
  padding-left: .75rem;
  padding-right: .75rem;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.px-8 {
  padding-left: 2rem;
  padding-right: 2rem;
}

.py-2 {
  padding-top: .5rem;
  padding-bottom: .5rem;
}

.pl-8 {
  padding-left: 2rem;
}

.text-sm {
  font-size: .875rem;
  line-height: 1.25rem;
}

.font-medium {
  font-weight: 500;
}

.text-destructive-foreground {
  color: hsl(var(--destructive-foreground));
}

.text-primary {
  color: hsl(var(--primary));
}

.text-primary-foreground {
  color: hsl(var(--primary-foreground));
}

.text-secondary-foreground {
  color: hsl(var(--secondary-foreground));
}

.underline-offset-4 {
  text-underline-offset: 4px;
}

.outline {
  outline-style: solid;
}

.ring-offset-background {
  --tw-ring-offset-color: hsl(var(--background));
}

.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-duration: .15s;
  transition-timing-function: cubic-bezier(.4, 0, .2, 1);
}

@keyframes enter {
  from {
    opacity: var(--tw-enter-opacity, 1);
    transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));
  }
}

@keyframes exit {
  to {
    opacity: var(--tw-exit-opacity, 1);
    transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));
  }
}

@media (max-width: 640px) {
  .container {
    padding-left: 1rem;
    padding-right: 1rem;
  }
}

.file\:border-0::file-selector-button {
  border-width: 0;
}

.file\:bg-transparent::file-selector-button {
  background-color: #0000;
}

.file\:text-sm::file-selector-button {
  font-size: .875rem;
  line-height: 1.25rem;
}

.file\:font-medium::file-selector-button {
  font-weight: 500;
}

.placeholder\:text-muted-foreground::placeholder {
  color: hsl(var(--muted-foreground));
}

.hover\:bg-accent:hover {
  background-color: hsl(var(--accent));
}

.hover\:bg-destructive\/90:hover {
  background-color: hsl(var(--destructive) / .9);
}

.hover\:bg-primary\/90:hover {
  background-color: hsl(var(--primary) / .9);
}

.hover\:bg-secondary\/80:hover {
  background-color: hsl(var(--secondary) / .8);
}

.hover\:text-accent-foreground:hover {
  color: hsl(var(--accent-foreground));
}

.hover\:underline:hover {
  text-decoration-line: underline;
}

.focus-visible\:outline-none:focus-visible {
  outline-offset: 2px;
  outline: 2px solid #0000;
}

.focus-visible\:ring-2:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.focus-visible\:ring-ring:focus-visible {
  --tw-ring-color: hsl(var(--ring));
}

.focus-visible\:ring-offset-2:focus-visible {
  --tw-ring-offset-width: 2px;
}

.disabled\:pointer-events-none:disabled {
  pointer-events: none;
}

.disabled\:cursor-not-allowed:disabled {
  cursor: not-allowed;
}

.disabled\:opacity-50:disabled {
  opacity: .5;
}



</style>
</head>
<body>
  <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"aeHed":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "42036d7a98ade5a7";
module.bundle.HMR_BUNDLE_ID = "f34cb5cf07df2b04";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"BMEKY":[function(require,module,exports) {
var _optionsTsx = require("./options.tsx");
(0, _optionsTsx.init)();

},{"./options.tsx":"exSdi"}],"exSdi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "init", ()=>init);
var _web = require("solid-js/web");
var _core = require("@kobalte/core");
var _app = require("./App");
var _appDefault = parcelHelpers.interopDefault(_app);
const init = ()=>{
    (0, _web.render)(()=>(0, _web.createComponent)((0, _core.ColorModeProvider), {
            initialColorMode: "light",
            get children () {
                return (0, _web.createComponent)((0, _appDefault.default), {});
            }
        }), document.body);
};

},{"solid-js/web":"eGRlU","@kobalte/core":"hJybK","./App":"aHTGG","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eGRlU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ErrorBoundary", ()=>(0, _solidJs.ErrorBoundary));
parcelHelpers.export(exports, "For", ()=>(0, _solidJs.For));
parcelHelpers.export(exports, "Index", ()=>(0, _solidJs.Index));
parcelHelpers.export(exports, "Match", ()=>(0, _solidJs.Match));
parcelHelpers.export(exports, "Show", ()=>(0, _solidJs.Show));
parcelHelpers.export(exports, "Suspense", ()=>(0, _solidJs.Suspense));
parcelHelpers.export(exports, "SuspenseList", ()=>(0, _solidJs.SuspenseList));
parcelHelpers.export(exports, "Switch", ()=>(0, _solidJs.Switch));
parcelHelpers.export(exports, "createComponent", ()=>(0, _solidJs.createComponent));
parcelHelpers.export(exports, "effect", ()=>(0, _solidJs.createRenderEffect));
parcelHelpers.export(exports, "getOwner", ()=>(0, _solidJs.getOwner));
parcelHelpers.export(exports, "memo", ()=>(0, _solidJs.createMemo));
parcelHelpers.export(exports, "mergeProps", ()=>(0, _solidJs.mergeProps));
parcelHelpers.export(exports, "untrack", ()=>(0, _solidJs.untrack));
parcelHelpers.export(exports, "Aliases", ()=>Aliases);
parcelHelpers.export(exports, "Assets", ()=>voidFn);
parcelHelpers.export(exports, "ChildProperties", ()=>ChildProperties);
parcelHelpers.export(exports, "DOMElements", ()=>DOMElements);
parcelHelpers.export(exports, "DelegatedEvents", ()=>DelegatedEvents);
parcelHelpers.export(exports, "Dynamic", ()=>Dynamic);
parcelHelpers.export(exports, "Hydration", ()=>Hydration);
parcelHelpers.export(exports, "HydrationScript", ()=>voidFn);
parcelHelpers.export(exports, "NoHydration", ()=>NoHydration);
parcelHelpers.export(exports, "Portal", ()=>Portal);
parcelHelpers.export(exports, "Properties", ()=>Properties);
parcelHelpers.export(exports, "RequestContext", ()=>RequestContext);
parcelHelpers.export(exports, "SVGElements", ()=>SVGElements);
parcelHelpers.export(exports, "SVGNamespace", ()=>SVGNamespace);
parcelHelpers.export(exports, "addEventListener", ()=>addEventListener);
parcelHelpers.export(exports, "assign", ()=>assign);
parcelHelpers.export(exports, "classList", ()=>classList);
parcelHelpers.export(exports, "className", ()=>className);
parcelHelpers.export(exports, "clearDelegatedEvents", ()=>clearDelegatedEvents);
parcelHelpers.export(exports, "delegateEvents", ()=>delegateEvents);
parcelHelpers.export(exports, "dynamicProperty", ()=>dynamicProperty);
parcelHelpers.export(exports, "escape", ()=>escape);
parcelHelpers.export(exports, "generateHydrationScript", ()=>voidFn);
parcelHelpers.export(exports, "getAssets", ()=>voidFn);
parcelHelpers.export(exports, "getHydrationKey", ()=>getHydrationKey);
parcelHelpers.export(exports, "getNextElement", ()=>getNextElement);
parcelHelpers.export(exports, "getNextMarker", ()=>getNextMarker);
parcelHelpers.export(exports, "getNextMatch", ()=>getNextMatch);
parcelHelpers.export(exports, "getPropAlias", ()=>getPropAlias);
parcelHelpers.export(exports, "getRequestEvent", ()=>voidFn);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "innerHTML", ()=>innerHTML);
parcelHelpers.export(exports, "insert", ()=>insert);
parcelHelpers.export(exports, "isDev", ()=>isDev);
parcelHelpers.export(exports, "isServer", ()=>isServer);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "renderToStream", ()=>renderToStream);
parcelHelpers.export(exports, "renderToString", ()=>renderToString);
parcelHelpers.export(exports, "renderToStringAsync", ()=>renderToStringAsync);
parcelHelpers.export(exports, "resolveSSRNode", ()=>resolveSSRNode);
parcelHelpers.export(exports, "runHydrationEvents", ()=>runHydrationEvents);
parcelHelpers.export(exports, "setAttribute", ()=>setAttribute);
parcelHelpers.export(exports, "setAttributeNS", ()=>setAttributeNS);
parcelHelpers.export(exports, "setProperty", ()=>setProperty);
parcelHelpers.export(exports, "spread", ()=>spread);
parcelHelpers.export(exports, "ssr", ()=>ssr);
parcelHelpers.export(exports, "ssrAttribute", ()=>ssrAttribute);
parcelHelpers.export(exports, "ssrClassList", ()=>ssrClassList);
parcelHelpers.export(exports, "ssrElement", ()=>ssrElement);
parcelHelpers.export(exports, "ssrHydrationKey", ()=>ssrHydrationKey);
parcelHelpers.export(exports, "ssrSpread", ()=>ssrSpread);
parcelHelpers.export(exports, "ssrStyle", ()=>ssrStyle);
parcelHelpers.export(exports, "style", ()=>style);
parcelHelpers.export(exports, "template", ()=>template);
parcelHelpers.export(exports, "use", ()=>use);
parcelHelpers.export(exports, "useAssets", ()=>voidFn);
var _solidJs = require("solid-js");
const booleans = [
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "disabled",
    "formnovalidate",
    "hidden",
    "indeterminate",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "seamless",
    "selected"
];
const Properties = /*#__PURE__*/ new Set([
    "className",
    "value",
    "readOnly",
    "formNoValidate",
    "isMap",
    "noModule",
    "playsInline",
    ...booleans
]);
const ChildProperties = /*#__PURE__*/ new Set([
    "innerHTML",
    "textContent",
    "innerText",
    "children"
]);
const Aliases = /*#__PURE__*/ Object.assign(Object.create(null), {
    className: "class",
    htmlFor: "for"
});
const PropAliases = /*#__PURE__*/ Object.assign(Object.create(null), {
    class: "className",
    formnovalidate: {
        $: "formNoValidate",
        BUTTON: 1,
        INPUT: 1
    },
    ismap: {
        $: "isMap",
        IMG: 1
    },
    nomodule: {
        $: "noModule",
        SCRIPT: 1
    },
    playsinline: {
        $: "playsInline",
        VIDEO: 1
    },
    readonly: {
        $: "readOnly",
        INPUT: 1,
        TEXTAREA: 1
    }
});
function getPropAlias(prop, tagName) {
    const a = PropAliases[prop];
    return typeof a === "object" ? a[tagName] ? a["$"] : undefined : a;
}
const DelegatedEvents = /*#__PURE__*/ new Set([
    "beforeinput",
    "click",
    "dblclick",
    "contextmenu",
    "focusin",
    "focusout",
    "input",
    "keydown",
    "keyup",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "pointerdown",
    "pointermove",
    "pointerout",
    "pointerover",
    "pointerup",
    "touchend",
    "touchmove",
    "touchstart"
]);
const SVGElements = /*#__PURE__*/ new Set([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "circle",
    "clipPath",
    "color-profile",
    "cursor",
    "defs",
    "desc",
    "ellipse",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "filter",
    "font",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignObject",
    "g",
    "glyph",
    "glyphRef",
    "hkern",
    "image",
    "line",
    "linearGradient",
    "marker",
    "mask",
    "metadata",
    "missing-glyph",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "set",
    "stop",
    "svg",
    "switch",
    "symbol",
    "text",
    "textPath",
    "tref",
    "tspan",
    "use",
    "view",
    "vkern"
]);
const SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
};
const DOMElements = /*#__PURE__*/ new Set([
    "html",
    "base",
    "head",
    "link",
    "meta",
    "style",
    "title",
    "body",
    "address",
    "article",
    "aside",
    "footer",
    "header",
    "main",
    "nav",
    "section",
    "body",
    "blockquote",
    "dd",
    "div",
    "dl",
    "dt",
    "figcaption",
    "figure",
    "hr",
    "li",
    "ol",
    "p",
    "pre",
    "ul",
    "a",
    "abbr",
    "b",
    "bdi",
    "bdo",
    "br",
    "cite",
    "code",
    "data",
    "dfn",
    "em",
    "i",
    "kbd",
    "mark",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "time",
    "u",
    "var",
    "wbr",
    "area",
    "audio",
    "img",
    "map",
    "track",
    "video",
    "embed",
    "iframe",
    "object",
    "param",
    "picture",
    "portal",
    "source",
    "svg",
    "math",
    "canvas",
    "noscript",
    "script",
    "del",
    "ins",
    "caption",
    "col",
    "colgroup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "button",
    "datalist",
    "fieldset",
    "form",
    "input",
    "label",
    "legend",
    "meter",
    "optgroup",
    "option",
    "output",
    "progress",
    "select",
    "textarea",
    "details",
    "dialog",
    "menu",
    "summary",
    "details",
    "slot",
    "template",
    "acronym",
    "applet",
    "basefont",
    "bgsound",
    "big",
    "blink",
    "center",
    "content",
    "dir",
    "font",
    "frame",
    "frameset",
    "hgroup",
    "image",
    "keygen",
    "marquee",
    "menuitem",
    "nobr",
    "noembed",
    "noframes",
    "plaintext",
    "rb",
    "rtc",
    "shadow",
    "spacer",
    "strike",
    "tt",
    "xmp",
    "a",
    "abbr",
    "acronym",
    "address",
    "applet",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "basefont",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "frame",
    "frameset",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "image",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "nobr",
    "noembed",
    "noframes",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "plaintext",
    "portal",
    "pre",
    "progress",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "shadow",
    "slot",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "xmp",
    "input",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6"
]);
function reconcileArrays(parentNode, a, b) {
    let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
    while(aStart < aEnd || bStart < bEnd){
        if (a[aStart] === b[bStart]) {
            aStart++;
            bStart++;
            continue;
        }
        while(a[aEnd - 1] === b[bEnd - 1]){
            aEnd--;
            bEnd--;
        }
        if (aEnd === aStart) {
            const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
            while(bStart < bEnd)parentNode.insertBefore(b[bStart++], node);
        } else if (bEnd === bStart) while(aStart < aEnd){
            if (!map || !map.has(a[aStart])) a[aStart].remove();
            aStart++;
        }
        else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
            const node1 = a[--aEnd].nextSibling;
            parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
            parentNode.insertBefore(b[--bEnd], node1);
            a[aEnd] = b[bEnd];
        } else {
            if (!map) {
                map = new Map();
                let i = bStart;
                while(i < bEnd)map.set(b[i], i++);
            }
            const index = map.get(a[aStart]);
            if (index != null) {
                if (bStart < index && index < bEnd) {
                    let i1 = aStart, sequence = 1, t;
                    while(++i1 < aEnd && i1 < bEnd){
                        if ((t = map.get(a[i1])) == null || t !== index + sequence) break;
                        sequence++;
                    }
                    if (sequence > index - bStart) {
                        const node2 = a[aStart];
                        while(bStart < index)parentNode.insertBefore(b[bStart++], node2);
                    } else parentNode.replaceChild(b[bStart++], a[aStart++]);
                } else aStart++;
            } else a[aStart++].remove();
        }
    }
}
const $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
    let disposer;
    (0, _solidJs.createRoot)((dispose)=>{
        disposer = dispose;
        element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);
    }, options.owner);
    return ()=>{
        disposer();
        element.textContent = "";
    };
}
function template(html, isCE, isSVG) {
    let node;
    const create = ()=>{
        const t = document.createElement("template");
        t.innerHTML = html;
        return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;
    };
    const fn = isCE ? ()=>(0, _solidJs.untrack)(()=>document.importNode(node || (node = create()), true)) : ()=>(node || (node = create())).cloneNode(true);
    fn.cloneNode = fn;
    return fn;
}
function delegateEvents(eventNames, document1 = window.document) {
    const e = document1[$$EVENTS] || (document1[$$EVENTS] = new Set());
    for(let i = 0, l = eventNames.length; i < l; i++){
        const name = eventNames[i];
        if (!e.has(name)) {
            e.add(name);
            document1.addEventListener(name, eventHandler);
        }
    }
}
function clearDelegatedEvents(document1 = window.document) {
    if (document1[$$EVENTS]) {
        for (let name of document1[$$EVENTS].keys())document1.removeEventListener(name, eventHandler);
        delete document1[$$EVENTS];
    }
}
function setProperty(node, name, value) {
    !(0, _solidJs.sharedConfig).context && (node[name] = value);
}
function setAttribute(node, name, value) {
    if ((0, _solidJs.sharedConfig).context) return;
    if (value == null) node.removeAttribute(name);
    else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
    if ((0, _solidJs.sharedConfig).context) return;
    if (value == null) node.removeAttributeNS(namespace, name);
    else node.setAttributeNS(namespace, name, value);
}
function className(node, value) {
    if ((0, _solidJs.sharedConfig).context) return;
    if (value == null) node.removeAttribute("class");
    else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
    if (delegate) {
        if (Array.isArray(handler)) {
            node[`$$${name}`] = handler[0];
            node[`$$${name}Data`] = handler[1];
        } else node[`$$${name}`] = handler;
    } else if (Array.isArray(handler)) {
        const handlerFn = handler[0];
        node.addEventListener(name, handler[0] = (e)=>handlerFn.call(node, handler[1], e));
    } else node.addEventListener(name, handler);
}
function classList(node, value, prev = {}) {
    const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
    let i, len;
    for(i = 0, len = prevKeys.length; i < len; i++){
        const key = prevKeys[i];
        if (!key || key === "undefined" || value[key]) continue;
        toggleClassKey(node, key, false);
        delete prev[key];
    }
    for(i = 0, len = classKeys.length; i < len; i++){
        const key1 = classKeys[i], classValue = !!value[key1];
        if (!key1 || key1 === "undefined" || prev[key1] === classValue || !classValue) continue;
        toggleClassKey(node, key1, true);
        prev[key1] = classValue;
    }
    return prev;
}
function style(node, value, prev) {
    if (!value) return prev ? setAttribute(node, "style") : value;
    const nodeStyle = node.style;
    if (typeof value === "string") return nodeStyle.cssText = value;
    typeof prev === "string" && (nodeStyle.cssText = prev = undefined);
    prev || (prev = {});
    value || (value = {});
    let v, s;
    for(s in prev){
        value[s] == null && nodeStyle.removeProperty(s);
        delete prev[s];
    }
    for(s in value){
        v = value[s];
        if (v !== prev[s]) {
            nodeStyle.setProperty(s, v);
            prev[s] = v;
        }
    }
    return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
    const prevProps = {};
    if (!skipChildren) (0, _solidJs.createRenderEffect)(()=>prevProps.children = insertExpression(node, props.children, prevProps.children));
    (0, _solidJs.createRenderEffect)(()=>props.ref && props.ref(node));
    (0, _solidJs.createRenderEffect)(()=>assign(node, props, isSVG, true, prevProps, true));
    return prevProps;
}
function dynamicProperty(props, key) {
    const src = props[key];
    Object.defineProperty(props, key, {
        get () {
            return src();
        },
        enumerable: true
    });
    return props;
}
function use(fn, element, arg) {
    return (0, _solidJs.untrack)(()=>fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
    if (marker !== undefined && !initial) initial = [];
    if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
    (0, _solidJs.createRenderEffect)((current)=>insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
    props || (props = {});
    for(const prop in prevProps)if (!(prop in props)) {
        if (prop === "children") continue;
        prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);
    }
    for(const prop1 in props){
        if (prop1 === "children") {
            if (!skipChildren) insertExpression(node, props.children);
            continue;
        }
        const value = props[prop1];
        prevProps[prop1] = assignProp(node, prop1, value, prevProps[prop1], isSVG, skipRef);
    }
}
function hydrate$1(code, element, options = {}) {
    (0, _solidJs.sharedConfig).completed = globalThis._$HY.completed;
    (0, _solidJs.sharedConfig).events = globalThis._$HY.events;
    (0, _solidJs.sharedConfig).load = (id)=>globalThis._$HY.r[id];
    (0, _solidJs.sharedConfig).has = (id)=>id in globalThis._$HY.r;
    (0, _solidJs.sharedConfig).gather = (root)=>gatherHydratable(element, root);
    (0, _solidJs.sharedConfig).registry = new Map();
    (0, _solidJs.sharedConfig).context = {
        id: options.renderId || "",
        count: 0
    };
    gatherHydratable(element, options.renderId);
    const dispose = render(code, element, [
        ...element.childNodes
    ], options);
    (0, _solidJs.sharedConfig).context = null;
    return dispose;
}
function getNextElement(template) {
    let node, key;
    if (!(0, _solidJs.sharedConfig).context || !(node = (0, _solidJs.sharedConfig).registry.get(key = getHydrationKey()))) return template();
    if ((0, _solidJs.sharedConfig).completed) (0, _solidJs.sharedConfig).completed.add(node);
    (0, _solidJs.sharedConfig).registry.delete(key);
    return node;
}
function getNextMatch(el, nodeName) {
    while(el && el.localName !== nodeName)el = el.nextSibling;
    return el;
}
function getNextMarker(start) {
    let end = start, count = 0, current = [];
    if ((0, _solidJs.sharedConfig).context) while(end){
        if (end.nodeType === 8) {
            const v = end.nodeValue;
            if (v === "$") count++;
            else if (v === "/") {
                if (count === 0) return [
                    end,
                    current
                ];
                count--;
            }
        }
        current.push(end);
        end = end.nextSibling;
    }
    return [
        end,
        current
    ];
}
function runHydrationEvents() {
    if ((0, _solidJs.sharedConfig).events && !(0, _solidJs.sharedConfig).events.queued) {
        queueMicrotask(()=>{
            const { completed , events  } = (0, _solidJs.sharedConfig);
            events.queued = false;
            while(events.length){
                const [el, e] = events[0];
                if (!completed.has(el)) return;
                eventHandler(e);
                events.shift();
            }
        });
        (0, _solidJs.sharedConfig).events.queued = true;
    }
}
function toPropertyName(name) {
    return name.toLowerCase().replace(/-([a-z])/g, (_, w)=>w.toUpperCase());
}
function toggleClassKey(node, key, value) {
    const classNames = key.trim().split(/\s+/);
    for(let i = 0, nameLen = classNames.length; i < nameLen; i++)node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef) {
    let isCE, isProp, isChildProp, propAlias, forceProp;
    if (prop === "style") return style(node, value, prev);
    if (prop === "classList") return classList(node, value, prev);
    if (value === prev) return prev;
    if (prop === "ref") {
        if (!skipRef) value(node);
    } else if (prop.slice(0, 3) === "on:") {
        const e = prop.slice(3);
        prev && node.removeEventListener(e, prev);
        value && node.addEventListener(e, value);
    } else if (prop.slice(0, 10) === "oncapture:") {
        const e1 = prop.slice(10);
        prev && node.removeEventListener(e1, prev, true);
        value && node.addEventListener(e1, value, true);
    } else if (prop.slice(0, 2) === "on") {
        const name = prop.slice(2).toLowerCase();
        const delegate = DelegatedEvents.has(name);
        if (!delegate && prev) {
            const h = Array.isArray(prev) ? prev[0] : prev;
            node.removeEventListener(name, h);
        }
        if (delegate || value) {
            addEventListener(node, name, value, delegate);
            delegate && delegateEvents([
                name
            ]);
        }
    } else if (prop.slice(0, 5) === "attr:") setAttribute(node, prop.slice(5), value);
    else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-"))) {
        if (forceProp) {
            prop = prop.slice(5);
            isProp = true;
        } else if ((0, _solidJs.sharedConfig).context) return value;
        if (prop === "class" || prop === "className") className(node, value);
        else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
        else node[propAlias || prop] = value;
    } else {
        const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
        if (ns) setAttributeNS(node, ns, prop, value);
        else setAttribute(node, Aliases[prop] || prop, value);
    }
    return value;
}
function eventHandler(e) {
    const key = `$$${e.type}`;
    let node = e.composedPath && e.composedPath()[0] || e.target;
    if (e.target !== node) Object.defineProperty(e, "target", {
        configurable: true,
        value: node
    });
    Object.defineProperty(e, "currentTarget", {
        configurable: true,
        get () {
            return node || document;
        }
    });
    if ((0, _solidJs.sharedConfig).registry && !(0, _solidJs.sharedConfig).done) (0, _solidJs.sharedConfig).done = _$HY.done = true;
    while(node){
        const handler = node[key];
        if (handler && !node.disabled) {
            const data = node[`${key}Data`];
            data !== undefined ? handler.call(node, data, e) : handler.call(node, e);
            if (e.cancelBubble) return;
        }
        node = node._$host || node.parentNode || node.host;
    }
}
function insertExpression(parent, value, current, marker, unwrapArray) {
    if ((0, _solidJs.sharedConfig).context) {
        !current && (current = [
            ...parent.childNodes
        ]);
        let cleaned = [];
        for(let i = 0; i < current.length; i++){
            const node = current[i];
            if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
            else cleaned.push(node);
        }
        current = cleaned;
    }
    while(typeof current === "function")current = current();
    if (value === current) return current;
    const t = typeof value, multi = marker !== undefined;
    parent = multi && current[0] && current[0].parentNode || parent;
    if (t === "string" || t === "number") {
        if ((0, _solidJs.sharedConfig).context) return current;
        if (t === "number") value = value.toString();
        if (multi) {
            let node1 = current[0];
            if (node1 && node1.nodeType === 3) node1.data !== value && (node1.data = value);
            else node1 = document.createTextNode(value);
            current = cleanChildren(parent, current, marker, node1);
        } else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
        else current = parent.textContent = value;
    } else if (value == null || t === "boolean") {
        if ((0, _solidJs.sharedConfig).context) return current;
        current = cleanChildren(parent, current, marker);
    } else if (t === "function") {
        (0, _solidJs.createRenderEffect)(()=>{
            let v = value();
            while(typeof v === "function")v = v();
            current = insertExpression(parent, v, current, marker);
        });
        return ()=>current;
    } else if (Array.isArray(value)) {
        const array = [];
        const currentArray = current && Array.isArray(current);
        if (normalizeIncomingArray(array, value, current, unwrapArray)) {
            (0, _solidJs.createRenderEffect)(()=>current = insertExpression(parent, array, current, marker, true));
            return ()=>current;
        }
        if ((0, _solidJs.sharedConfig).context) {
            if (!array.length) return current;
            if (marker === undefined) return [
                ...parent.childNodes
            ];
            let node2 = array[0];
            let nodes = [
                node2
            ];
            while((node2 = node2.nextSibling) !== marker)nodes.push(node2);
            return current = nodes;
        }
        if (array.length === 0) {
            current = cleanChildren(parent, current, marker);
            if (multi) return current;
        } else if (currentArray) {
            if (current.length === 0) appendNodes(parent, array, marker);
            else reconcileArrays(parent, current, array);
        } else {
            current && cleanChildren(parent);
            appendNodes(parent, array);
        }
        current = array;
    } else if (value.nodeType) {
        if ((0, _solidJs.sharedConfig).context && value.parentNode) return current = multi ? [
            value
        ] : value;
        if (Array.isArray(current)) {
            if (multi) return current = cleanChildren(parent, current, marker, value);
            cleanChildren(parent, current, null, value);
        } else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
        else parent.replaceChild(value, parent.firstChild);
        current = value;
    }
    return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
    let dynamic = false;
    for(let i = 0, len = array.length; i < len; i++){
        let item = array[i], prev = current && current[i], t;
        if (item == null || item === true || item === false) ;
        else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
        else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
        else if (t === "function") {
            if (unwrap) {
                while(typeof item === "function")item = item();
                dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [
                    item
                ], Array.isArray(prev) ? prev : [
                    prev
                ]) || dynamic;
            } else {
                normalized.push(item);
                dynamic = true;
            }
        } else {
            const value = String(item);
            if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
            else normalized.push(document.createTextNode(value));
        }
    }
    return dynamic;
}
function appendNodes(parent, array, marker = null) {
    for(let i = 0, len = array.length; i < len; i++)parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
    if (marker === undefined) return parent.textContent = "";
    const node = replacement || document.createTextNode("");
    if (current.length) {
        let inserted = false;
        for(let i = current.length - 1; i >= 0; i--){
            const el = current[i];
            if (node !== el) {
                const isParent = el.parentNode === parent;
                if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
                else isParent && el.remove();
            } else inserted = true;
        }
    } else parent.insertBefore(node, marker);
    return [
        node
    ];
}
function gatherHydratable(element, root) {
    const templates = element.querySelectorAll(`*[data-hk]`);
    for(let i = 0; i < templates.length; i++){
        const node = templates[i];
        const key = node.getAttribute("data-hk");
        if ((!root || key.startsWith(root)) && !(0, _solidJs.sharedConfig).registry.has(key)) (0, _solidJs.sharedConfig).registry.set(key, node);
    }
}
function getHydrationKey() {
    const hydrate = (0, _solidJs.sharedConfig).context;
    return `${hydrate.id}${hydrate.count++}`;
}
function NoHydration(props) {
    return (0, _solidJs.sharedConfig).context ? undefined : props.children;
}
function Hydration(props) {
    return props.children;
}
const voidFn = ()=>undefined;
const RequestContext = Symbol();
function innerHTML(parent, content) {
    !(0, _solidJs.sharedConfig).context && (parent.innerHTML = content);
}
function throwInBrowser(func) {
    const err = new Error(`${func.name} is not supported in the browser, returning undefined`);
    console.error(err);
}
function renderToString(fn, options) {
    throwInBrowser(renderToString);
}
function renderToStringAsync(fn, options) {
    throwInBrowser(renderToStringAsync);
}
function renderToStream(fn, options) {
    throwInBrowser(renderToStream);
}
function ssr(template, ...nodes) {}
function ssrElement(name, props, children, needsId) {}
function ssrClassList(value) {}
function ssrStyle(value) {}
function ssrAttribute(key, value) {}
function ssrHydrationKey() {}
function resolveSSRNode(node) {}
function escape(html) {}
function ssrSpread(props, isSVG, skipChildren) {}
const isServer = false;
const isDev = false;
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
    return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
const hydrate = (...args)=>{
    (0, _solidJs.enableHydration)();
    return hydrate$1(...args);
};
function Portal(props) {
    const { useShadow  } = props, marker = document.createTextNode(""), mount = ()=>props.mount || document.body, owner = (0, _solidJs.getOwner)();
    let content;
    let hydrating = !!(0, _solidJs.sharedConfig).context;
    (0, _solidJs.createEffect)(()=>{
        if (hydrating) (0, _solidJs.getOwner)().user = hydrating = false;
        content || (content = (0, _solidJs.runWithOwner)(owner, ()=>(0, _solidJs.createMemo)(()=>props.children)));
        const el = mount();
        if (el instanceof HTMLHeadElement) {
            const [clean, setClean] = (0, _solidJs.createSignal)(false);
            const cleanup = ()=>setClean(true);
            (0, _solidJs.createRoot)((dispose)=>insert(el, ()=>!clean() ? content() : dispose(), null));
            (0, _solidJs.onCleanup)(cleanup);
        } else {
            const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
                mode: "open"
            }) : container;
            Object.defineProperty(container, "_$host", {
                get () {
                    return marker.parentNode;
                },
                configurable: true
            });
            insert(renderRoot, content);
            el.appendChild(container);
            props.ref && props.ref(container);
            (0, _solidJs.onCleanup)(()=>el.removeChild(container));
        }
    }, undefined, {
        render: !hydrating
    });
    return marker;
}
function Dynamic(props) {
    const [p, others] = (0, _solidJs.splitProps)(props, [
        "component"
    ]);
    const cached = (0, _solidJs.createMemo)(()=>p.component);
    return (0, _solidJs.createMemo)(()=>{
        const component = cached();
        switch(typeof component){
            case "function":
                return (0, _solidJs.untrack)(()=>component(others));
            case "string":
                const isSvg = SVGElements.has(component);
                const el = (0, _solidJs.sharedConfig).context ? getNextElement() : createElement(component, isSvg);
                spread(el, others, isSvg);
                return el;
        }
    });
}

},{"solid-js":"f1z31","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"f1z31":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$DEVCOMP", ()=>$DEVCOMP);
parcelHelpers.export(exports, "$PROXY", ()=>$PROXY);
parcelHelpers.export(exports, "$TRACK", ()=>$TRACK);
parcelHelpers.export(exports, "DEV", ()=>DEV);
parcelHelpers.export(exports, "ErrorBoundary", ()=>ErrorBoundary);
parcelHelpers.export(exports, "For", ()=>For);
parcelHelpers.export(exports, "Index", ()=>Index);
parcelHelpers.export(exports, "Match", ()=>Match);
parcelHelpers.export(exports, "Show", ()=>Show);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "SuspenseList", ()=>SuspenseList);
parcelHelpers.export(exports, "Switch", ()=>Switch);
parcelHelpers.export(exports, "batch", ()=>batch);
parcelHelpers.export(exports, "cancelCallback", ()=>cancelCallback);
parcelHelpers.export(exports, "catchError", ()=>catchError);
parcelHelpers.export(exports, "children", ()=>children);
parcelHelpers.export(exports, "createComponent", ()=>createComponent);
parcelHelpers.export(exports, "createComputed", ()=>createComputed);
parcelHelpers.export(exports, "createContext", ()=>createContext);
parcelHelpers.export(exports, "createDeferred", ()=>createDeferred);
parcelHelpers.export(exports, "createEffect", ()=>createEffect);
parcelHelpers.export(exports, "createMemo", ()=>createMemo);
parcelHelpers.export(exports, "createReaction", ()=>createReaction);
parcelHelpers.export(exports, "createRenderEffect", ()=>createRenderEffect);
parcelHelpers.export(exports, "createResource", ()=>createResource);
parcelHelpers.export(exports, "createRoot", ()=>createRoot);
parcelHelpers.export(exports, "createSelector", ()=>createSelector);
parcelHelpers.export(exports, "createSignal", ()=>createSignal);
parcelHelpers.export(exports, "createUniqueId", ()=>createUniqueId);
parcelHelpers.export(exports, "enableExternalSource", ()=>enableExternalSource);
parcelHelpers.export(exports, "enableHydration", ()=>enableHydration);
parcelHelpers.export(exports, "enableScheduling", ()=>enableScheduling);
parcelHelpers.export(exports, "equalFn", ()=>equalFn);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "getListener", ()=>getListener);
parcelHelpers.export(exports, "getOwner", ()=>getOwner);
parcelHelpers.export(exports, "indexArray", ()=>indexArray);
parcelHelpers.export(exports, "lazy", ()=>lazy);
parcelHelpers.export(exports, "mapArray", ()=>mapArray);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "observable", ()=>observable);
parcelHelpers.export(exports, "on", ()=>on);
parcelHelpers.export(exports, "onCleanup", ()=>onCleanup);
parcelHelpers.export(exports, "onError", ()=>onError);
parcelHelpers.export(exports, "onMount", ()=>onMount);
parcelHelpers.export(exports, "requestCallback", ()=>requestCallback);
parcelHelpers.export(exports, "resetErrorBoundaries", ()=>resetErrorBoundaries);
parcelHelpers.export(exports, "runWithOwner", ()=>runWithOwner);
parcelHelpers.export(exports, "sharedConfig", ()=>sharedConfig);
parcelHelpers.export(exports, "splitProps", ()=>splitProps);
parcelHelpers.export(exports, "startTransition", ()=>startTransition);
parcelHelpers.export(exports, "untrack", ()=>untrack);
parcelHelpers.export(exports, "useContext", ()=>useContext);
parcelHelpers.export(exports, "useTransition", ()=>useTransition);
let taskIdCounter = 1, isCallbackScheduled = false, isPerformingWork = false, taskQueue = [], currentTask = null, shouldYieldToHost = null, yieldInterval = 5, deadline = 0, maxYieldInterval = 300, scheduleCallback = null, scheduledCallback = null;
const maxSigned31BitInt = 1073741823;
function setupScheduler() {
    const channel = new MessageChannel(), port = channel.port2;
    scheduleCallback = ()=>port.postMessage(null);
    channel.port1.onmessage = ()=>{
        if (scheduledCallback !== null) {
            const currentTime = performance.now();
            deadline = currentTime + yieldInterval;
            const hasTimeRemaining = true;
            try {
                const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);
                if (!hasMoreWork) scheduledCallback = null;
                else port.postMessage(null);
            } catch (error) {
                port.postMessage(null);
                throw error;
            }
        }
    };
    if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {
        const scheduling = navigator.scheduling;
        shouldYieldToHost = ()=>{
            const currentTime = performance.now();
            if (currentTime >= deadline) {
                if (scheduling.isInputPending()) return true;
                return currentTime >= maxYieldInterval;
            } else return false;
        };
    } else shouldYieldToHost = ()=>performance.now() >= deadline;
}
function enqueue(taskQueue, task) {
    function findIndex() {
        let m = 0;
        let n = taskQueue.length - 1;
        while(m <= n){
            const k = n + m >> 1;
            const cmp = task.expirationTime - taskQueue[k].expirationTime;
            if (cmp > 0) m = k + 1;
            else if (cmp < 0) n = k - 1;
            else return k;
        }
        return m;
    }
    taskQueue.splice(findIndex(), 0, task);
}
function requestCallback(fn, options) {
    if (!scheduleCallback) setupScheduler();
    let startTime = performance.now(), timeout = maxSigned31BitInt;
    if (options && options.timeout) timeout = options.timeout;
    const newTask = {
        id: taskIdCounter++,
        fn,
        startTime,
        expirationTime: startTime + timeout
    };
    enqueue(taskQueue, newTask);
    if (!isCallbackScheduled && !isPerformingWork) {
        isCallbackScheduled = true;
        scheduledCallback = flushWork;
        scheduleCallback();
    }
    return newTask;
}
function cancelCallback(task) {
    task.fn = null;
}
function flushWork(hasTimeRemaining, initialTime) {
    isCallbackScheduled = false;
    isPerformingWork = true;
    try {
        return workLoop(hasTimeRemaining, initialTime);
    } finally{
        currentTask = null;
        isPerformingWork = false;
    }
}
function workLoop(hasTimeRemaining, initialTime) {
    let currentTime = initialTime;
    currentTask = taskQueue[0] || null;
    while(currentTask !== null){
        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) break;
        const callback = currentTask.fn;
        if (callback !== null) {
            currentTask.fn = null;
            const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
            callback(didUserCallbackTimeout);
            currentTime = performance.now();
            if (currentTask === taskQueue[0]) taskQueue.shift();
        } else taskQueue.shift();
        currentTask = taskQueue[0] || null;
    }
    return currentTask !== null;
}
const sharedConfig = {
    context: undefined,
    registry: undefined
};
function setHydrateContext(context) {
    sharedConfig.context = context;
}
function nextHydrateContext() {
    return {
        ...sharedConfig.context,
        id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
        count: 0
    };
}
const equalFn = (a, b)=>a === b;
const $PROXY = Symbol("solid-proxy");
const $TRACK = Symbol("solid-track");
const $DEVCOMP = Symbol("solid-dev-component");
const signalOptions = {
    equals: equalFn
};
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
};
const NO_INIT = {};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
    const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === undefined ? owner : detachedOwner, root = unowned ? UNOWNED : {
        owned: null,
        cleanups: null,
        context: current ? current.context : null,
        owner: current
    }, updateFn = unowned ? fn : ()=>fn(()=>untrack(()=>cleanNode(root)));
    Owner = root;
    Listener = null;
    try {
        return runUpdates(updateFn, true);
    } finally{
        Listener = listener;
        Owner = owner;
    }
}
function createSignal(value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const s = {
        value,
        observers: null,
        observerSlots: null,
        comparator: options.equals || undefined
    };
    const setter = (value)=>{
        if (typeof value === "function") {
            if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);
            else value = value(s.value);
        }
        return writeSignal(s, value);
    };
    return [
        readSignal.bind(s),
        setter
    ];
}
function createComputed(fn, value, options) {
    const c = createComputation(fn, value, true, STALE);
    if (Scheduler && Transition && Transition.running) Updates.push(c);
    else updateComputation(c);
}
function createRenderEffect(fn, value, options) {
    const c = createComputation(fn, value, false, STALE);
    if (Scheduler && Transition && Transition.running) Updates.push(c);
    else updateComputation(c);
}
function createEffect(fn, value, options) {
    runEffects = runUserEffects;
    const c = createComputation(fn, value, false, STALE), s = SuspenseContext && useContext(SuspenseContext);
    if (s) c.suspense = s;
    if (!options || !options.render) c.user = true;
    Effects ? Effects.push(c) : updateComputation(c);
}
function createReaction(onInvalidate, options) {
    let fn;
    const c = createComputation(()=>{
        fn ? fn() : untrack(onInvalidate);
        fn = undefined;
    }, undefined, false, 0), s = SuspenseContext && useContext(SuspenseContext);
    if (s) c.suspense = s;
    c.user = true;
    return (tracking)=>{
        fn = tracking;
        updateComputation(c);
    };
}
function createMemo(fn, value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const c = createComputation(fn, value, true, 0);
    c.observers = null;
    c.observerSlots = null;
    c.comparator = options.equals || undefined;
    if (Scheduler && Transition && Transition.running) {
        c.tState = STALE;
        Updates.push(c);
    } else updateComputation(c);
    return readSignal.bind(c);
}
function isPromise(v) {
    return v && typeof v === "object" && "then" in v;
}
function createResource(pSource, pFetcher, pOptions) {
    let source;
    let fetcher;
    let options;
    if (arguments.length === 2 && typeof pFetcher === "object" || arguments.length === 1) {
        source = true;
        fetcher = pSource;
        options = pFetcher || {};
    } else {
        source = pSource;
        fetcher = pFetcher;
        options = pOptions || {};
    }
    let pr = null, initP = NO_INIT, id = null, loadedUnderTransition = false, scheduled = false, resolved = "initialValue" in options, dynamic = typeof source === "function" && createMemo(source);
    const contexts = new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(undefined), [track, trigger] = createSignal(undefined, {
        equals: false
    }), [state, setState] = createSignal(resolved ? "ready" : "unresolved");
    if (sharedConfig.context) {
        id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
        let v;
        if (options.ssrLoadFrom === "initial") initP = options.initialValue;
        else if (sharedConfig.load && (v = sharedConfig.load(id))) initP = v;
    }
    function loadEnd(p, v, error, key) {
        if (pr === p) {
            pr = null;
            key !== undefined && (resolved = true);
            if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(()=>options.onHydrated(key, {
                    value: v
                }));
            initP = NO_INIT;
            if (Transition && p && loadedUnderTransition) {
                Transition.promises.delete(p);
                loadedUnderTransition = false;
                runUpdates(()=>{
                    Transition.running = true;
                    completeLoad(v, error);
                }, false);
            } else completeLoad(v, error);
        }
        return v;
    }
    function completeLoad(v, err) {
        runUpdates(()=>{
            if (err === undefined) setValue(()=>v);
            setState(err !== undefined ? "errored" : resolved ? "ready" : "unresolved");
            setError(err);
            for (const c of contexts.keys())c.decrement();
            contexts.clear();
        }, false);
    }
    function read() {
        const c = SuspenseContext && useContext(SuspenseContext), v = value(), err = error();
        if (err !== undefined && !pr) throw err;
        if (Listener && !Listener.user && c) createComputed(()=>{
            track();
            if (pr) {
                if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);
                else if (!contexts.has(c)) {
                    c.increment();
                    contexts.add(c);
                }
            }
        });
        return v;
    }
    function load(refetching = true) {
        if (refetching !== false && scheduled) return;
        scheduled = false;
        const lookup = dynamic ? dynamic() : source;
        loadedUnderTransition = Transition && Transition.running;
        if (lookup == null || lookup === false) {
            loadEnd(pr, untrack(value));
            return;
        }
        if (Transition && pr) Transition.promises.delete(pr);
        const p = initP !== NO_INIT ? initP : untrack(()=>fetcher(lookup, {
                value: value(),
                refetching
            }));
        if (!isPromise(p)) {
            loadEnd(pr, p, undefined, lookup);
            return p;
        }
        pr = p;
        if ("value" in p) {
            if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);
            else loadEnd(pr, undefined, undefined, lookup);
            return p;
        }
        scheduled = true;
        queueMicrotask(()=>scheduled = false);
        runUpdates(()=>{
            setState(resolved ? "refreshing" : "pending");
            trigger();
        }, false);
        return p.then((v)=>loadEnd(p, v, undefined, lookup), (e)=>loadEnd(p, undefined, castError(e), lookup));
    }
    Object.defineProperties(read, {
        state: {
            get: ()=>state()
        },
        error: {
            get: ()=>error()
        },
        loading: {
            get () {
                const s = state();
                return s === "pending" || s === "refreshing";
            }
        },
        latest: {
            get () {
                if (!resolved) return read();
                const err = error();
                if (err && !pr) throw err;
                return value();
            }
        }
    });
    if (dynamic) createComputed(()=>load(false));
    else load(false);
    return [
        read,
        {
            refetch: load,
            mutate: setValue
        }
    ];
}
function createDeferred(source, options) {
    let t, timeout = options ? options.timeoutMs : undefined;
    const node = createComputation(()=>{
        if (!t || !t.fn) t = requestCallback(()=>setDeferred(()=>node.value), timeout !== undefined ? {
            timeout
        } : undefined);
        return source();
    }, undefined, true);
    const [deferred, setDeferred] = createSignal(Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, options);
    updateComputation(node);
    setDeferred(()=>Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
    return deferred;
}
function createSelector(source, fn = equalFn, options) {
    const subs = new Map();
    const node = createComputation((p)=>{
        const v = source();
        for (const [key, val] of subs.entries())if (fn(key, v) !== fn(key, p)) for (const c of val.values()){
            c.state = STALE;
            if (c.pure) Updates.push(c);
            else Effects.push(c);
        }
        return v;
    }, undefined, true, STALE);
    updateComputation(node);
    return (key)=>{
        const listener = Listener;
        if (listener) {
            let l;
            if (l = subs.get(key)) l.add(listener);
            else subs.set(key, l = new Set([
                listener
            ]));
            onCleanup(()=>{
                l.delete(listener);
                !l.size && subs.delete(key);
            });
        }
        return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
    };
}
function batch(fn) {
    return runUpdates(fn, false);
}
function untrack(fn) {
    if (!ExternalSourceConfig && Listener === null) return fn();
    const listener = Listener;
    Listener = null;
    try {
        if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
        return fn();
    } finally{
        Listener = listener;
    }
}
function on(deps, fn, options) {
    const isArray = Array.isArray(deps);
    let prevInput;
    let defer = options && options.defer;
    return (prevValue)=>{
        let input;
        if (isArray) {
            input = Array(deps.length);
            for(let i = 0; i < deps.length; i++)input[i] = deps[i]();
        } else input = deps();
        if (defer) {
            defer = false;
            return undefined;
        }
        const result = untrack(()=>fn(input, prevInput, prevValue));
        prevInput = input;
        return result;
    };
}
function onMount(fn) {
    createEffect(()=>untrack(fn));
}
function onCleanup(fn) {
    if (Owner === null) ;
    else if (Owner.cleanups === null) Owner.cleanups = [
        fn
    ];
    else Owner.cleanups.push(fn);
    return fn;
}
function catchError(fn, handler) {
    ERROR || (ERROR = Symbol("error"));
    Owner = createComputation(undefined, undefined, true);
    Owner.context = {
        ...Owner.context,
        [ERROR]: [
            handler
        ]
    };
    if (Transition && Transition.running) Transition.sources.add(Owner);
    try {
        return fn();
    } catch (err) {
        handleError(err);
    } finally{
        Owner = Owner.owner;
    }
}
function getListener() {
    return Listener;
}
function getOwner() {
    return Owner;
}
function runWithOwner(o, fn) {
    const prev = Owner;
    const prevListener = Listener;
    Owner = o;
    Listener = null;
    try {
        return runUpdates(fn, true);
    } catch (err) {
        handleError(err);
    } finally{
        Owner = prev;
        Listener = prevListener;
    }
}
function enableScheduling(scheduler = requestCallback) {
    Scheduler = scheduler;
}
function startTransition(fn) {
    if (Transition && Transition.running) {
        fn();
        return Transition.done;
    }
    const l = Listener;
    const o = Owner;
    return Promise.resolve().then(()=>{
        Listener = l;
        Owner = o;
        let t;
        if (Scheduler || SuspenseContext) {
            t = Transition || (Transition = {
                sources: new Set(),
                effects: [],
                promises: new Set(),
                disposed: new Set(),
                queue: new Set(),
                running: true
            });
            t.done || (t.done = new Promise((res)=>t.resolve = res));
            t.running = true;
        }
        runUpdates(fn, false);
        Listener = Owner = null;
        return t ? t.done : undefined;
    });
}
const [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);
function useTransition() {
    return [
        transPending,
        startTransition
    ];
}
function resumeEffects(e) {
    Effects.push.apply(Effects, e);
    e.length = 0;
}
function createContext(defaultValue, options) {
    const id = Symbol("context");
    return {
        id,
        Provider: createProvider(id),
        defaultValue
    };
}
function useContext(context) {
    return Owner && Owner.context && Owner.context[context.id] !== undefined ? Owner.context[context.id] : context.defaultValue;
}
function children(fn) {
    const children = createMemo(fn);
    const memo = createMemo(()=>resolveChildren(children()));
    memo.toArray = ()=>{
        const c = memo();
        return Array.isArray(c) ? c : c != null ? [
            c
        ] : [];
    };
    return memo;
}
let SuspenseContext;
function getSuspenseContext() {
    return SuspenseContext || (SuspenseContext = createContext());
}
function enableExternalSource(factory, untrack = (fn)=>fn()) {
    if (ExternalSourceConfig) {
        const { factory: oldFactory , untrack: oldUntrack  } = ExternalSourceConfig;
        ExternalSourceConfig = {
            factory: (fn, trigger)=>{
                const oldSource = oldFactory(fn, trigger);
                const source = factory((x)=>oldSource.track(x), trigger);
                return {
                    track: (x)=>source.track(x),
                    dispose () {
                        source.dispose();
                        oldSource.dispose();
                    }
                };
            },
            untrack: (fn)=>oldUntrack(()=>untrack(fn))
        };
    } else ExternalSourceConfig = {
        factory,
        untrack
    };
}
function readSignal() {
    const runningTransition = Transition && Transition.running;
    if (this.sources && (runningTransition ? this.tState : this.state)) {
        if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
        else {
            const updates = Updates;
            Updates = null;
            runUpdates(()=>lookUpstream(this), false);
            Updates = updates;
        }
    }
    if (Listener) {
        const sSlot = this.observers ? this.observers.length : 0;
        if (!Listener.sources) {
            Listener.sources = [
                this
            ];
            Listener.sourceSlots = [
                sSlot
            ];
        } else {
            Listener.sources.push(this);
            Listener.sourceSlots.push(sSlot);
        }
        if (!this.observers) {
            this.observers = [
                Listener
            ];
            this.observerSlots = [
                Listener.sources.length - 1
            ];
        } else {
            this.observers.push(Listener);
            this.observerSlots.push(Listener.sources.length - 1);
        }
    }
    if (runningTransition && Transition.sources.has(this)) return this.tValue;
    return this.value;
}
function writeSignal(node, value, isComp) {
    let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
    if (!node.comparator || !node.comparator(current, value)) {
        if (Transition) {
            const TransitionRunning = Transition.running;
            if (TransitionRunning || !isComp && Transition.sources.has(node)) {
                Transition.sources.add(node);
                node.tValue = value;
            }
            if (!TransitionRunning) node.value = value;
        } else node.value = value;
        if (node.observers && node.observers.length) runUpdates(()=>{
            for(let i = 0; i < node.observers.length; i += 1){
                const o = node.observers[i];
                const TransitionRunning = Transition && Transition.running;
                if (TransitionRunning && Transition.disposed.has(o)) continue;
                if (TransitionRunning ? !o.tState : !o.state) {
                    if (o.pure) Updates.push(o);
                    else Effects.push(o);
                    if (o.observers) markDownstream(o);
                }
                if (!TransitionRunning) o.state = STALE;
                else o.tState = STALE;
            }
            if (Updates.length > 10e5) {
                Updates = [];
                throw new Error();
            }
        }, false);
    }
    return value;
}
function updateComputation(node) {
    if (!node.fn) return;
    cleanNode(node);
    const time = ExecCount;
    runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
    if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(()=>{
        runUpdates(()=>{
            Transition && (Transition.running = true);
            Listener = Owner = node;
            runComputation(node, node.tValue, time);
            Listener = Owner = null;
        }, false);
    });
}
function runComputation(node, value, time) {
    let nextValue;
    const owner = Owner, listener = Listener;
    Listener = Owner = node;
    try {
        nextValue = node.fn(value);
    } catch (err) {
        if (node.pure) {
            if (Transition && Transition.running) {
                node.tState = STALE;
                node.tOwned && node.tOwned.forEach(cleanNode);
                node.tOwned = undefined;
            } else {
                node.state = STALE;
                node.owned && node.owned.forEach(cleanNode);
                node.owned = null;
            }
        }
        node.updatedAt = time + 1;
        return handleError(err);
    } finally{
        Listener = listener;
        Owner = owner;
    }
    if (!node.updatedAt || node.updatedAt <= time) {
        if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
        else if (Transition && Transition.running && node.pure) {
            Transition.sources.add(node);
            node.tValue = nextValue;
        } else node.value = nextValue;
        node.updatedAt = time;
    }
}
function createComputation(fn, init, pure, state = STALE, options) {
    const c = {
        fn,
        state: state,
        updatedAt: null,
        owned: null,
        sources: null,
        sourceSlots: null,
        cleanups: null,
        value: init,
        owner: Owner,
        context: Owner ? Owner.context : null,
        pure
    };
    if (Transition && Transition.running) {
        c.state = 0;
        c.tState = state;
    }
    if (Owner === null) ;
    else if (Owner !== UNOWNED) {
        if (Transition && Transition.running && Owner.pure) {
            if (!Owner.tOwned) Owner.tOwned = [
                c
            ];
            else Owner.tOwned.push(c);
        } else if (!Owner.owned) Owner.owned = [
            c
        ];
        else Owner.owned.push(c);
    }
    if (ExternalSourceConfig && c.fn) {
        const [track, trigger] = createSignal(undefined, {
            equals: false
        });
        const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
        onCleanup(()=>ordinary.dispose());
        const triggerInTransition = ()=>startTransition(trigger).then(()=>inTransition.dispose());
        const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
        c.fn = (x)=>{
            track();
            return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
        };
    }
    return c;
}
function runTop(node) {
    const runningTransition = Transition && Transition.running;
    if ((runningTransition ? node.tState : node.state) === 0) return;
    if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
    if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
    const ancestors = [
        node
    ];
    while((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)){
        if (runningTransition && Transition.disposed.has(node)) return;
        if (runningTransition ? node.tState : node.state) ancestors.push(node);
    }
    for(let i = ancestors.length - 1; i >= 0; i--){
        node = ancestors[i];
        if (runningTransition) {
            let top = node, prev = ancestors[i + 1];
            while((top = top.owner) && top !== prev){
                if (Transition.disposed.has(top)) return;
            }
        }
        if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
        else if ((runningTransition ? node.tState : node.state) === PENDING) {
            const updates = Updates;
            Updates = null;
            runUpdates(()=>lookUpstream(node, ancestors[0]), false);
            Updates = updates;
        }
    }
}
function runUpdates(fn, init) {
    if (Updates) return fn();
    let wait = false;
    if (!init) Updates = [];
    if (Effects) wait = true;
    else Effects = [];
    ExecCount++;
    try {
        const res = fn();
        completeUpdates(wait);
        return res;
    } catch (err) {
        if (!wait) Effects = null;
        Updates = null;
        handleError(err);
    }
}
function completeUpdates(wait) {
    if (Updates) {
        if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
        else runQueue(Updates);
        Updates = null;
    }
    if (wait) return;
    let res;
    if (Transition) {
        if (!Transition.promises.size && !Transition.queue.size) {
            const sources = Transition.sources;
            const disposed = Transition.disposed;
            Effects.push.apply(Effects, Transition.effects);
            res = Transition.resolve;
            for (const e of Effects){
                "tState" in e && (e.state = e.tState);
                delete e.tState;
            }
            Transition = null;
            runUpdates(()=>{
                for (const d of disposed)cleanNode(d);
                for (const v of sources){
                    v.value = v.tValue;
                    if (v.owned) for(let i = 0, len = v.owned.length; i < len; i++)cleanNode(v.owned[i]);
                    if (v.tOwned) v.owned = v.tOwned;
                    delete v.tValue;
                    delete v.tOwned;
                    v.tState = 0;
                }
                setTransPending(false);
            }, false);
        } else if (Transition.running) {
            Transition.running = false;
            Transition.effects.push.apply(Transition.effects, Effects);
            Effects = null;
            setTransPending(true);
            return;
        }
    }
    const e1 = Effects;
    Effects = null;
    if (e1.length) runUpdates(()=>runEffects(e1), false);
    if (res) res();
}
function runQueue(queue) {
    for(let i = 0; i < queue.length; i++)runTop(queue[i]);
}
function scheduleQueue(queue) {
    for(let i = 0; i < queue.length; i++){
        const item = queue[i];
        const tasks = Transition.queue;
        if (!tasks.has(item)) {
            tasks.add(item);
            Scheduler(()=>{
                tasks.delete(item);
                runUpdates(()=>{
                    Transition.running = true;
                    runTop(item);
                }, false);
                Transition && (Transition.running = false);
            });
        }
    }
}
function runUserEffects(queue) {
    let i, userLength = 0;
    for(i = 0; i < queue.length; i++){
        const e = queue[i];
        if (!e.user) runTop(e);
        else queue[userLength++] = e;
    }
    if (sharedConfig.context) {
        if (sharedConfig.count) {
            sharedConfig.effects || (sharedConfig.effects = []);
            sharedConfig.effects.push(...queue.slice(0, userLength));
            return;
        } else if (sharedConfig.effects) {
            queue = [
                ...sharedConfig.effects,
                ...queue
            ];
            userLength += sharedConfig.effects.length;
            delete sharedConfig.effects;
        }
        setHydrateContext();
    }
    for(i = 0; i < userLength; i++)runTop(queue[i]);
}
function lookUpstream(node, ignore) {
    const runningTransition = Transition && Transition.running;
    if (runningTransition) node.tState = 0;
    else node.state = 0;
    for(let i = 0; i < node.sources.length; i += 1){
        const source = node.sources[i];
        if (source.sources) {
            const state = runningTransition ? source.tState : source.state;
            if (state === STALE) {
                if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
            } else if (state === PENDING) lookUpstream(source, ignore);
        }
    }
}
function markDownstream(node) {
    const runningTransition = Transition && Transition.running;
    for(let i = 0; i < node.observers.length; i += 1){
        const o = node.observers[i];
        if (runningTransition ? !o.tState : !o.state) {
            if (runningTransition) o.tState = PENDING;
            else o.state = PENDING;
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            o.observers && markDownstream(o);
        }
    }
}
function cleanNode(node) {
    let i;
    if (node.sources) while(node.sources.length){
        const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
        if (obs && obs.length) {
            const n = obs.pop(), s = source.observerSlots.pop();
            if (index < obs.length) {
                n.sourceSlots[s] = index;
                obs[index] = n;
                source.observerSlots[index] = s;
            }
        }
    }
    if (Transition && Transition.running && node.pure) {
        if (node.tOwned) {
            for(i = node.tOwned.length - 1; i >= 0; i--)cleanNode(node.tOwned[i]);
            delete node.tOwned;
        }
        reset(node, true);
    } else if (node.owned) {
        for(i = node.owned.length - 1; i >= 0; i--)cleanNode(node.owned[i]);
        node.owned = null;
    }
    if (node.cleanups) {
        for(i = node.cleanups.length - 1; i >= 0; i--)node.cleanups[i]();
        node.cleanups = null;
    }
    if (Transition && Transition.running) node.tState = 0;
    else node.state = 0;
}
function reset(node, top) {
    if (!top) {
        node.tState = 0;
        Transition.disposed.add(node);
    }
    if (node.owned) for(let i = 0; i < node.owned.length; i++)reset(node.owned[i]);
}
function castError(err) {
    if (err instanceof Error) return err;
    return new Error(typeof err === "string" ? err : "Unknown error", {
        cause: err
    });
}
function runErrors(err, fns, owner) {
    try {
        for (const f of fns)f(err);
    } catch (e) {
        handleError(e, owner && owner.owner || null);
    }
}
function handleError(err, owner = Owner) {
    const fns = ERROR && owner && owner.context && owner.context[ERROR];
    const error = castError(err);
    if (!fns) throw error;
    if (Effects) Effects.push({
        fn () {
            runErrors(error, fns, owner);
        },
        state: STALE
    });
    else runErrors(error, fns, owner);
}
function resolveChildren(children) {
    if (typeof children === "function" && !children.length) return resolveChildren(children());
    if (Array.isArray(children)) {
        const results = [];
        for(let i = 0; i < children.length; i++){
            const result = resolveChildren(children[i]);
            Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
        }
        return results;
    }
    return children;
}
function createProvider(id, options) {
    return function provider(props) {
        let res;
        createRenderEffect(()=>res = untrack(()=>{
                Owner.context = {
                    ...Owner.context,
                    [id]: props.value
                };
                return children(()=>props.children);
            }), undefined);
        return res;
    };
}
function onError(fn) {
    ERROR || (ERROR = Symbol("error"));
    if (Owner === null) ;
    else if (Owner.context === null || !Owner.context[ERROR]) {
        Owner.context = {
            ...Owner.context,
            [ERROR]: [
                fn
            ]
        };
        mutateContext(Owner, ERROR, [
            fn
        ]);
    } else Owner.context[ERROR].push(fn);
}
function mutateContext(o, key, value) {
    if (o.owned) for(let i = 0; i < o.owned.length; i++){
        if (o.owned[i].context === o.context) mutateContext(o.owned[i], key, value);
        if (!o.owned[i].context) {
            o.owned[i].context = o.context;
            mutateContext(o.owned[i], key, value);
        } else if (!o.owned[i].context[key]) {
            o.owned[i].context[key] = value;
            mutateContext(o.owned[i], key, value);
        }
    }
}
function observable(input) {
    return {
        subscribe (observer) {
            if (!(observer instanceof Object) || observer == null) throw new TypeError("Expected the observer to be an object.");
            const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
            if (!handler) return {
                unsubscribe () {}
            };
            const dispose = createRoot((disposer)=>{
                createEffect(()=>{
                    const v = input();
                    untrack(()=>handler(v));
                });
                return disposer;
            });
            if (getOwner()) onCleanup(dispose);
            return {
                unsubscribe () {
                    dispose();
                }
            };
        },
        [Symbol.observable || "@@observable"] () {
            return this;
        }
    };
}
function from(producer) {
    const [s, set] = createSignal(undefined, {
        equals: false
    });
    if ("subscribe" in producer) {
        const unsub = producer.subscribe((v)=>set(()=>v));
        onCleanup(()=>"unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
    } else {
        const clean = producer(set);
        onCleanup(clean);
    }
    return s;
}
const FALLBACK = Symbol("fallback");
function dispose(d) {
    for(let i = 0; i < d.length; i++)d[i]();
}
function mapArray(list, mapFn, options = {}) {
    let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
    onCleanup(()=>dispose(disposers));
    return ()=>{
        let newItems = list() || [], i, j;
        newItems[$TRACK];
        return untrack(()=>{
            let newLen = newItems.length, newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
            if (newLen === 0) {
                if (len !== 0) {
                    dispose(disposers);
                    disposers = [];
                    items = [];
                    mapped = [];
                    len = 0;
                    indexes && (indexes = []);
                }
                if (options.fallback) {
                    items = [
                        FALLBACK
                    ];
                    mapped[0] = createRoot((disposer)=>{
                        disposers[0] = disposer;
                        return options.fallback();
                    });
                    len = 1;
                }
            } else if (len === 0) {
                mapped = new Array(newLen);
                for(j = 0; j < newLen; j++){
                    items[j] = newItems[j];
                    mapped[j] = createRoot(mapper);
                }
                len = newLen;
            } else {
                temp = new Array(newLen);
                tempdisposers = new Array(newLen);
                indexes && (tempIndexes = new Array(newLen));
                for(start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);
                for(end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--){
                    temp[newEnd] = mapped[end];
                    tempdisposers[newEnd] = disposers[end];
                    indexes && (tempIndexes[newEnd] = indexes[end]);
                }
                newIndices = new Map();
                newIndicesNext = new Array(newEnd + 1);
                for(j = newEnd; j >= start; j--){
                    item = newItems[j];
                    i = newIndices.get(item);
                    newIndicesNext[j] = i === undefined ? -1 : i;
                    newIndices.set(item, j);
                }
                for(i = start; i <= end; i++){
                    item = items[i];
                    j = newIndices.get(item);
                    if (j !== undefined && j !== -1) {
                        temp[j] = mapped[i];
                        tempdisposers[j] = disposers[i];
                        indexes && (tempIndexes[j] = indexes[i]);
                        j = newIndicesNext[j];
                        newIndices.set(item, j);
                    } else disposers[i]();
                }
                for(j = start; j < newLen; j++)if (j in temp) {
                    mapped[j] = temp[j];
                    disposers[j] = tempdisposers[j];
                    if (indexes) {
                        indexes[j] = tempIndexes[j];
                        indexes[j](j);
                    }
                } else mapped[j] = createRoot(mapper);
                mapped = mapped.slice(0, len = newLen);
                items = newItems.slice(0);
            }
            return mapped;
        });
        function mapper(disposer) {
            disposers[j] = disposer;
            if (indexes) {
                const [s, set] = createSignal(j);
                indexes[j] = set;
                return mapFn(newItems[j], s);
            }
            return mapFn(newItems[j]);
        }
    };
}
function indexArray(list, mapFn, options = {}) {
    let items = [], mapped = [], disposers = [], signals = [], len = 0, i;
    onCleanup(()=>dispose(disposers));
    return ()=>{
        const newItems = list() || [];
        newItems[$TRACK];
        return untrack(()=>{
            if (newItems.length === 0) {
                if (len !== 0) {
                    dispose(disposers);
                    disposers = [];
                    items = [];
                    mapped = [];
                    len = 0;
                    signals = [];
                }
                if (options.fallback) {
                    items = [
                        FALLBACK
                    ];
                    mapped[0] = createRoot((disposer)=>{
                        disposers[0] = disposer;
                        return options.fallback();
                    });
                    len = 1;
                }
                return mapped;
            }
            if (items[0] === FALLBACK) {
                disposers[0]();
                disposers = [];
                items = [];
                mapped = [];
                len = 0;
            }
            for(i = 0; i < newItems.length; i++){
                if (i < items.length && items[i] !== newItems[i]) signals[i](()=>newItems[i]);
                else if (i >= items.length) mapped[i] = createRoot(mapper);
            }
            for(; i < items.length; i++)disposers[i]();
            len = signals.length = disposers.length = newItems.length;
            items = newItems.slice(0);
            return mapped = mapped.slice(0, len);
        });
        function mapper(disposer) {
            disposers[i] = disposer;
            const [s, set] = createSignal(newItems[i]);
            signals[i] = set;
            return mapFn(s, i);
        }
    };
}
let hydrationEnabled = false;
function enableHydration() {
    hydrationEnabled = true;
}
function createComponent(Comp, props) {
    if (hydrationEnabled) {
        if (sharedConfig.context) {
            const c = sharedConfig.context;
            setHydrateContext(nextHydrateContext());
            const r = untrack(()=>Comp(props || {}));
            setHydrateContext(c);
            return r;
        }
    }
    return untrack(()=>Comp(props || {}));
}
function trueFn() {
    return true;
}
const propTraps = {
    get (_, property, receiver) {
        if (property === $PROXY) return receiver;
        return _.get(property);
    },
    has (_, property) {
        if (property === $PROXY) return true;
        return _.has(property);
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor (_, property) {
        return {
            configurable: true,
            enumerable: true,
            get () {
                return _.get(property);
            },
            set: trueFn,
            deleteProperty: trueFn
        };
    },
    ownKeys (_) {
        return _.keys();
    }
};
function resolveSource(s) {
    return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
    for(let i = 0, length = this.length; i < length; ++i){
        const v = this[i]();
        if (v !== undefined) return v;
    }
}
function mergeProps(...sources) {
    let proxy = false;
    for(let i = 0; i < sources.length; i++){
        const s = sources[i];
        proxy = proxy || !!s && $PROXY in s;
        sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
    }
    if (proxy) return new Proxy({
        get (property) {
            for(let i = sources.length - 1; i >= 0; i--){
                const v = resolveSource(sources[i])[property];
                if (v !== undefined) return v;
            }
        },
        has (property) {
            for(let i = sources.length - 1; i >= 0; i--){
                if (property in resolveSource(sources[i])) return true;
            }
            return false;
        },
        keys () {
            const keys = [];
            for(let i = 0; i < sources.length; i++)keys.push(...Object.keys(resolveSource(sources[i])));
            return [
                ...new Set(keys)
            ];
        }
    }, propTraps);
    const sourcesMap = {};
    const defined = Object.create(null);
    for(let i1 = sources.length - 1; i1 >= 0; i1--){
        const source = sources[i1];
        if (!source) continue;
        const sourceKeys = Object.getOwnPropertyNames(source);
        for(let i2 = sourceKeys.length - 1; i2 >= 0; i2--){
            const key = sourceKeys[i2];
            if (key === "__proto__" || key === "constructor") continue;
            const desc = Object.getOwnPropertyDescriptor(source, key);
            if (!defined[key]) defined[key] = desc.get ? {
                enumerable: true,
                configurable: true,
                get: resolveSources.bind(sourcesMap[key] = [
                    desc.get.bind(source)
                ])
            } : desc.value !== undefined ? desc : undefined;
            else {
                const sources1 = sourcesMap[key];
                if (sources1) {
                    if (desc.get) sources1.push(desc.get.bind(source));
                    else if (desc.value !== undefined) sources1.push(()=>desc.value);
                }
            }
        }
    }
    const target = {};
    const definedKeys = Object.keys(defined);
    for(let i3 = definedKeys.length - 1; i3 >= 0; i3--){
        const key1 = definedKeys[i3], desc1 = defined[key1];
        if (desc1 && desc1.get) Object.defineProperty(target, key1, desc1);
        else target[key1] = desc1 ? desc1.value : undefined;
    }
    return target;
}
function splitProps(props, ...keys) {
    if ($PROXY in props) {
        const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
        const res = keys.map((k)=>{
            return new Proxy({
                get (property) {
                    return k.includes(property) ? props[property] : undefined;
                },
                has (property) {
                    return k.includes(property) && property in props;
                },
                keys () {
                    return k.filter((property)=>property in props);
                }
            }, propTraps);
        });
        res.push(new Proxy({
            get (property) {
                return blocked.has(property) ? undefined : props[property];
            },
            has (property) {
                return blocked.has(property) ? false : property in props;
            },
            keys () {
                return Object.keys(props).filter((k)=>!blocked.has(k));
            }
        }, propTraps));
        return res;
    }
    const otherObject = {};
    const objects = keys.map(()=>({}));
    for (const propName of Object.getOwnPropertyNames(props)){
        const desc = Object.getOwnPropertyDescriptor(props, propName);
        const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
        let blocked1 = false;
        let objectIndex = 0;
        for (const k of keys){
            if (k.includes(propName)) {
                blocked1 = true;
                isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
            }
            ++objectIndex;
        }
        if (!blocked1) isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
    }
    return [
        ...objects,
        otherObject
    ];
}
function lazy(fn) {
    let comp;
    let p;
    const wrap = (props)=>{
        const ctx = sharedConfig.context;
        if (ctx) {
            const [s, set] = createSignal();
            sharedConfig.count || (sharedConfig.count = 0);
            sharedConfig.count++;
            (p || (p = fn())).then((mod)=>{
                setHydrateContext(ctx);
                sharedConfig.count--;
                set(()=>mod.default);
                setHydrateContext();
            });
            comp = s;
        } else if (!comp) {
            const [s1] = createResource(()=>(p || (p = fn())).then((mod)=>mod.default));
            comp = s1;
        }
        let Comp;
        return createMemo(()=>(Comp = comp()) && untrack(()=>{
                if (!ctx) return Comp(props);
                const c = sharedConfig.context;
                setHydrateContext(ctx);
                const r = Comp(props);
                setHydrateContext(c);
                return r;
            }));
    };
    wrap.preload = ()=>p || ((p = fn()).then((mod)=>comp = ()=>mod.default), p);
    return wrap;
}
let counter = 0;
function createUniqueId() {
    const ctx = sharedConfig.context;
    return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;
}
const narrowedError = (name)=>`Stale read from <${name}>.`;
function For(props) {
    const fallback = "fallback" in props && {
        fallback: ()=>props.fallback
    };
    return createMemo(mapArray(()=>props.each, props.children, fallback || undefined));
}
function Index(props) {
    const fallback = "fallback" in props && {
        fallback: ()=>props.fallback
    };
    return createMemo(indexArray(()=>props.each, props.children, fallback || undefined));
}
function Show(props) {
    const keyed = props.keyed;
    const condition = createMemo(()=>props.when, undefined, {
        equals: (a, b)=>keyed ? a === b : !a === !b
    });
    return createMemo(()=>{
        const c = condition();
        if (c) {
            const child = props.children;
            const fn = typeof child === "function" && child.length > 0;
            return fn ? untrack(()=>child(keyed ? c : ()=>{
                    if (!untrack(condition)) throw narrowedError("Show");
                    return props.when;
                })) : child;
        }
        return props.fallback;
    }, undefined, undefined);
}
function Switch(props) {
    let keyed = false;
    const equals = (a, b)=>(keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];
    const conditions = children(()=>props.children), evalConditions = createMemo(()=>{
        let conds = conditions();
        if (!Array.isArray(conds)) conds = [
            conds
        ];
        for(let i = 0; i < conds.length; i++){
            const c = conds[i].when;
            if (c) {
                keyed = !!conds[i].keyed;
                return [
                    i,
                    c,
                    conds[i]
                ];
            }
        }
        return [
            -1
        ];
    }, undefined, {
        equals
    });
    return createMemo(()=>{
        const [index, when, cond] = evalConditions();
        if (index < 0) return props.fallback;
        const c = cond.children;
        const fn = typeof c === "function" && c.length > 0;
        return fn ? untrack(()=>c(keyed ? when : ()=>{
                if (untrack(evalConditions)[0] !== index) throw narrowedError("Match");
                return cond.when;
            })) : c;
    }, undefined, undefined);
}
function Match(props) {
    return props;
}
let Errors;
function resetErrorBoundaries() {
    Errors && [
        ...Errors
    ].forEach((fn)=>fn());
}
function ErrorBoundary(props) {
    let err;
    if (sharedConfig.context && sharedConfig.load) err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count);
    const [errored, setErrored] = createSignal(err, undefined);
    Errors || (Errors = new Set());
    Errors.add(setErrored);
    onCleanup(()=>Errors.delete(setErrored));
    return createMemo(()=>{
        let e;
        if (e = errored()) {
            const f = props.fallback;
            return typeof f === "function" && f.length ? untrack(()=>f(e, ()=>setErrored())) : f;
        }
        return catchError(()=>props.children, setErrored);
    }, undefined, undefined);
}
const suspenseListEquals = (a, b)=>a.showContent === b.showContent && a.showFallback === b.showFallback;
const SuspenseListContext = createContext();
function SuspenseList(props) {
    let [wrapper, setWrapper] = createSignal(()=>({
            inFallback: false
        })), show;
    const listContext = useContext(SuspenseListContext);
    const [registry, setRegistry] = createSignal([]);
    if (listContext) show = listContext.register(createMemo(()=>wrapper()().inFallback));
    const resolved = createMemo((prev)=>{
        const reveal = props.revealOrder, tail = props.tail, { showContent =true , showFallback =true  } = show ? show() : {}, reg = registry(), reverse = reveal === "backwards";
        if (reveal === "together") {
            const all = reg.every((inFallback)=>!inFallback());
            const res = reg.map(()=>({
                    showContent: all && showContent,
                    showFallback
                }));
            res.inFallback = !all;
            return res;
        }
        let stop = false;
        let inFallback = prev.inFallback;
        const res1 = [];
        for(let i = 0, len = reg.length; i < len; i++){
            const n = reverse ? len - i - 1 : i, s = reg[n]();
            if (!stop && !s) res1[n] = {
                showContent,
                showFallback
            };
            else {
                const next = !stop;
                if (next) inFallback = true;
                res1[n] = {
                    showContent: next,
                    showFallback: !tail || next && tail === "collapsed" ? showFallback : false
                };
                stop = true;
            }
        }
        if (!stop) inFallback = false;
        res1.inFallback = inFallback;
        return res1;
    }, {
        inFallback: false
    });
    setWrapper(()=>resolved);
    return createComponent(SuspenseListContext.Provider, {
        value: {
            register: (inFallback)=>{
                let index;
                setRegistry((registry)=>{
                    index = registry.length;
                    return [
                        ...registry,
                        inFallback
                    ];
                });
                return createMemo(()=>resolved()[index], undefined, {
                    equals: suspenseListEquals
                });
            }
        },
        get children () {
            return props.children;
        }
    });
}
function Suspense(props) {
    let counter = 0, show, ctx, p, flicker, error;
    const [inFallback, setFallback] = createSignal(false), SuspenseContext = getSuspenseContext(), store = {
        increment: ()=>{
            if (++counter === 1) setFallback(true);
        },
        decrement: ()=>{
            if (--counter === 0) setFallback(false);
        },
        inFallback,
        effects: [],
        resolved: false
    }, owner = getOwner();
    if (sharedConfig.context && sharedConfig.load) {
        const key = sharedConfig.context.id + sharedConfig.context.count;
        let ref = sharedConfig.load(key);
        if (ref && (typeof ref !== "object" || ref.status !== "success")) p = ref;
        if (p && p !== "$$f") {
            const [s, set] = createSignal(undefined, {
                equals: false
            });
            flicker = s;
            p.then(()=>{
                sharedConfig.gather(key);
                setHydrateContext(ctx);
                set();
                setHydrateContext();
            }).catch((err)=>{
                if (err || sharedConfig.done) {
                    err && (error = err);
                    return set();
                }
            });
        }
    }
    const listContext = useContext(SuspenseListContext);
    if (listContext) show = listContext.register(store.inFallback);
    let dispose;
    onCleanup(()=>dispose && dispose());
    return createComponent(SuspenseContext.Provider, {
        value: store,
        get children () {
            return createMemo(()=>{
                if (error) throw error;
                ctx = sharedConfig.context;
                if (flicker) {
                    flicker();
                    return flicker = undefined;
                }
                if (ctx && p === "$$f") setHydrateContext();
                const rendered = createMemo(()=>props.children);
                return createMemo((prev)=>{
                    const inFallback = store.inFallback(), { showContent =true , showFallback =true  } = show ? show() : {};
                    if ((!inFallback || p && p !== "$$f") && showContent) {
                        store.resolved = true;
                        dispose && dispose();
                        dispose = ctx = p = undefined;
                        resumeEffects(store.effects);
                        return rendered();
                    }
                    if (!showFallback) return;
                    if (dispose) return prev;
                    return createRoot((disposer)=>{
                        dispose = disposer;
                        if (ctx) {
                            setHydrateContext({
                                id: ctx.id + "f",
                                count: 0
                            });
                            ctx = undefined;
                        }
                        return props.fallback;
                    }, owner);
                });
            });
        }
    });
}
const DEV = undefined;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j7FRh":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"hJybK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Accordion", ()=>index$s);
parcelHelpers.export(exports, "Alert", ()=>index$r);
parcelHelpers.export(exports, "AlertDialog", ()=>index$p);
parcelHelpers.export(exports, "As", ()=>As);
parcelHelpers.export(exports, "Breadcrumbs", ()=>index$n);
parcelHelpers.export(exports, "Button", ()=>index$u);
parcelHelpers.export(exports, "COLOR_MODE_STORAGE_KEY", ()=>COLOR_MODE_STORAGE_KEY);
parcelHelpers.export(exports, "Calendar", ()=>index$m);
parcelHelpers.export(exports, "Checkbox", ()=>index$l);
parcelHelpers.export(exports, "Collapsible", ()=>index$t);
parcelHelpers.export(exports, "ColorModeContext", ()=>ColorModeContext);
parcelHelpers.export(exports, "ColorModeProvider", ()=>ColorModeProvider);
parcelHelpers.export(exports, "ColorModeScript", ()=>ColorModeScript);
parcelHelpers.export(exports, "Combobox", ()=>index$j);
parcelHelpers.export(exports, "ContextMenu", ()=>index$h);
parcelHelpers.export(exports, "DATA_LIVE_ANNOUNCER_ATTR", ()=>DATA_LIVE_ANNOUNCER_ATTR);
parcelHelpers.export(exports, "DatePicker", ()=>index$g);
parcelHelpers.export(exports, "Dialog", ()=>index$q);
parcelHelpers.export(exports, "DropdownMenu", ()=>index$f);
parcelHelpers.export(exports, "FORM_CONTROL_FIELD_PROP_NAMES", ()=>FORM_CONTROL_FIELD_PROP_NAMES);
parcelHelpers.export(exports, "FORM_CONTROL_PROP_NAMES", ()=>FORM_CONTROL_PROP_NAMES);
parcelHelpers.export(exports, "FormControlContext", ()=>FormControlContext);
parcelHelpers.export(exports, "FormControlDescription", ()=>FormControlDescription);
parcelHelpers.export(exports, "FormControlErrorMessage", ()=>FormControlErrorMessage);
parcelHelpers.export(exports, "FormControlLabel", ()=>FormControlLabel);
parcelHelpers.export(exports, "HoverCard", ()=>index$e);
parcelHelpers.export(exports, "I18nProvider", ()=>I18nProvider);
parcelHelpers.export(exports, "Image", ()=>index$d);
parcelHelpers.export(exports, "Link", ()=>index$o);
parcelHelpers.export(exports, "ListCollection", ()=>ListCollection);
parcelHelpers.export(exports, "ListKeyboardDelegate", ()=>ListKeyboardDelegate);
parcelHelpers.export(exports, "Listbox", ()=>index$k);
parcelHelpers.export(exports, "Pagination", ()=>index$c);
parcelHelpers.export(exports, "Polymorphic", ()=>Polymorphic);
parcelHelpers.export(exports, "Popover", ()=>index$b);
parcelHelpers.export(exports, "Progress", ()=>index$a);
parcelHelpers.export(exports, "RTL_LANGS", ()=>RTL_LANGS);
parcelHelpers.export(exports, "RadioGroup", ()=>index$9);
parcelHelpers.export(exports, "Select", ()=>index$8);
parcelHelpers.export(exports, "Selection", ()=>Selection);
parcelHelpers.export(exports, "SelectionManager", ()=>SelectionManager);
parcelHelpers.export(exports, "Separator", ()=>index$i);
parcelHelpers.export(exports, "Skeleton", ()=>index$7);
parcelHelpers.export(exports, "Slider", ()=>index$6);
parcelHelpers.export(exports, "Switch", ()=>index$5);
parcelHelpers.export(exports, "Tabs", ()=>index$4);
parcelHelpers.export(exports, "TextField", ()=>index$3);
parcelHelpers.export(exports, "Toast", ()=>index$2);
parcelHelpers.export(exports, "ToggleButton", ()=>index$1);
parcelHelpers.export(exports, "Tooltip", ()=>index);
parcelHelpers.export(exports, "announce", ()=>announce);
parcelHelpers.export(exports, "ariaHideOutside", ()=>ariaHideOutside);
parcelHelpers.export(exports, "clearAnnouncer", ()=>clearAnnouncer);
parcelHelpers.export(exports, "cookieStorageManager", ()=>cookieStorageManager);
parcelHelpers.export(exports, "cookieStorageManagerSSR", ()=>cookieStorageManagerSSR);
parcelHelpers.export(exports, "createCollator", ()=>createCollator);
parcelHelpers.export(exports, "createCollection", ()=>createCollection);
parcelHelpers.export(exports, "createControllableArraySignal", ()=>createControllableArraySignal);
parcelHelpers.export(exports, "createControllableBooleanSignal", ()=>createControllableBooleanSignal);
parcelHelpers.export(exports, "createControllableSetSignal", ()=>createControllableSetSignal);
parcelHelpers.export(exports, "createControllableSignal", ()=>createControllableSignal);
parcelHelpers.export(exports, "createCookieStorageManager", ()=>createCookieStorageManager);
parcelHelpers.export(exports, "createDateFormatter", ()=>createDateFormatter);
parcelHelpers.export(exports, "createDefaultLocale", ()=>createDefaultLocale);
parcelHelpers.export(exports, "createDisclosureState", ()=>createDisclosureState);
parcelHelpers.export(exports, "createEscapeKeyDown", ()=>createEscapeKeyDown);
parcelHelpers.export(exports, "createFilter", ()=>createFilter);
parcelHelpers.export(exports, "createFocusScope", ()=>createFocusScope);
parcelHelpers.export(exports, "createFormControl", ()=>createFormControl);
parcelHelpers.export(exports, "createFormControlField", ()=>createFormControlField);
parcelHelpers.export(exports, "createFormResetListener", ()=>createFormResetListener);
parcelHelpers.export(exports, "createHideOutside", ()=>createHideOutside);
parcelHelpers.export(exports, "createInteractOutside", ()=>createInteractOutside);
parcelHelpers.export(exports, "createListState", ()=>createListState);
parcelHelpers.export(exports, "createLocalStorageManager", ()=>createLocalStorageManager);
parcelHelpers.export(exports, "createMultipleSelectionState", ()=>createMultipleSelectionState);
parcelHelpers.export(exports, "createNumberFormatter", ()=>createNumberFormatter);
parcelHelpers.export(exports, "createPresence", ()=>createPresence);
parcelHelpers.export(exports, "createPreventScroll", ()=>createPreventScroll);
parcelHelpers.export(exports, "createRegisterId", ()=>createRegisterId);
parcelHelpers.export(exports, "createSelectableCollection", ()=>createSelectableCollection);
parcelHelpers.export(exports, "createSelectableItem", ()=>createSelectableItem);
parcelHelpers.export(exports, "createSelectableList", ()=>createSelectableList);
parcelHelpers.export(exports, "createSingleSelectListState", ()=>createSingleSelectListState);
parcelHelpers.export(exports, "createTagName", ()=>createTagName);
parcelHelpers.export(exports, "createToggleState", ()=>createToggleState);
parcelHelpers.export(exports, "createTransition", ()=>createTransition);
parcelHelpers.export(exports, "createTypeSelect", ()=>createTypeSelect);
parcelHelpers.export(exports, "destroyAnnouncer", ()=>destroyAnnouncer);
parcelHelpers.export(exports, "getDefaultLocale", ()=>getDefaultLocale);
parcelHelpers.export(exports, "getItemCount", ()=>getItemCount);
parcelHelpers.export(exports, "getReadingDirection", ()=>getReadingDirection);
parcelHelpers.export(exports, "isRTL", ()=>isRTL);
parcelHelpers.export(exports, "localStorageManager", ()=>localStorageManager);
parcelHelpers.export(exports, "toaster", ()=>toaster);
parcelHelpers.export(exports, "useColorMode", ()=>useColorMode);
parcelHelpers.export(exports, "useColorModeValue", ()=>useColorModeValue);
parcelHelpers.export(exports, "useFormControlContext", ()=>useFormControlContext);
parcelHelpers.export(exports, "useLocale", ()=>useLocale);
var _utils = require("@kobalte/utils");
var _store = require("solid-js/store");
var _web = require("solid-js/web");
var _solidJs = require("solid-js");
var _date = require("@internationalized/date");
var _dom = require("@floating-ui/dom");
var _number = require("@internationalized/number");
/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/color-mode-context.ts
 */ const ColorModeContext = (0, _solidJs.createContext)();
/**
 * Primitive that reads from `ColorModeProvider` context,
 * Returns the color mode and function to toggle it.
 */ function useColorMode() {
    const context = (0, _solidJs.useContext)(ColorModeContext);
    if (context === undefined) throw new Error("[kobalte]: `useColorMode` must be used within a `ColorModeProvider`");
    return context;
}
/**
 * Change value based on color mode.
 *
 * @param light the light mode value
 * @param dark the dark mode value
 * @return A memoized value based on the color mode.
 *
 * @example
 *
 * ```js
 * const Icon = useColorModeValue(MoonIcon, SunIcon)
 * ```
 */ function useColorModeValue(light, dark) {
    const { colorMode  } = useColorMode();
    return (0, _solidJs.createMemo)(()=>colorMode() === "dark" ? dark : light);
}
/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/storage-manager.ts
 */ const COLOR_MODE_STORAGE_KEY = "kb-color-mode";
function createLocalStorageManager(key) {
    return {
        ssr: false,
        type: "localStorage",
        get: (fallback)=>{
            if (0, _web.isServer) return fallback;
            let value;
            try {
                value = localStorage.getItem(key);
            } catch (e) {
            // noop
            }
            return value ?? fallback;
        },
        set: (value)=>{
            try {
                localStorage.setItem(key, value);
            } catch (e) {
            // noop
            }
        }
    };
}
const localStorageManager = createLocalStorageManager(COLOR_MODE_STORAGE_KEY);
function parseCookie(cookie, key) {
    const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
    return match?.[2];
}
function createCookieStorageManager(key, cookie) {
    return {
        ssr: !!cookie,
        type: "cookie",
        get: (fallback)=>{
            if (cookie) return parseCookie(cookie, key) ?? fallback;
            if (0, _web.isServer) return fallback;
            return parseCookie(document.cookie, key) ?? fallback;
        },
        set: (value)=>{
            document.cookie = `${key}=${value}; max-age=31536000; path=/`;
        }
    };
}
const cookieStorageManager = createCookieStorageManager(COLOR_MODE_STORAGE_KEY);
function cookieStorageManagerSSR(cookie) {
    return createCookieStorageManager(COLOR_MODE_STORAGE_KEY, cookie);
}
/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/color-mode.utils.ts
 */ const FALLBACK_COLOR_MODE_VALUE = "system";
function query() {
    return window.matchMedia("(prefers-color-scheme: dark)");
}
function preventTransition() {
    const css = document.createElement("style");
    css.appendChild(document.createTextNode(`*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`));
    document.head.appendChild(css);
    return ()=>{
        // force a reflow
        (()=>window.getComputedStyle(document.body))();
        // wait for next tick
        requestAnimationFrame(()=>{
            requestAnimationFrame(()=>{
                document.head.removeChild(css);
            });
        });
    };
}
function setColorModeDataset(value, shouldPreventTransition = true) {
    const cleanup = shouldPreventTransition ? preventTransition() : undefined;
    document.documentElement.dataset.kbTheme = value;
    document.documentElement.style.colorScheme = value;
    cleanup?.();
}
function getSystemColorMode(fallback) {
    const isDark = query().matches ?? fallback === "dark";
    return isDark ? "dark" : "light";
}
function getInitialColorMode(manager) {
    const fallback = "light";
    const initialColorMode = manager.get(fallback) ?? fallback;
    if (initialColorMode === "system") // We can't know the client system preference in SSR so just return the fallback.
    return (0, _web.isServer) ? fallback : getSystemColorMode();
    return initialColorMode;
}
function addColorModeListener(fn) {
    const mql = query();
    const listener = (e)=>{
        fn(e.matches ? "dark" : "light");
    };
    mql.addEventListener("change", listener);
    return ()=>{
        mql.removeEventListener("change", listener);
    };
}
/**
 * Provides context for the color mode based on config in `theme`
 * Returns the color mode and function to toggle the color mode
 */ function ColorModeProvider(props) {
    const fallbackColorMode = ()=>props.initialColorMode ?? FALLBACK_COLOR_MODE_VALUE;
    const colorModeManager = ()=>props.storageManager ?? localStorageManager;
    let colorModeListenerCleanupFn;
    const [colorMode, rawSetColorMode] = (0, _solidJs.createSignal)(getInitialColorMode(colorModeManager()));
    const applyColorMode = (value)=>{
        rawSetColorMode(value);
        setColorModeDataset(value, props.disableTransitionOnChange);
    };
    const setColorMode = (value)=>{
        if (colorModeListenerCleanupFn) {
            colorModeListenerCleanupFn();
            colorModeListenerCleanupFn = undefined;
        }
        const isSystem = value === "system";
        if (isSystem) colorModeListenerCleanupFn = addColorModeListener(applyColorMode);
        applyColorMode(isSystem ? getSystemColorMode() : value);
        colorModeManager().set(value);
    };
    const toggleColorMode = ()=>{
        setColorMode(colorMode() === "dark" ? "light" : "dark");
    };
    (0, _solidJs.createEffect)(()=>{
        setColorMode(colorModeManager().get() ?? fallbackColorMode());
    });
    (0, _solidJs.onCleanup)(()=>{
        // ensure listener is always cleaned when component is destroyed.
        colorModeListenerCleanupFn?.();
    });
    const context = {
        colorMode,
        setColorMode,
        toggleColorMode
    };
    return (0, _web.createComponent)(ColorModeContext.Provider, {
        value: context,
        get children () {
            return props.children;
        }
    });
}
const _tmpl$$h = /*#__PURE__*/ (0, _web.template)(`<script id="kb-color-mode-script">`);
const VALID_VALUES = new Set([
    "light",
    "dark",
    "system"
]);
/**
 * runtime safe-guard against invalid color mode values
 */ function normalize(initialColorMode) {
    if (!VALID_VALUES.has(initialColorMode)) return FALLBACK_COLOR_MODE_VALUE;
    return initialColorMode;
}
function ColorModeScript(props) {
    props = (0, _solidJs.mergeProps)({
        initialColorMode: FALLBACK_COLOR_MODE_VALUE,
        storageType: "localStorage",
        storageKey: COLOR_MODE_STORAGE_KEY
    }, props);
    const scriptSrc = (0, _solidJs.createMemo)(()=>{
        // runtime safe-guard against invalid color mode values
        const init = normalize(props.initialColorMode);
        const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,s=e==="dark";return d.style.colorScheme=e,d.dataset.kbTheme=e,o},u=a,h="${init}",r="${props.storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();`;
        const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,i=r==="dark";return o.style.colorScheme=r,o.dataset.kbTheme=r,c},n=a,m="${init}",e="${props.storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();`;
        const fn = props.storageType === "cookie" ? cookieScript : localStorageScript;
        return `!${fn}`.trim();
    });
    // eslint-disable-next-line solid/no-innerhtml
    return (()=>{
        const _el$ = _tmpl$$h();
        (0, _web.effect)((_p$)=>{
            const _v$ = props.nonce, _v$2 = scriptSrc();
            _v$ !== _p$._v$ && (0, _web.setAttribute)(_el$, "nonce", _p$._v$ = _v$);
            _v$2 !== _p$._v$2 && (_el$.innerHTML = _p$._v$2 = _v$2);
            return _p$;
        }, {
            _v$: undefined,
            _v$2: undefined
        });
        return _el$;
    })();
}
/**
 * Generate a flatted array of `CollectionNode` from a custom data source.
 */ function buildNodes(params) {
    let index = params.startIndex ?? 0;
    const level = params.startLevel ?? 0;
    const nodes = [];
    const getKey = (data)=>{
        if (data == null) return "";
        const _getKey = params.getKey ?? "key";
        const dataKey = (0, _utils.isString)(_getKey) ? data[_getKey] : _getKey(data);
        return dataKey != null ? String(dataKey) : "";
    };
    const getTextValue = (data)=>{
        if (data == null) return "";
        const _getTextValue = params.getTextValue ?? "textValue";
        const dataTextValue = (0, _utils.isString)(_getTextValue) ? data[_getTextValue] : _getTextValue(data);
        return dataTextValue != null ? String(dataTextValue) : "";
    };
    const getDisabled = (data)=>{
        if (data == null) return false;
        const _getDisabled = params.getDisabled ?? "disabled";
        return ((0, _utils.isString)(_getDisabled) ? data[_getDisabled] : _getDisabled(data)) ?? false;
    };
    const getSectionChildren = (data)=>{
        if (data == null) return undefined;
        if ((0, _utils.isString)(params.getSectionChildren)) return data[params.getSectionChildren];
        return params.getSectionChildren?.(data);
    };
    for (const data of params.dataSource){
        // If it's not an object assume it's an item.
        if ((0, _utils.isString)(data) || (0, _utils.isNumber)(data)) {
            nodes.push({
                type: "item",
                rawValue: data,
                key: String(data),
                textValue: String(data),
                disabled: getDisabled(data),
                level,
                index
            });
            index++;
            continue;
        }
        // Assume it's a section if it has children.
        if (getSectionChildren(data) != null) {
            nodes.push({
                type: "section",
                rawValue: data,
                key: "",
                // not applicable here
                textValue: "",
                // not applicable here
                disabled: false,
                // not applicable here
                level: level,
                index: index
            });
            index++;
            const sectionChildren = getSectionChildren(data) ?? [];
            if (sectionChildren.length > 0) {
                const childNodes = buildNodes({
                    dataSource: sectionChildren,
                    getKey: params.getKey,
                    getTextValue: params.getTextValue,
                    getDisabled: params.getDisabled,
                    getSectionChildren: params.getSectionChildren,
                    startIndex: index,
                    startLevel: level + 1
                });
                nodes.push(...childNodes);
                index += childNodes.length;
            }
        } else {
            nodes.push({
                type: "item",
                rawValue: data,
                key: getKey(data),
                textValue: getTextValue(data),
                disabled: getDisabled(data),
                level,
                index
            });
            index++;
        }
    }
    return nodes;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/collections/src/useCollection.ts
 */ function createCollection(props, deps = []) {
    const initialNodes = buildNodes({
        dataSource: (0, _utils.access)(props.dataSource),
        getKey: (0, _utils.access)(props.getKey),
        getTextValue: (0, _utils.access)(props.getTextValue),
        getDisabled: (0, _utils.access)(props.getDisabled),
        getSectionChildren: (0, _utils.access)(props.getSectionChildren)
    });
    const [collection, setCollection] = (0, _solidJs.createSignal)(props.factory(initialNodes));
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>(0, _utils.access)(props.dataSource),
        ()=>(0, _utils.access)(props.getKey),
        ()=>(0, _utils.access)(props.getTextValue),
        ()=>(0, _utils.access)(props.getDisabled),
        ()=>(0, _utils.access)(props.getSectionChildren),
        ()=>props.factory,
        ...deps
    ], ([dataSource, getKey, getTextValue, getDisabled, getSectionChildren, factory])=>{
        const nodes = buildNodes({
            dataSource,
            getKey,
            getTextValue,
            getDisabled,
            getSectionChildren
        });
        setCollection(()=>factory(nodes));
    }, {
        defer: true
    }));
    return collection;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/22cb32d329e66c60f55d4fc4025d1d44bb015d71/packages/@react-stately/collections/src/getItemCount.ts
 */ const cache$1 = new WeakMap();
function getItemCount(collection) {
    let count = cache$1.get(collection);
    if (count != null) return count;
    count = 0;
    for (const item of collection)if (item.type === "item") count++;
    cache$1.set(collection, count);
    return count;
}
/**
 * Creates a simple reactive state with a getter and setter,
 * that can be controlled with `value` and `onChange` props.
 */ function createControllableSignal(props) {
    // Internal uncontrolled value
    // eslint-disable-next-line solid/reactivity
    const [_value, _setValue] = (0, _solidJs.createSignal)(props.defaultValue?.());
    const isControlled = (0, _solidJs.createMemo)(()=>props.value?.() !== undefined);
    const value = (0, _solidJs.createMemo)(()=>isControlled() ? props.value?.() : _value());
    const setValue = (next)=>{
        (0, _solidJs.untrack)(()=>{
            const nextValue = (0, _utils.accessWith)(next, value());
            if (!Object.is(nextValue, value())) {
                if (!isControlled()) _setValue(nextValue);
                props.onChange?.(nextValue);
            }
            return nextValue;
        });
    };
    return [
        value,
        setValue
    ];
}
/**
 * Creates a simple reactive Boolean state with a getter, setter and a fallback value of `false`,
 * that can be controlled with `value` and `onChange` props.
 */ function createControllableBooleanSignal(props) {
    const [_value, setValue] = createControllableSignal(props);
    const value = ()=>_value() ?? false;
    return [
        value,
        setValue
    ];
}
/**
 * Creates a simple reactive Array state with a getter, setter and a fallback value of `[]`,
 * that can be controlled with `value` and `onChange` props.
 */ function createControllableArraySignal(props) {
    const [_value, setValue] = createControllableSignal(props);
    const value = ()=>_value() ?? [];
    return [
        value,
        setValue
    ];
}
/**
 * Creates a simple reactive Set state with a getter, setter and a fallback value of `Set()`,
 * that can be controlled with `value` and `onChange` props.
 */ function createControllableSetSignal(props) {
    const [_value, setValue] = createControllableSignal(props);
    const value = ()=>_value() ?? new Set();
    return [
        value,
        setValue
    ];
}
/**
 * Provides state management for open, close and toggle scenarios.
 * Used to control the "open state" of components like Modal, Drawer, etc.
 */ function createDisclosureState(props = {}) {
    const [isOpen, setIsOpen] = createControllableBooleanSignal({
        value: ()=>(0, _utils.access)(props.open),
        defaultValue: ()=>!!(0, _utils.access)(props.defaultOpen),
        onChange: (value)=>props.onOpenChange?.(value)
    });
    const open = ()=>{
        setIsOpen(true);
    };
    const close = ()=>{
        setIsOpen(false);
    };
    const toggle = ()=>{
        isOpen() ? close() : open();
    };
    return {
        isOpen,
        setIsOpen,
        open,
        close,
        toggle
    };
}
/**
 * Listens for when the escape key is down on the document.
 */ function createEscapeKeyDown(props) {
    const handleKeyDown = (event)=>{
        if (event.key === (0, _utils.EventKey).Escape) props.onEscapeKeyDown?.(event);
    };
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        if ((0, _utils.access)(props.isDisabled)) return;
        const document1 = props.ownerDocument?.() ?? (0, _utils.getDocument)();
        document1.addEventListener("keydown", handleKeyDown);
        (0, _solidJs.onCleanup)(()=>{
            document1.removeEventListener("keydown", handleKeyDown);
        });
    });
}
/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dismissable-layer/src/DismissableLayer.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/dismissable/src/layer-stack.ts
 */ const DATA_TOP_LAYER_ATTR = "data-kb-top-layer";
let originalBodyPointerEvents;
let hasDisabledBodyPointerEvents = false;
const layers = [];
function indexOf(node) {
    return layers.findIndex((layer)=>layer.node === node);
}
function find(node) {
    return layers[indexOf(node)];
}
function isTopMostLayer(node) {
    return layers[layers.length - 1].node === node;
}
function getPointerBlockingLayers() {
    return layers.filter((layer)=>layer.isPointerBlocking);
}
function getTopMostPointerBlockingLayer() {
    return [
        ...getPointerBlockingLayers()
    ].slice(-1)[0];
}
function hasPointerBlockingLayer() {
    return getPointerBlockingLayers().length > 0;
}
function isBelowPointerBlockingLayer(node) {
    const highestBlockingIndex = indexOf(getTopMostPointerBlockingLayer()?.node);
    return indexOf(node) < highestBlockingIndex;
}
function addLayer(layer) {
    layers.push(layer);
}
function removeLayer(node) {
    const index = indexOf(node);
    if (index < 0) return;
    layers.splice(index, 1);
}
function assignPointerEventToLayers() {
    layers.forEach(({ node  })=>{
        node.style.pointerEvents = isBelowPointerBlockingLayer(node) ? "none" : "auto";
    });
}
/**
 * Disable body `pointer-events` if there are "pointer blocking" layers in the stack,
 * and body `pointer-events` has not been disabled yet.
 */ function disableBodyPointerEvents(node) {
    if (hasPointerBlockingLayer() && !hasDisabledBodyPointerEvents) {
        const ownerDocument = (0, _utils.getDocument)(node);
        originalBodyPointerEvents = document.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
        hasDisabledBodyPointerEvents = true;
    }
}
/**
 * Restore body `pointer-events` style if there is no "pointer blocking" layer in the stack.
 */ function restoreBodyPointerEvents(node) {
    if (hasPointerBlockingLayer()) return;
    const ownerDocument = (0, _utils.getDocument)(node);
    ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
    if (ownerDocument.body.style.length === 0) ownerDocument.body.removeAttribute("style");
    hasDisabledBodyPointerEvents = false;
}
const layerStack = {
    layers,
    isTopMostLayer,
    hasPointerBlockingLayer,
    isBelowPointerBlockingLayer,
    addLayer,
    removeLayer,
    indexOf,
    find,
    assignPointerEventToLayers,
    disableBodyPointerEvents,
    restoreBodyPointerEvents
};
/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/focus-scope/src/FocusScope.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/focus-scope/src/focus-on-child-unmount.ts
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/focus-scope/src/focus-containment.ts
 */ const AUTOFOCUS_ON_MOUNT_EVENT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT_EVENT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
};
const focusScopeStack = {
    /** A stack of focus scopes, with the active one at the top */ stack: [],
    active () {
        return this.stack[0];
    },
    add (scope) {
        // pause the currently active focus scope (at the top of the stack)
        if (scope !== this.active()) this.active()?.pause();
        // remove in case it already exists and re-add it at the top of the stack.
        this.stack = (0, _utils.removeItemFromArray)(this.stack, scope);
        this.stack.unshift(scope);
    },
    remove (scope) {
        this.stack = (0, _utils.removeItemFromArray)(this.stack, scope);
        this.active()?.resume();
    }
};
function createFocusScope(props, ref) {
    const [isPaused, setIsPaused] = (0, _solidJs.createSignal)(false);
    const focusScope = {
        pause () {
            setIsPaused(true);
        },
        resume () {
            setIsPaused(false);
        }
    };
    let lastFocusedElement = null;
    const onMountAutoFocus = (e)=>props.onMountAutoFocus?.(e);
    const onUnmountAutoFocus = (e)=>props.onUnmountAutoFocus?.(e);
    const ownerDocument = ()=>(0, _utils.getDocument)(ref());
    const createSentinel = ()=>{
        const element = ownerDocument().createElement("span");
        element.setAttribute("data-focus-trap", "");
        element.tabIndex = 0;
        Object.assign(element.style, (0, _utils.visuallyHiddenStyles));
        return element;
    };
    const tabbables = ()=>{
        const container = ref();
        if (!container) return [];
        // Get all tabbable in container excluding focus scope sentinels
        return (0, _utils.getAllTabbableIn)(container, true).filter((el)=>!el.hasAttribute("data-focus-trap"));
    };
    const firstTabbable = ()=>{
        const items = tabbables();
        return items.length > 0 ? items[0] : null;
    };
    const lastTabbable = ()=>{
        const items = tabbables();
        return items.length > 0 ? items[items.length - 1] : null;
    };
    const shouldPreventUnmountAutoFocus = ()=>{
        const container = ref();
        if (!container) return false;
        const activeElement = (0, _utils.getActiveElement)(container);
        if (!activeElement) return false;
        if ((0, _utils.contains)(container, activeElement)) return false;
        // Don't autofocus the previously focused element on unmount
        // if a focusable element outside the container is already focused.
        return (0, _utils.isFocusable)(activeElement);
    };
    // Handle dispatching mount and unmount autofocus events.
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        const container = ref();
        if (!container) return;
        focusScopeStack.add(focusScope);
        const previouslyFocusedElement = (0, _utils.getActiveElement)(container);
        const hasFocusedCandidate = (0, _utils.contains)(container, previouslyFocusedElement);
        if (!hasFocusedCandidate) {
            const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT_EVENT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
            container.dispatchEvent(mountEvent);
            if (!mountEvent.defaultPrevented) // Delay the focusing because it may run before a `DismissableLayer` is added to the layer stack,
            // so it cause nested dismissable layer to open then close instantly.
            setTimeout(()=>{
                (0, _utils.focusWithoutScrolling)(firstTabbable());
                if ((0, _utils.getActiveElement)(container) === previouslyFocusedElement) (0, _utils.focusWithoutScrolling)(container);
            }, 0);
        }
        (0, _solidJs.onCleanup)(()=>{
            container.removeEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
            setTimeout(()=>{
                const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT_EVENT, EVENT_OPTIONS);
                if (shouldPreventUnmountAutoFocus()) unmountEvent.preventDefault();
                container.addEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
                container.dispatchEvent(unmountEvent);
                if (!unmountEvent.defaultPrevented) (0, _utils.focusWithoutScrolling)(previouslyFocusedElement ?? ownerDocument().body);
                // We need to remove the listener after we `dispatchEvent`.
                container.removeEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
                focusScopeStack.remove(focusScope);
            }, 0);
        });
    });
    /*
  // Handle containing focus if a child unmount.
  createEffect(() => {
    if (isServer) {
      return;
    }
     const container = ref();
     if (!container || !access(props.trapFocus)) {
      return;
    }
     const observer = new MutationObserver(([mutation]) => {
      if (!mutation || mutation.target !== container) {
        return;
      }
       if (getActiveElement(container) === ownerDocument().body) {
        focusWithoutScrolling(container);
      }
    });
     observer.observe(container, { childList: true, subtree: true });
     onCleanup(() => {
      observer.disconnect();
    });
  });
  */ // Handle containing focus if focus is moved outside.
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        const container = ref();
        if (!container || !(0, _utils.access)(props.trapFocus) || isPaused()) return;
        const onFocusIn = (event)=>{
            const target = event.target;
            // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
            if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) return;
            if ((0, _utils.contains)(container, target)) lastFocusedElement = target;
            else (0, _utils.focusWithoutScrolling)(lastFocusedElement);
        };
        const onFocusOut = (event)=>{
            const relatedTarget = event.relatedTarget;
            const target = relatedTarget ?? (0, _utils.getActiveElement)(container);
            // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
            if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) return;
            if (!(0, _utils.contains)(container, target)) (0, _utils.focusWithoutScrolling)(lastFocusedElement);
        };
        ownerDocument().addEventListener("focusin", onFocusIn);
        ownerDocument().addEventListener("focusout", onFocusOut);
        (0, _solidJs.onCleanup)(()=>{
            ownerDocument().removeEventListener("focusin", onFocusIn);
            ownerDocument().removeEventListener("focusout", onFocusOut);
        });
    });
    // Handle looping focus (when tabbing whilst at the edges)
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        const container = ref();
        if (!container || !(0, _utils.access)(props.trapFocus) || isPaused()) return;
        const startSentinel = createSentinel();
        container.insertAdjacentElement("afterbegin", startSentinel);
        const endSentinel = createSentinel();
        container.insertAdjacentElement("beforeend", endSentinel);
        function onFocus(event) {
            const first = firstTabbable();
            const last = lastTabbable();
            if (event.relatedTarget === first) (0, _utils.focusWithoutScrolling)(last);
            else (0, _utils.focusWithoutScrolling)(first);
        }
        startSentinel.addEventListener("focusin", onFocus);
        endSentinel.addEventListener("focusin", onFocus);
        // Ensure sentinels are always the edges of the container.
        const observer = new MutationObserver((mutations)=>{
            for (const mutation of mutations){
                if (mutation.previousSibling === endSentinel) {
                    endSentinel.remove();
                    container.insertAdjacentElement("beforeend", endSentinel);
                }
                if (mutation.nextSibling === startSentinel) {
                    startSentinel.remove();
                    container.insertAdjacentElement("afterbegin", startSentinel);
                }
            }
        });
        observer.observe(container, {
            childList: true,
            subtree: false
        });
        (0, _solidJs.onCleanup)(()=>{
            startSentinel.removeEventListener("focusin", onFocus);
            endSentinel.removeEventListener("focusin", onFocus);
            startSentinel.remove();
            endSentinel.remove();
            observer.disconnect();
        });
    });
}
/*!
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the zag team:
 * https://github.com/chakra-ui/zag/blob/c1e6c7689b22bf58741ded7cf224dd9baec2a046/packages/utilities/form-utils/src/form.ts
 */ /**
 * Listens for `reset` event on the closest `<form>` element and execute the given handler.
 */ function createFormResetListener(element, handler) {
    (0, _solidJs.createEffect)((0, _solidJs.on)(element, (element)=>{
        if (element == null) return;
        const form = getClosestForm(element);
        if (form == null) return;
        form.addEventListener("reset", handler, {
            passive: true
        });
        (0, _solidJs.onCleanup)(()=>{
            form.removeEventListener("reset", handler);
        });
    }));
}
function getClosestForm(element) {
    return isFormElement(element) ? element.form : element.closest("form");
}
function isFormElement(element) {
    return element.matches("textarea, input, select, button");
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/live-announcer/src/LiveAnnouncer.tsx
 */ /* Inspired by https://github.com/AlmeroSteyn/react-aria-live */ const LIVEREGION_TIMEOUT_DELAY = 7000;
let liveAnnouncer = null;
const DATA_LIVE_ANNOUNCER_ATTR = "data-live-announcer";
/**
 * Announces the message using screen reader technology.
 */ function announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
    if (!liveAnnouncer) liveAnnouncer = new LiveAnnouncer();
    liveAnnouncer.announce(message, assertiveness, timeout);
}
/**
 * Stops all queued announcements.
 */ function clearAnnouncer(assertiveness) {
    if (liveAnnouncer) liveAnnouncer.clear(assertiveness);
}
/**
 * Removes the announcer from the DOM.
 */ function destroyAnnouncer() {
    if (liveAnnouncer) {
        liveAnnouncer.destroy();
        liveAnnouncer = null;
    }
}
// LiveAnnouncer is implemented using vanilla DOM, not SolidJS.
class LiveAnnouncer {
    constructor(){
        this.node = document.createElement("div");
        this.node.dataset.liveAnnouncer = "true";
        Object.assign(this.node.style, (0, _utils.visuallyHiddenStyles));
        this.assertiveLog = this.createLog("assertive");
        this.node.appendChild(this.assertiveLog);
        this.politeLog = this.createLog("polite");
        this.node.appendChild(this.politeLog);
        document.body.prepend(this.node);
    }
    createLog(ariaLive) {
        const node = document.createElement("div");
        node.setAttribute("role", "log");
        node.setAttribute("aria-live", ariaLive);
        node.setAttribute("aria-relevant", "additions");
        return node;
    }
    destroy() {
        if (!this.node) return;
        document.body.removeChild(this.node);
        this.node = null;
    }
    announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
        if (!this.node) return;
        const node = document.createElement("div");
        node.textContent = message;
        if (assertiveness === "assertive") this.assertiveLog.appendChild(node);
        else this.politeLog.appendChild(node);
        if (message !== "") setTimeout(()=>{
            node.remove();
        }, timeout);
    }
    clear(assertiveness) {
        if (!this.node) return;
        if (!assertiveness || assertiveness === "assertive") this.assertiveLog.innerHTML = "";
        if (!assertiveness || assertiveness === "polite") this.politeLog.innerHTML = "";
    }
}
/*!
 * This file is based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/810579b671791f1593108f62cdc1893de3a220e3/packages/@react-aria/overlays/src/ariaHideOutside.ts
 */ /**
 * Hides all elements in the DOM outside the given targets from screen readers
 * using aria-hidden, and returns a function to revert these changes.
 * In addition, changes to the DOM are watched and new elements
 * outside the targets are automatically hidden.
 */ function createHideOutside(props) {
    (0, _solidJs.createEffect)(()=>{
        if ((0, _utils.access)(props.isDisabled)) return;
        (0, _solidJs.onCleanup)(ariaHideOutside((0, _utils.access)(props.targets), (0, _utils.access)(props.root)));
    });
}
// Keeps a ref count of all hidden elements.
// Added to when hiding an element, and subtracted from when showing it again.
// When it reaches zero, aria-hidden is removed.
const refCountMap = new WeakMap();
const observerStack = [];
/**
 * Hides all elements in the DOM outside the given targets from screen readers using aria-hidden,
 * and returns a function to revert these changes. In addition, changes to the DOM are watched
 * and new elements outside the targets are automatically hidden.
 * @param targets - The elements that should remain visible.
 * @param root - Nothing will be hidden above this element.
 * @returns - A function to restore all hidden elements.
 */ function ariaHideOutside(targets, root = document.body) {
    const visibleNodes = new Set(targets);
    const hiddenNodes = new Set();
    const walk = (root)=>{
        // Keep live announcer and top layer elements (e.g. toasts) visible.
        for (const element of root.querySelectorAll(`[${DATA_LIVE_ANNOUNCER_ATTR}], [${DATA_TOP_LAYER_ATTR}]`))visibleNodes.add(element);
        const acceptNode = (node)=>{
            // Skip this node and its children if it is one of the target nodes, or a live announcer.
            // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is
            // made for elements with role="row" since VoiceOver on iOS has issues hiding elements with role="row".
            // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).
            if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") return NodeFilter.FILTER_REJECT;
            // Skip this node but continue to children if one of the targets is inside the node.
            for (const target of visibleNodes){
                if (node.contains(target)) return NodeFilter.FILTER_SKIP;
            }
            return NodeFilter.FILTER_ACCEPT;
        };
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode
        });
        // TreeWalker does not include the root.
        const acceptRoot = acceptNode(root);
        if (acceptRoot === NodeFilter.FILTER_ACCEPT) hide(root);
        if (acceptRoot !== NodeFilter.FILTER_REJECT) {
            let node = walker.nextNode();
            while(node != null){
                hide(node);
                node = walker.nextNode();
            }
        }
    };
    const hide = (node)=>{
        const refCount = refCountMap.get(node) ?? 0;
        // If already aria-hidden, and the ref count is zero, then this element
        // was already hidden and there's nothing for us to do.
        if (node.getAttribute("aria-hidden") === "true" && refCount === 0) return;
        if (refCount === 0) node.setAttribute("aria-hidden", "true");
        hiddenNodes.add(node);
        refCountMap.set(node, refCount + 1);
    };
    // If there is already a MutationObserver listening from a previous call,
    // disconnect it so the new on takes over.
    if (observerStack.length) observerStack[observerStack.length - 1].disconnect();
    walk(root);
    const observer = new MutationObserver((changes)=>{
        for (const change of changes){
            if (change.type !== "childList" || change.addedNodes.length === 0) continue;
            // If the parent element of the added nodes is not within one of the targets,
            // and not already inside a hidden node, hide all of the new children.
            if (![
                ...visibleNodes,
                ...hiddenNodes
            ].some((node)=>node.contains(change.target))) {
                for (const node of change.removedNodes)if (node instanceof Element) {
                    visibleNodes.delete(node);
                    hiddenNodes.delete(node);
                }
                for (const node1 of change.addedNodes){
                    if ((node1 instanceof HTMLElement || node1 instanceof SVGElement) && (node1.dataset.liveAnnouncer === "true" || node1.dataset.reactAriaTopLayer === "true")) visibleNodes.add(node1);
                    else if (node1 instanceof Element) walk(node1);
                }
            }
        }
    });
    observer.observe(root, {
        childList: true,
        subtree: true
    });
    const observerWrapper = {
        observe () {
            observer.observe(root, {
                childList: true,
                subtree: true
            });
        },
        disconnect () {
            observer.disconnect();
        }
    };
    observerStack.push(observerWrapper);
    return ()=>{
        observer.disconnect();
        for (const node of hiddenNodes){
            const count = refCountMap.get(node);
            if (count == null) return;
            if (count === 1) {
                node.removeAttribute("aria-hidden");
                refCountMap.delete(node);
            } else refCountMap.set(node, count - 1);
        }
        // Remove this observer from the stack, and start the previous one.
        if (observerWrapper === observerStack[observerStack.length - 1]) {
            observerStack.pop();
            if (observerStack.length) observerStack[observerStack.length - 1].observe();
        } else observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    };
}
/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dismissable-layer/src/DismissableLayer.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/interact-outside/src/index.ts
 */ const POINTER_DOWN_OUTSIDE_EVENT = "interactOutside.pointerDownOutside";
const FOCUS_OUTSIDE_EVENT = "interactOutside.focusOutside";
function createInteractOutside(props, ref) {
    let pointerDownTimeoutId;
    let clickHandler = (0, _utils.noop);
    const ownerDocument = ()=>(0, _utils.getDocument)(ref());
    const onPointerDownOutside = (e)=>props.onPointerDownOutside?.(e);
    const onFocusOutside = (e)=>props.onFocusOutside?.(e);
    const onInteractOutside = (e)=>props.onInteractOutside?.(e);
    const isEventOutside = (e)=>{
        const target = e.target;
        if (!(target instanceof HTMLElement)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (target.closest(`[${DATA_TOP_LAYER_ATTR}]`)) return false;
        if (!(0, _utils.contains)(ownerDocument(), target)) return false;
        if ((0, _utils.contains)(ref(), target)) return false;
        return !props.shouldExcludeElement?.(target);
    };
    const onPointerDown = (e)=>{
        function handler() {
            const container = ref();
            const target = e.target;
            if (!container || !target || !isEventOutside(e)) return;
            const handler = (0, _utils.composeEventHandlers)([
                onPointerDownOutside,
                onInteractOutside
            ]);
            target.addEventListener(POINTER_DOWN_OUTSIDE_EVENT, handler, {
                once: true
            });
            const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE_EVENT, {
                bubbles: false,
                cancelable: true,
                detail: {
                    originalEvent: e,
                    isContextMenu: e.button === 2 || (0, _utils.isCtrlKey)(e) && e.button === 0
                }
            });
            target.dispatchEvent(pointerDownOutsideEvent);
        }
        /**
     * On touch devices, we need to wait for a click event because browsers implement
     * a ~350ms delay between the time the user stops touching the display and when the
     * browser executes events. We need to ensure we don't reactivate pointer-events within
     * this timeframe otherwise the browser may execute events that should have been prevented.
     *
     * Additionally, this also lets us deal automatically with cancellations when a click event
     * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.
     *
     * This is why we also continuously remove the previous listener, because we cannot be
     * certain that it was raised, and therefore cleaned-up.
     */ if (e.pointerType === "touch") {
            ownerDocument().removeEventListener("click", handler);
            clickHandler = handler;
            ownerDocument().addEventListener("click", handler, {
                once: true
            });
        } else handler();
    };
    const onFocusIn = (e)=>{
        const container = ref();
        const target = e.target;
        if (!container || !target || !isEventOutside(e)) return;
        const handler = (0, _utils.composeEventHandlers)([
            onFocusOutside,
            onInteractOutside
        ]);
        target.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
            once: true
        });
        const focusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE_EVENT, {
            bubbles: false,
            cancelable: true,
            detail: {
                originalEvent: e,
                isContextMenu: false
            }
        });
        target.dispatchEvent(focusOutsideEvent);
    };
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        if ((0, _utils.access)(props.isDisabled)) return;
        /**
     * if this primitive executes in a component that mounts via a `pointerdown` event, the event
     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid
     * this by delaying the event listener registration on the document.
     * ```
     * button.addEventListener('pointerdown', () => {
     *   console.log('I will log');
     *   document.addEventListener('pointerdown', () => {
     *     console.log('I will also log');
     *   })
     * });
     */ pointerDownTimeoutId = window.setTimeout(()=>{
            ownerDocument().addEventListener("pointerdown", onPointerDown, true);
        }, 0);
        ownerDocument().addEventListener("focusin", onFocusIn, true);
        (0, _solidJs.onCleanup)(()=>{
            window.clearTimeout(pointerDownTimeoutId);
            ownerDocument().removeEventListener("click", clickHandler);
            ownerDocument().removeEventListener("pointerdown", onPointerDown, true);
            ownerDocument().removeEventListener("focusin", onFocusIn, true);
        });
    });
}
/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/21a7c97dc8efa79fecca36428eec49f187294085/packages/react/presence/src/Presence.tsx
 * https://github.com/radix-ui/primitives/blob/21a7c97dc8efa79fecca36428eec49f187294085/packages/react/presence/src/useStateMachine.tsx
 */ function createPresence(present) {
    const [node, setNode] = (0, _solidJs.createSignal)();
    let styles = {};
    let prevPresent = present();
    let prevAnimationName = "none";
    const [state, send] = createStateMachine(present() ? "mounted" : "unmounted", {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    (0, _solidJs.createEffect)((0, _solidJs.on)(state, (state)=>{
        const currentAnimationName = getAnimationName(styles);
        prevAnimationName = state === "mounted" ? currentAnimationName : "none";
    }));
    (0, _solidJs.createEffect)((0, _solidJs.on)(present, (present)=>{
        if (prevPresent === present) return;
        const currentAnimationName = getAnimationName(styles);
        if (present) send("MOUNT");
        else if (styles?.display === "none") // If the element is hidden, animations won't run, so we unmount instantly
        send("UNMOUNT");
        else {
            /**
       * When `present` changes to `false`, we check changes to animation-name to
       * determine whether an animation has started. We chose this approach (reading
       * computed styles) because there is no `animationrun` event and `animationstart`
       * fires after `animation-delay` has expired which would be too late.
       */ const isAnimating = prevAnimationName !== currentAnimationName;
            if (prevPresent && isAnimating) send("ANIMATION_OUT");
            else send("UNMOUNT");
        }
        prevPresent = present;
    }));
    (0, _solidJs.createEffect)((0, _solidJs.on)(node, (node)=>{
        if (node) {
            /**
       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
       * make sure we only trigger ANIMATION_END for the currently active animation.
       */ const handleAnimationEnd = (event)=>{
                const currentAnimationName = getAnimationName(styles);
                const isCurrentAnimation = currentAnimationName.includes(event.animationName);
                if (event.target === node && isCurrentAnimation) send("ANIMATION_END");
            };
            const handleAnimationStart = (event)=>{
                if (event.target === node) // if animation occurred, store its name as the previous animation.
                prevAnimationName = getAnimationName(styles);
            };
            node.addEventListener("animationstart", handleAnimationStart);
            node.addEventListener("animationcancel", handleAnimationEnd);
            node.addEventListener("animationend", handleAnimationEnd);
            (0, _solidJs.onCleanup)(()=>{
                node.removeEventListener("animationstart", handleAnimationStart);
                node.removeEventListener("animationcancel", handleAnimationEnd);
                node.removeEventListener("animationend", handleAnimationEnd);
            });
        } else // Transition to the unmounted state if the node is removed prematurely.
        // We avoid doing so during cleanup as the node may change but still exist.
        send("ANIMATION_END");
    }));
    return {
        isPresent: ()=>[
                "mounted",
                "unmountSuspended"
            ].includes(state()),
        setRef: (el)=>{
            if (el) styles = getComputedStyle(el);
            setNode(el);
        }
    };
}
/* -----------------------------------------------------------------------------------------------*/ function getAnimationName(styles) {
    return styles?.animationName || "none";
}
// https://fettblog.eu/typescript-union-to-intersection/
function createStateMachine(initialState, machine) {
    const reduce = (state, event)=>{
        const nextState = machine[state][event];
        return nextState ?? state;
    };
    const [state, setState] = (0, _solidJs.createSignal)(initialState);
    const send = (event)=>{
        setState((prev)=>reduce(prev, event));
    };
    return [
        state,
        send
    ];
}
/*!
 * Portions of this file are based on code from floating-ui.
 * MIT Licensed, Copyright (c) 2021 Floating UI contributors.
 *
 * Credits to the Floating UI contributors:
 * https://github.com/floating-ui/floating-ui/blob/f7ce9420aa32c150eb45049f12cf3b5506715341/packages/react/src/components/FloatingOverlay.tsx
 *
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/5d8a1f047fcadcf117073c70359663a3946b73bf/packages/ariakit/src/dialog/__utils/use-prevent-body-scroll.ts
 */ const SCROLL_LOCK_IDENTIFIER = "data-kb-scroll-lock";
function assignStyle(element, style) {
    if (!element) return ()=>{};
    const previousStyle = element.style.cssText;
    Object.assign(element.style, style);
    return ()=>{
        element.style.cssText = previousStyle;
    };
}
function setCSSProperty(element, property, value) {
    if (!element) return ()=>{};
    const previousValue = element.style.getPropertyValue(property);
    element.style.setProperty(property, value);
    return ()=>{
        if (previousValue) element.style.setProperty(property, previousValue);
        else element.style.removeProperty(property);
    };
}
function getPaddingProperty(documentElement) {
    // RTL <body> scrollbar
    const documentLeft = documentElement.getBoundingClientRect().left;
    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
    return scrollbarX ? "paddingLeft" : "paddingRight";
}
/**
 * Prevents scrolling on the document body on mount, and
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */ function createPreventScroll(props) {
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        if (!(0, _utils.access)(props.ownerRef) || (0, _utils.access)(props.isDisabled)) return;
        const doc = (0, _utils.getDocument)((0, _utils.access)(props.ownerRef));
        const win = (0, _utils.getWindow)((0, _utils.access)(props.ownerRef));
        const { documentElement , body  } = doc;
        const alreadyLocked = body.hasAttribute(SCROLL_LOCK_IDENTIFIER);
        if (alreadyLocked) return;
        body.setAttribute(SCROLL_LOCK_IDENTIFIER, "");
        const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
        const setScrollbarWidthProperty = ()=>{
            return setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
        };
        const paddingProperty = getPaddingProperty(documentElement);
        // For most browsers, all we need to do is set `overflow: hidden` on the root element, and
        // add some padding to prevent the page from shifting when the scrollbar is hidden.
        const setStyle = ()=>{
            return assignStyle(body, {
                overflow: "hidden",
                [paddingProperty]: `${scrollbarWidth}px`
            });
        };
        // Only iOS doesn't respect `overflow: hidden` on document.body.
        const setIOSStyle = ()=>{
            const { scrollX , scrollY , visualViewport  } = win;
            // iOS 12 does not support `visualViewport`.
            const offsetLeft = visualViewport?.offsetLeft ?? 0;
            const offsetTop = visualViewport?.offsetTop ?? 0;
            const restoreStyle = assignStyle(body, {
                position: "fixed",
                overflow: "hidden",
                top: `${-(scrollY - Math.floor(offsetTop))}px`,
                left: `${-(scrollX - Math.floor(offsetLeft))}px`,
                right: "0",
                [paddingProperty]: `${scrollbarWidth}px`
            });
            return ()=>{
                restoreStyle();
                win.scrollTo(scrollX, scrollY);
            };
        };
        const cleanup = (0, _utils.chain)([
            setScrollbarWidthProperty(),
            (0, _utils.isIOS)() ? setIOSStyle() : setStyle()
        ]);
        (0, _solidJs.onCleanup)(()=>{
            cleanup();
            body.removeAttribute(SCROLL_LOCK_IDENTIFIER);
        });
    });
}
/**
 * Create a function that call the setter with an id and return a function to reset it.
 */ function createRegisterId(setter) {
    return (id)=>{
        setter(id);
        return ()=>setter(undefined);
    };
}
/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the ariakit team:
 * https://github.com/ariakit/ariakit/blob/8a13899ff807bbf39f3d89d2d5964042ba4d5287/packages/ariakit-react-utils/src/hooks.ts
 */ /**
 * Returns the tag name by parsing an element ref.
 * @example
 * function Component(props) {
 *   let ref: HTMLDivElement | undefined;
 *   const tagName = createTagName(() => ref, () => "button"); // div
 *   return <div ref={ref} {...props} />;
 * }
 */ function createTagName(ref, fallback) {
    const [tagName, setTagName] = (0, _solidJs.createSignal)(stringOrUndefined(fallback?.()));
    (0, _solidJs.createEffect)(()=>{
        setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));
    });
    return tagName;
}
function stringOrUndefined(value) {
    return (0, _utils.isString)(value) ? value : undefined;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a13802d8be6f83af1450e56f7a88527b10d9cadf/packages/@react-stately/toggle/src/useToggleState.ts
 */ /**
 * Provides state management for toggle components like checkboxes and switches.
 */ function createToggleState(props = {}) {
    const [isSelected, _setIsSelected] = createControllableBooleanSignal({
        value: ()=>(0, _utils.access)(props.isSelected),
        defaultValue: ()=>!!(0, _utils.access)(props.defaultIsSelected),
        onChange: (value)=>props.onSelectedChange?.(value)
    });
    const setIsSelected = (value)=>{
        if (!(0, _utils.access)(props.isReadOnly) && !(0, _utils.access)(props.isDisabled)) _setIsSelected(value);
    };
    const toggle = ()=>{
        if (!(0, _utils.access)(props.isReadOnly) && !(0, _utils.access)(props.isDisabled)) _setIsSelected(!isSelected());
    };
    return {
        isSelected,
        setIsSelected,
        toggle
    };
}
/*!
 * Portions of this file are based on code from mantinedev.
 * MIT Licensed, Copyright (c) 2021 Vitaly Rtishchev.
 *
 * Credits to the Mantinedev team:
 * https://github.com/mantinedev/mantine/blob/8546c580fdcaa9653edc6f4813103349a96cfb09/src/mantine-core/src/Transition/get-transition-styles/get-transition-styles.ts
 */ const TRANSITION_PHASES_MAP = {
    beforeEnter: "out",
    enter: "in",
    afterEnter: "in",
    beforeExit: "in",
    //"out",
    exit: "out",
    afterExit: "out"
};
function getTransitionStyles(params) {
    const shared = {
        "transition-duration": `${params.duration}ms`,
        "transition-timing-function": params.easing
    };
    return {
        "transition-property": getTransitionProperty(params.transition),
        ...shared,
        ...params.transition.common,
        ...params.transition[TRANSITION_PHASES_MAP[params.phase]]
    };
}
function getTransitionProperty(transitionStyles) {
    return [
        ...new Set([
            ...Object.keys(transitionStyles.in),
            ...Object.keys(transitionStyles.out)
        ])
    ].join(", ");
}
/*!
 * Portions of this file are based on code from mantinedev.
 * MIT Licensed, Copyright (c) 2021 Vitaly Rtishchev.
 *
 * Credits to the Mantinedev team:
 * https://github.com/mantinedev/mantine/blob/8546c580fdcaa9653edc6f4813103349a96cfb09/src/mantine-core/src/Transition/use-transition.ts
 */ const DEFAULT_DURATION = 250;
const DEFAULT_DELAY = 10;
const DEFAULT_EASING = "ease";
/**
 * Primitive for working with enter/exit transitions.
 *
 * @param shouldMount Whether the component should be mounted.
 * @param options The transition options.
 */ function createTransition(shouldMount, options) {
    options = (0, _solidJs.mergeProps)({
        duration: DEFAULT_DURATION,
        delay: DEFAULT_DELAY,
        easing: DEFAULT_EASING,
        get exitDuration () {
            return (0, _utils.access)(options).duration || DEFAULT_DURATION;
        },
        get exitDelay () {
            return (0, _utils.access)(options).delay || DEFAULT_DELAY;
        },
        get exitEasing () {
            return (0, _utils.access)(options).easing || DEFAULT_EASING;
        }
    }, options);
    const reduceMotion = (0, _utils.createMediaQuery)("(prefers-reduced-motion: reduce)");
    const [duration, setDuration] = (0, _solidJs.createSignal)(reduceMotion() ? 0 : (0, _utils.access)(options).duration);
    const [phase, setPhase] = (0, _solidJs.createSignal)((0, _utils.access)(shouldMount) ? "afterEnter" : "afterExit");
    const [easing, setEasing] = (0, _solidJs.createSignal)((0, _utils.access)(options).easing);
    let timeoutId = -1;
    const handleStateChange = (shouldMount)=>{
        const preHandler = shouldMount ? (0, _utils.access)(options).onBeforeEnter : (0, _utils.access)(options).onBeforeExit;
        const postHandler = shouldMount ? (0, _utils.access)(options).onAfterEnter : (0, _utils.access)(options).onAfterExit;
        setPhase(shouldMount ? "beforeEnter" : "beforeExit");
        window.clearTimeout(timeoutId);
        const newDuration = setDuration(reduceMotion() ? 0 : shouldMount ? (0, _utils.access)(options).duration : (0, _utils.access)(options).exitDuration);
        setEasing(shouldMount ? (0, _utils.access)(options).easing : (0, _utils.access)(options).exitEasing);
        if (newDuration === 0) {
            preHandler?.();
            postHandler?.();
            setPhase(shouldMount ? "afterEnter" : "afterExit");
            return;
        }
        const delay = reduceMotion() ? 0 : shouldMount ? (0, _utils.access)(options).delay : (0, _utils.access)(options).exitDelay;
        const preStateTimeoutId = window.setTimeout(()=>{
            preHandler?.();
            setPhase(shouldMount ? "enter" : "exit");
        }, delay);
        timeoutId = window.setTimeout(()=>{
            window.clearTimeout(preStateTimeoutId);
            postHandler?.();
            setPhase(shouldMount ? "afterEnter" : "afterExit");
        }, delay + newDuration);
    };
    const style = (0, _solidJs.createMemo)(()=>getTransitionStyles({
            transition: (0, _utils.access)(options).transition,
            duration: duration(),
            phase: phase(),
            easing: easing()
        }));
    const keepMounted = (0, _solidJs.createMemo)(()=>phase() !== "afterExit");
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>(0, _utils.access)(shouldMount), (shouldMount)=>handleStateChange(shouldMount), {
        defer: true
    }));
    (0, _solidJs.onCleanup)(()=>{
        if (0, _web.isServer) return;
        window.clearTimeout(timeoutId);
    });
    return {
        keepMounted,
        style
    };
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/70e7caf1946c423bc9aa9cb0e50dbdbe953d239b/packages/@react-aria/label/src/useField.ts
 */ const FORM_CONTROL_PROP_NAMES = [
    "id",
    "name",
    "validationState",
    "required",
    "disabled",
    "readOnly"
];
function createFormControl(props) {
    const defaultId = `form-control-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [labelId, setLabelId] = (0, _solidJs.createSignal)();
    const [fieldId, setFieldId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const [errorMessageId, setErrorMessageId] = (0, _solidJs.createSignal)();
    const getAriaLabelledBy = (fieldId, fieldAriaLabel, fieldAriaLabelledBy)=>{
        const hasAriaLabelledBy = fieldAriaLabelledBy != null || labelId() != null;
        return [
            fieldAriaLabelledBy,
            labelId(),
            // If there is both an aria-label and aria-labelledby, add the field itself has an aria-labelledby
            hasAriaLabelledBy && fieldAriaLabel != null ? fieldId : undefined
        ].filter(Boolean).join(" ") || undefined;
    };
    const getAriaDescribedBy = (fieldAriaDescribedBy)=>{
        return [
            descriptionId(),
            // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA.
            // See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
            errorMessageId(),
            fieldAriaDescribedBy
        ].filter(Boolean).join(" ") || undefined;
    };
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-valid": (0, _utils.access)(props.validationState) === "valid" ? "" : undefined,
            "data-invalid": (0, _utils.access)(props.validationState) === "invalid" ? "" : undefined,
            "data-required": (0, _utils.access)(props.required) ? "" : undefined,
            "data-disabled": (0, _utils.access)(props.disabled) ? "" : undefined,
            "data-readonly": (0, _utils.access)(props.readOnly) ? "" : undefined
        }));
    const formControlContext = {
        name: ()=>(0, _utils.access)(props.name) ?? (0, _utils.access)(props.id),
        dataset,
        validationState: ()=>(0, _utils.access)(props.validationState),
        isRequired: ()=>(0, _utils.access)(props.required),
        isDisabled: ()=>(0, _utils.access)(props.disabled),
        isReadOnly: ()=>(0, _utils.access)(props.readOnly),
        labelId,
        fieldId,
        descriptionId,
        errorMessageId,
        getAriaLabelledBy,
        getAriaDescribedBy,
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(props.id)),
        registerLabel: createRegisterId(setLabelId),
        registerField: createRegisterId(setFieldId),
        registerDescription: createRegisterId(setDescriptionId),
        registerErrorMessage: createRegisterId(setErrorMessageId)
    };
    return {
        formControlContext
    };
}
const FormControlContext = (0, _solidJs.createContext)();
function useFormControlContext() {
    const context = (0, _solidJs.useContext)(FormControlContext);
    if (context === undefined) throw new Error("[kobalte]: `useFormControlContext` must be used within a `FormControlContext.Provider` component");
    return context;
}
const FORM_CONTROL_FIELD_PROP_NAMES = [
    "id",
    "aria-label",
    "aria-labelledby",
    "aria-describedby"
];
function createFormControlField(props) {
    const context = useFormControlContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("field")
    }, props);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerField((0, _utils.access)(props.id))));
    return {
        fieldProps: {
            id: ()=>(0, _utils.access)(props.id),
            ariaLabel: ()=>(0, _utils.access)(props["aria-label"]),
            ariaLabelledBy: ()=>context.getAriaLabelledBy((0, _utils.access)(props.id), (0, _utils.access)(props["aria-label"]), (0, _utils.access)(props["aria-labelledby"])),
            ariaDescribedBy: ()=>context.getAriaDescribedBy((0, _utils.access)(props["aria-describedby"]))
        }
    };
}
/* -------------------------------------------------------------------------------------------------
 * Polymorphic
 * -----------------------------------------------------------------------------------------------*/ /**
 * A utility component that render either a direct `<As>` child or its `as` prop.
 */ function Polymorphic(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "asChild",
        "as",
        "children"
    ]);
    // Prevent the extra computation below when "as child" polymorphism is not needed.
    if (!local.asChild) return (0, _web.createComponent)((0, _web.Dynamic), (0, _web.mergeProps)({
        get component () {
            return local.as;
        }
    }, others, {
        get children () {
            return local.children;
        }
    }));
    const resolvedChildren = (0, _solidJs.children)(()=>local.children);
    // Single child is `As`.
    if (isAs(resolvedChildren())) {
        const combinedProps = combineProps(others, resolvedChildren()?.props ?? {});
        return (0, _web.createComponent)((0, _web.Dynamic), combinedProps);
    }
    // Multiple children, find an `As` if any.
    if ((0, _utils.isArray)(resolvedChildren())) {
        const newElement = resolvedChildren().find(isAs);
        if (newElement) {
            // because the new element will be the one rendered, we are only interested
            // in grabbing its children (`newElement.props.children`)
            const newChildren = ()=>(0, _web.createComponent)((0, _solidJs.For), {
                    get each () {
                        return resolvedChildren();
                    },
                    children: (child)=>(0, _web.createComponent)((0, _solidJs.Show), {
                            when: child === newElement,
                            fallback: child,
                            get children () {
                                return newElement.props.children;
                            }
                        })
                });
            const combinedProps1 = combineProps(others, newElement?.props ?? {});
            return (0, _web.createComponent)((0, _web.Dynamic), (0, _web.mergeProps)(combinedProps1, {
                children: newChildren
            }));
        }
    }
    throw new Error("[kobalte]: Component is expected to render `asChild` but no children `As` component was found.");
}
/* -------------------------------------------------------------------------------------------------
 * As
 * -----------------------------------------------------------------------------------------------*/ const AS_COMPONENT_SYMBOL = Symbol("$$KobalteAsComponent");
/**
 * A utility component used to delegate rendering of its `Polymorphic` parent component.
 */ function As(props) {
    return {
        [AS_COMPONENT_SYMBOL]: true,
        props
    };
}
/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*/ function isAs(component) {
    return component?.[AS_COMPONENT_SYMBOL] === true;
}
function combineProps(baseProps, overrideProps) {
    return (0, _utils.combineProps)([
        baseProps,
        overrideProps
    ], {
        reverseEventHandlers: true
    });
}
/**
 * The description that gives the user more information on the form control.
 */ function FormControlDescription(props) {
    const context = useFormControlContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescription(props.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div"
    }, ()=>context.dataset(), props));
}
/**
 * The error message that gives the user information about how to fix a validation error on the form control.
 */ function FormControlErrorMessage(props) {
    const context = useFormControlContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("error-message")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "forceMount"
    ]);
    const isInvalid = ()=>context.validationState() === "invalid";
    (0, _solidJs.createEffect)(()=>{
        if (!isInvalid()) return;
        (0, _solidJs.onCleanup)(context.registerErrorMessage(others.id));
    });
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return local.forceMount || isInvalid();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div"
            }, ()=>context.dataset(), others));
        }
    });
}
/**
 * The label that gives the user information on the form control.
 */ function FormControlLabel(props) {
    let ref;
    const context = useFormControlContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("label")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref"
    ]);
    const tagName = createTagName(()=>ref, ()=>"label");
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerLabel(others.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "label",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get ["for"] () {
            return (0, _web.memo)(()=>tagName() === "label")() ? context.fieldId() : undefined;
        }
    }, ()=>context.dataset(), others));
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/utils.ts
 */ // https://en.wikipedia.org/wiki/Right-to-left
const RTL_SCRIPTS = new Set([
    "Avst",
    "Arab",
    "Armi",
    "Syrc",
    "Samr",
    "Mand",
    "Thaa",
    "Mend",
    "Nkoo",
    "Adlm",
    "Rohg",
    "Hebr"
]);
const RTL_LANGS = new Set([
    "ae",
    "ar",
    "arc",
    "bcc",
    "bqi",
    "ckb",
    "dv",
    "fa",
    "glk",
    "he",
    "ku",
    "mzn",
    "nqo",
    "pnb",
    "ps",
    "sd",
    "ug",
    "ur",
    "yi"
]);
/**
 * Determines if a locale is read right to left using [Intl.Locale]
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale}.
 */ function isRTL(locale) {
    // If the Intl.Locale API is available, use it to get the script for the locale.
    // This is more accurate than guessing by language, since languages can be written in multiple scripts.
    if (Intl.Locale) {
        const script = new Intl.Locale(locale).maximize().script ?? "";
        return RTL_SCRIPTS.has(script);
    }
    // If not, just guess by the language (first part of the locale)
    const lang = locale.split("-")[0];
    return RTL_LANGS.has(lang);
}
function getReadingDirection(locale) {
    return isRTL(locale) ? "rtl" : "ltr";
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useDefaultLocale.ts
 */ /**
 * Gets the locale setting of the browser.
 */ function getDefaultLocale() {
    let locale = // @ts-ignore
    typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
    try {
        Intl.DateTimeFormat.supportedLocalesOf([
            locale
        ]);
    } catch (_err) {
        locale = "en-US";
    }
    return {
        locale,
        direction: getReadingDirection(locale)
    };
}
let currentLocale = getDefaultLocale();
const listeners = new Set();
function updateLocale() {
    currentLocale = getDefaultLocale();
    for (const listener of listeners)listener(currentLocale);
}
/**
 * Returns an accessor for the current browser/system language, and updates when it changes.
 */ function createDefaultLocale() {
    // We cannot determine the browser's language on the server, so default to en-US.
    // This will be updated after hydration on the client to the correct value.
    const defaultSSRLocale = {
        locale: "en-US",
        direction: "ltr"
    };
    const [defaultClientLocale, setDefaultClientLocale] = (0, _solidJs.createSignal)(currentLocale);
    const defaultLocale = (0, _solidJs.createMemo)(()=>(0, _web.isServer) ? defaultSSRLocale : defaultClientLocale());
    (0, _solidJs.onMount)(()=>{
        if (listeners.size === 0) window.addEventListener("languagechange", updateLocale);
        listeners.add(setDefaultClientLocale);
        (0, _solidJs.onCleanup)(()=>{
            listeners.delete(setDefaultClientLocale);
            if (listeners.size === 0) window.removeEventListener("languagechange", updateLocale);
        });
    });
    return {
        locale: ()=>defaultLocale().locale,
        direction: ()=>defaultLocale().direction
    };
}
const I18nContext = (0, _solidJs.createContext)();
/**
 * Provides the locale for the application to all child components.
 */ function I18nProvider(props) {
    const defaultLocale = createDefaultLocale();
    const context = {
        locale: ()=>props.locale ?? defaultLocale.locale(),
        direction: ()=>props.locale ? getReadingDirection(props.locale) : defaultLocale.direction()
    };
    return (0, _web.createComponent)(I18nContext.Provider, {
        value: context,
        get children () {
            return props.children;
        }
    });
}
/**
 * Returns an accessor for the current locale and layout direction.
 */ function useLocale() {
    const defaultLocale = createDefaultLocale();
    const context = (0, _solidJs.useContext)(I18nContext);
    return context || defaultLocale;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useCollator.ts
 */ const cache = new Map();
/**
 * Provides localized string collation for the current locale. Automatically updates when the locale changes,
 * and handles caching of the collator for performance.
 * @param options - Collator options.
 */ function createCollator(options) {
    const { locale  } = useLocale();
    const cacheKey = (0, _solidJs.createMemo)(()=>{
        return locale() + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    });
    return (0, _solidJs.createMemo)(()=>{
        const key = cacheKey();
        let collator;
        if (cache.has(key)) collator = cache.get(key);
        if (!collator) {
            collator = new Intl.Collator(locale(), options);
            cache.set(key, collator);
        }
        return collator;
    });
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/i18n/src/useDateFormatter.ts
 */ /**
 * Provides localized date formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the date formatter for performance.
 * @param options - Formatting options.
 */ function createDateFormatter(options) {
    const { locale  } = useLocale();
    return (0, _solidJs.createMemo)(()=>new (0, _date.DateFormatter)(locale(), (0, _utils.access)(options)));
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/22cb32d329e66c60f55d4fc4025d1d44bb015d71/packages/@react-aria/i18n/src/useFilter.ts
 */ /**
 * Provides localized string search functionality that is useful for filtering or matching items
 * in a list. Options can be provided to adjust the sensitivity to case, diacritics, and other parameters.
 */ function createFilter(options) {
    const collator = createCollator({
        usage: "search",
        ...options
    });
    // TODO: these methods don't currently support the ignorePunctuation option.
    const startsWith = (str, substr)=>{
        if (substr.length === 0) return true;
        // Normalize both strings so we can slice safely
        // TODO: take into account the ignorePunctuation option as well...
        str = str.normalize("NFC");
        substr = substr.normalize("NFC");
        return collator().compare(str.slice(0, substr.length), substr) === 0;
    };
    const endsWith = (str, substr)=>{
        if (substr.length === 0) return true;
        str = str.normalize("NFC");
        substr = substr.normalize("NFC");
        return collator().compare(str.slice(-substr.length), substr) === 0;
    };
    const contains = (str, substr)=>{
        if (substr.length === 0) return true;
        str = str.normalize("NFC");
        substr = substr.normalize("NFC");
        let scan = 0;
        const sliceLen = substr.length;
        for(; scan + sliceLen <= str.length; scan++){
            const slice = str.slice(scan, scan + sliceLen);
            if (collator().compare(substr, slice) === 0) return true;
        }
        return false;
    };
    return {
        startsWith,
        endsWith,
        contains
    };
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useNumberFormatter.ts
 */ /**
 * Provides localized number formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the number formatter for performance.
 * @param options - Formatting options.
 */ function createNumberFormatter(options) {
    const { locale  } = useLocale();
    return (0, _solidJs.createMemo)(()=>new (0, _number.NumberFormatter)(locale(), (0, _utils.access)(options)));
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/Selection.ts
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/types.ts
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-types/shared/src/selection.d.ts
 */ /**
 * A Selection is a special Set containing Keys, which also has an anchor
 * and current selected key for use when range selecting.
 */ class Selection extends Set {
    constructor(keys, anchorKey, currentKey){
        super(keys);
        if (keys instanceof Selection) {
            this.anchorKey = anchorKey || keys.anchorKey;
            this.currentKey = currentKey || keys.currentKey;
        } else {
            this.anchorKey = anchorKey;
            this.currentKey = currentKey;
        }
    }
}
/**
 * Creates a simple reactive `Selection` state with a getter, setter and a fallback value of an empty selection,
 * that can be controlled with `value` and `onChange` props.
 */ function createControllableSelectionSignal(props) {
    const [_value, setValue] = createControllableSignal(props);
    const value = ()=>_value() ?? new Selection();
    return [
        value,
        setValue
    ];
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/utils.ts
 */ function isNonContiguousSelectionModifier(e) {
    // Ctrl + Arrow Up/Arrow Down has a system-wide meaning on macOS, so use Alt instead.
    // On Windows and Ubuntu, Alt + Space has a system-wide meaning.
    return (0, _utils.isAppleDevice)() ? e.altKey : e.ctrlKey;
}
function isCtrlKeyPressed(e) {
    if ((0, _utils.isMac)()) return e.metaKey;
    return e.ctrlKey;
}
function convertSelection(selection) {
    return new Selection(selection);
}
function isSameSelection(setA, setB) {
    if (setA.size !== setB.size) return false;
    for (const item of setA){
        if (!setB.has(item)) return false;
    }
    return true;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/useMultipleSelectionState.ts
 */ /**
 * Manages state for multiple selection and focus in a collection.
 */ function createMultipleSelectionState(props) {
    props = (0, _utils.mergeDefaultProps)({
        selectionMode: "none",
        selectionBehavior: "toggle"
    }, props);
    const [isFocused, setFocused] = (0, _solidJs.createSignal)(false);
    const [focusedKey, setFocusedKey] = (0, _solidJs.createSignal)();
    const selectedKeysProp = (0, _solidJs.createMemo)(()=>{
        const selection = (0, _utils.access)(props.selectedKeys);
        if (selection != null) return convertSelection(selection);
        return selection;
    });
    const defaultSelectedKeys = (0, _solidJs.createMemo)(()=>{
        const defaultSelection = (0, _utils.access)(props.defaultSelectedKeys);
        if (defaultSelection != null) return convertSelection(defaultSelection);
        return new Selection();
    });
    const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({
        value: selectedKeysProp,
        defaultValue: defaultSelectedKeys,
        onChange: (value)=>props.onSelectionChange?.(value)
    });
    const [selectionBehavior, setSelectionBehavior] = (0, _solidJs.createSignal)((0, _utils.access)(props.selectionBehavior));
    const selectionMode = ()=>(0, _utils.access)(props.selectionMode);
    const disallowEmptySelection = ()=>(0, _utils.access)(props.disallowEmptySelection) ?? false;
    const setSelectedKeys = (keys)=>{
        if ((0, _utils.access)(props.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) _setSelectedKeys(keys);
    };
    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press
    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.
    (0, _solidJs.createEffect)(()=>{
        const selection = selectedKeys();
        if ((0, _utils.access)(props.selectionBehavior) === "replace" && selectionBehavior() === "toggle" && typeof selection === "object" && selection.size === 0) setSelectionBehavior("replace");
    });
    // If the selectionBehavior prop changes, update the state as well.
    (0, _solidJs.createEffect)(()=>{
        setSelectionBehavior((0, _utils.access)(props.selectionBehavior) ?? "toggle");
    });
    return {
        selectionMode,
        disallowEmptySelection,
        selectionBehavior,
        setSelectionBehavior,
        isFocused,
        setFocused,
        focusedKey,
        setFocusedKey,
        selectedKeys,
        setSelectedKeys
    };
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useTypeSelect.ts
 */ /**
 * Handles typeahead interactions with collections.
 */ function createTypeSelect(props) {
    const [search, setSearch] = (0, _solidJs.createSignal)("");
    const [timeoutId, setTimeoutId] = (0, _solidJs.createSignal)(-1);
    const onKeyDown = (e)=>{
        if ((0, _utils.access)(props.isDisabled)) return;
        const delegate = (0, _utils.access)(props.keyboardDelegate);
        const manager = (0, _utils.access)(props.selectionManager);
        if (!delegate.getKeyForSearch) return;
        const character = getStringForKey(e.key);
        if (!character || e.ctrlKey || e.metaKey) return;
        // Do not propagate the Space bar event if it's meant to be part of the search.
        // When we time out, the search term becomes empty, hence the check on length.
        // Trimming is to account for the case of pressing the Space bar more than once,
        // which should cycle through the selection/deselection of the focused item.
        if (character === " " && search().trim().length > 0) {
            e.preventDefault();
            e.stopPropagation();
        }
        let newSearch = setSearch((prev)=>prev += character);
        // Use the delegate to find a key to focus.
        // Prioritize items after the currently focused item, falling back to searching the whole list.
        let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
        // If not key found, and the search is multiple iterations of the same letter (e.g "aaa"),
        // then cycle through first-letter matches
        if (key == null && isAllSameLetter(newSearch)) {
            newSearch = newSearch[0];
            key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
        }
        if (key != null) {
            manager.setFocusedKey(key);
            props.onTypeSelect?.(key);
        }
        clearTimeout(timeoutId());
        setTimeoutId(window.setTimeout(()=>setSearch(""), 500));
    };
    return {
        typeSelectHandlers: {
            onKeyDown
        }
    };
}
function getStringForKey(key) {
    // If the key is of length 1, it is an ASCII value.
    // Otherwise, if there are no ASCII characters in the key name,
    // it is a Unicode character.
    // See https://www.w3.org/TR/uievents-key/
    if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;
    return "";
}
function isAllSameLetter(search) {
    return search.split("").every((letter)=>letter === search[0]);
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableCollection.ts
 */ /**
 * Handles interactions with selectable collections.
 * @param props Props for the collection.
 * @param ref The ref attached to the element representing the collection.
 * @param scrollRef The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections. If not provided, defaults to the collection ref.
 */ function createSelectableCollection(props, ref, scrollRef) {
    const defaultProps = {
        selectOnFocus: ()=>(0, _utils.access)(props.selectionManager).selectionBehavior() === "replace"
    };
    props = (0, _solidJs.mergeProps)(defaultProps, props);
    const finalScrollRef = ()=>scrollRef?.() ?? ref();
    const { direction  } = useLocale();
    // Store the scroll position, so we can restore it later.
    let scrollPos = {
        top: 0,
        left: 0
    };
    (0, _utils.createEventListener)(()=>!(0, _utils.access)(props.isVirtualized) ? finalScrollRef() : undefined, "scroll", ()=>{
        const scrollEl = finalScrollRef();
        if (!scrollEl) return;
        scrollPos = {
            top: scrollEl.scrollTop,
            left: scrollEl.scrollLeft
        };
    });
    const { typeSelectHandlers  } = createTypeSelect({
        isDisabled: ()=>(0, _utils.access)(props.disallowTypeAhead),
        keyboardDelegate: ()=>(0, _utils.access)(props.keyboardDelegate),
        selectionManager: ()=>(0, _utils.access)(props.selectionManager)
    });
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, typeSelectHandlers.onKeyDown);
        // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes
        if (e.altKey && e.key === "Tab") e.preventDefault();
        const refEl = ref();
        // Keyboard events bubble through portals. Don't handle keyboard events
        // for elements outside the collection (e.g. menus).
        if (!refEl?.contains(e.target)) return;
        const manager = (0, _utils.access)(props.selectionManager);
        const selectOnFocus = (0, _utils.access)(props.selectOnFocus);
        const navigateToKey = (key)=>{
            if (key != null) {
                manager.setFocusedKey(key);
                if (e.shiftKey && manager.selectionMode() === "multiple") manager.extendSelection(key);
                else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) manager.replaceSelection(key);
            }
        };
        const delegate = (0, _utils.access)(props.keyboardDelegate);
        const shouldFocusWrap = (0, _utils.access)(props.shouldFocusWrap);
        const focusedKey = manager.focusedKey();
        switch(e.key){
            case "ArrowDown":
                if (delegate.getKeyBelow) {
                    e.preventDefault();
                    let nextKey;
                    if (focusedKey != null) nextKey = delegate.getKeyBelow(focusedKey);
                    else nextKey = delegate.getFirstKey?.();
                    if (nextKey == null && shouldFocusWrap) nextKey = delegate.getFirstKey?.(focusedKey);
                    navigateToKey(nextKey);
                }
                break;
            case "ArrowUp":
                if (delegate.getKeyAbove) {
                    e.preventDefault();
                    let nextKey1;
                    if (focusedKey != null) nextKey1 = delegate.getKeyAbove(focusedKey);
                    else nextKey1 = delegate.getLastKey?.();
                    if (nextKey1 == null && shouldFocusWrap) nextKey1 = delegate.getLastKey?.(focusedKey);
                    navigateToKey(nextKey1);
                }
                break;
            case "ArrowLeft":
                if (delegate.getKeyLeftOf) {
                    e.preventDefault();
                    const isRTL = direction() === "rtl";
                    let nextKey2;
                    if (focusedKey != null) nextKey2 = delegate.getKeyLeftOf(focusedKey);
                    else nextKey2 = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();
                    navigateToKey(nextKey2);
                }
                break;
            case "ArrowRight":
                if (delegate.getKeyRightOf) {
                    e.preventDefault();
                    const isRTL1 = direction() === "rtl";
                    let nextKey3;
                    if (focusedKey != null) nextKey3 = delegate.getKeyRightOf(focusedKey);
                    else nextKey3 = isRTL1 ? delegate.getLastKey?.() : delegate.getFirstKey?.();
                    navigateToKey(nextKey3);
                }
                break;
            case "Home":
                if (delegate.getFirstKey) {
                    e.preventDefault();
                    const firstKey = delegate.getFirstKey(focusedKey, isCtrlKeyPressed(e));
                    if (firstKey != null) {
                        manager.setFocusedKey(firstKey);
                        if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") manager.extendSelection(firstKey);
                        else if (selectOnFocus) manager.replaceSelection(firstKey);
                    }
                }
                break;
            case "End":
                if (delegate.getLastKey) {
                    e.preventDefault();
                    const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));
                    if (lastKey != null) {
                        manager.setFocusedKey(lastKey);
                        if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") manager.extendSelection(lastKey);
                        else if (selectOnFocus) manager.replaceSelection(lastKey);
                    }
                }
                break;
            case "PageDown":
                if (delegate.getKeyPageBelow && focusedKey != null) {
                    e.preventDefault();
                    const nextKey4 = delegate.getKeyPageBelow(focusedKey);
                    navigateToKey(nextKey4);
                }
                break;
            case "PageUp":
                if (delegate.getKeyPageAbove && focusedKey != null) {
                    e.preventDefault();
                    const nextKey5 = delegate.getKeyPageAbove(focusedKey);
                    navigateToKey(nextKey5);
                }
                break;
            case "a":
                if (isCtrlKeyPressed(e) && manager.selectionMode() === "multiple" && (0, _utils.access)(props.disallowSelectAll) !== true) {
                    e.preventDefault();
                    manager.selectAll();
                }
                break;
            case "Escape":
                if (!e.defaultPrevented) {
                    e.preventDefault();
                    if (!(0, _utils.access)(props.disallowEmptySelection)) manager.clearSelection();
                }
                break;
            case "Tab":
                if (!(0, _utils.access)(props.allowsTabNavigation)) {
                    // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
                    // However, collections should be treated as a single tab stop, with arrow key navigation internally.
                    // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
                    // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
                    // in the collection, so that the browser default behavior will apply starting from that element
                    // rather than the currently focused one.
                    if (e.shiftKey) refEl.focus();
                    else {
                        const walker = (0, _utils.getFocusableTreeWalker)(refEl, {
                            tabbable: true
                        });
                        let next;
                        let last;
                        do {
                            last = walker.lastChild();
                            if (last) next = last;
                        }while (last);
                        if (next && !next.contains(document.activeElement)) (0, _utils.focusWithoutScrolling)(next);
                    }
                    break;
                }
        }
    };
    const onFocusIn = (e)=>{
        const manager = (0, _utils.access)(props.selectionManager);
        const delegate = (0, _utils.access)(props.keyboardDelegate);
        const selectOnFocus = (0, _utils.access)(props.selectOnFocus);
        if (manager.isFocused()) {
            // If a focus event bubbled through a portal, reset focus state.
            if (!e.currentTarget.contains(e.target)) manager.setFocused(false);
            return;
        }
        // Focus events can bubble through portals. Ignore these events.
        if (!e.currentTarget.contains(e.target)) return;
        manager.setFocused(true);
        if (manager.focusedKey() == null) {
            const navigateToFirstKey = (key)=>{
                if (key == null) return;
                manager.setFocusedKey(key);
                if (selectOnFocus) manager.replaceSelection(key);
            };
            // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
            // Attempt to detect whether the user is tabbing forward or backward into the collection
            // and either focus the first or last item accordingly.
            const relatedTarget = e.relatedTarget;
            if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey(manager.lastSelectedKey() ?? delegate.getLastKey?.());
            else navigateToFirstKey(manager.firstSelectedKey() ?? delegate.getFirstKey?.());
        } else if (!(0, _utils.access)(props.isVirtualized)) {
            const scrollEl = finalScrollRef();
            if (scrollEl) {
                // Restore the scroll position to what it was before.
                scrollEl.scrollTop = scrollPos.top;
                scrollEl.scrollLeft = scrollPos.left;
                // Refocus and scroll the focused item into view if it exists within the scrollable region.
                const element = scrollEl.querySelector(`[data-key="${manager.focusedKey()}"]`);
                if (element) {
                    // This prevents a flash of focus on the first/last element in the collection
                    (0, _utils.focusWithoutScrolling)(element);
                    (0, _utils.scrollIntoView)(scrollEl, element);
                }
            }
        }
    };
    const onFocusOut = (e)=>{
        const manager = (0, _utils.access)(props.selectionManager);
        // Don't set blurred and then focused again if moving focus within the collection.
        if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);
    };
    const onMouseDown = (e)=>{
        // Ignore events that bubbled through portals.
        if (finalScrollRef() === e.target) // Prevent focus going to the collection when clicking on the scrollbar.
        e.preventDefault();
    };
    const tryAutoFocus = ()=>{
        const autoFocus = (0, _utils.access)(props.autoFocus);
        if (!autoFocus) return;
        const manager = (0, _utils.access)(props.selectionManager);
        const delegate = (0, _utils.access)(props.keyboardDelegate);
        let focusedKey;
        // Check focus strategy to determine which item to focus
        if (autoFocus === "first") focusedKey = delegate.getFirstKey?.();
        if (autoFocus === "last") focusedKey = delegate.getLastKey?.();
        // If there are any selected keys, make the first one the new focus target
        const selectedKeys = manager.selectedKeys();
        if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;
        manager.setFocused(true);
        manager.setFocusedKey(focusedKey);
        const refEl = ref();
        // If no default focus key is selected, focus the collection itself.
        if (refEl && focusedKey == null && !(0, _utils.access)(props.shouldUseVirtualFocus)) (0, _utils.focusWithoutScrolling)(refEl);
    };
    (0, _solidJs.onMount)(()=>{
        if (props.deferAutoFocus) setTimeout(tryAutoFocus, 0); // TODO: does this work EVERY time ?
        else tryAutoFocus();
    });
    // If not virtualized, scroll the focused element into view when the focusedKey changes.
    // When virtualized, the Virtualizer should handle this.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        finalScrollRef,
        ()=>(0, _utils.access)(props.isVirtualized),
        ()=>(0, _utils.access)(props.selectionManager).focusedKey()
    ], (newValue)=>{
        const [scrollEl, isVirtualized, focusedKey] = newValue;
        if (isVirtualized) focusedKey && props.scrollToKey?.(focusedKey);
        else if (focusedKey && scrollEl) {
            const element = scrollEl.querySelector(`[data-key="${focusedKey}"]`);
            if (element) (0, _utils.scrollIntoView)(scrollEl, element);
        }
    }));
    // If nothing is focused within the collection, make the collection itself tabbable.
    // This will be marshalled to either the first or last item depending on where focus came from.
    // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
    // to move real DOM focus to the element anyway.
    const tabIndex = (0, _solidJs.createMemo)(()=>{
        if ((0, _utils.access)(props.shouldUseVirtualFocus)) return undefined;
        return (0, _utils.access)(props.selectionManager).focusedKey() == null ? 0 : -1;
    });
    return {
        tabIndex,
        onKeyDown,
        onMouseDown,
        onFocusIn,
        onFocusOut
    };
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableItem.ts
 */ /**
 * Handles interactions with an item in a selectable collection.
 * @param props Props for the item.
 * @param ref Ref to the item.
 */ function createSelectableItem(props, ref) {
    const manager = ()=>(0, _utils.access)(props.selectionManager);
    const key = ()=>(0, _utils.access)(props.key);
    const shouldUseVirtualFocus = ()=>(0, _utils.access)(props.shouldUseVirtualFocus);
    const onSelect = (e)=>{
        if (manager().selectionMode() === "none") return;
        if (manager().selectionMode() === "single") {
            if (manager().isSelected(key()) && !manager().disallowEmptySelection()) manager().toggleSelection(key());
            else manager().replaceSelection(key());
        } else if (e && e.shiftKey) manager().extendSelection(key());
        else if (manager().selectionBehavior() === "toggle" || isCtrlKeyPressed(e) || "pointerType" in e && e.pointerType === "touch") // if touch then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
        manager().toggleSelection(key());
        else manager().replaceSelection(key());
    };
    const isSelected = ()=>manager().isSelected(key());
    // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.
    // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.
    // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.
    // With touch, onAction occurs on single tap, and long press enters selection mode.
    const isDisabled = ()=>(0, _utils.access)(props.disabled) || manager().isDisabled(key());
    const allowsSelection = ()=>!isDisabled() && manager().canSelectItem(key());
    let pointerDownType = null;
    const onPointerDown = (e)=>{
        if (!allowsSelection()) return;
        pointerDownType = e.pointerType;
        // Selection occurs on mouse down (main button).
        if (e.pointerType === "mouse" && e.button === 0 && !(0, _utils.access)(props.shouldSelectOnPressUp)) onSelect(e);
    };
    // By default, selection occurs on pointer down. This can be strange if selecting an
    // item causes the UI to disappear immediately (e.g. menus).
    // If shouldSelectOnPressUp is true, we use onPointerUp instead of onPointerDown.
    const onPointerUp = (e)=>{
        if (!allowsSelection()) return;
        // If allowsDifferentPressOrigin, make selection happen on mouse up (main button).
        // Otherwise, have selection happen on click.
        if (e.pointerType === "mouse" && e.button === 0 && (0, _utils.access)(props.shouldSelectOnPressUp) && (0, _utils.access)(props.allowsDifferentPressOrigin)) onSelect(e);
    };
    const onClick = (e)=>{
        if (!allowsSelection()) return;
        // If not allowsDifferentPressOrigin or pointerType is touch/pen, make selection happen on click.
        if ((0, _utils.access)(props.shouldSelectOnPressUp) && !(0, _utils.access)(props.allowsDifferentPressOrigin) || pointerDownType !== "mouse") onSelect(e);
    };
    // For keyboard events, selection occurs on key down (Enter or Space bar).
    const onKeyDown = (e)=>{
        if (!allowsSelection() || ![
            "Enter",
            " "
        ].includes(e.key)) return;
        if (isNonContiguousSelectionModifier(e)) manager().toggleSelection(key());
        else onSelect(e);
    };
    const onMouseDown = (e)=>{
        if (isDisabled()) // Prevent focus going to the body when clicking on a disabled item.
        e.preventDefault();
    };
    const onFocus = (e)=>{
        const refEl = ref();
        if (shouldUseVirtualFocus() || isDisabled() || !refEl) return;
        if (e.target === refEl) manager().setFocusedKey(key());
    };
    // Set tabIndex to 0 if the element is focused,
    // or -1 otherwise so that only the last focused item is tabbable.
    // If using virtual focus, don't set a tabIndex at all so that VoiceOver
    // on iOS 14 doesn't try to move real DOM focus to the item anyway.
    const tabIndex = (0, _solidJs.createMemo)(()=>{
        if (shouldUseVirtualFocus() || isDisabled()) return undefined;
        return key() === manager().focusedKey() ? 0 : -1;
    });
    // data-attribute used in selection manager and keyboard delegate
    const dataKey = (0, _solidJs.createMemo)(()=>{
        return (0, _utils.access)(props.virtualized) ? undefined : key();
    });
    // Focus the associated DOM node when this item becomes the focusedKey.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ref,
        key,
        shouldUseVirtualFocus,
        ()=>manager().focusedKey(),
        ()=>manager().isFocused()
    ], ([refEl, key, shouldUseVirtualFocus, focusedKey, isFocused])=>{
        if (refEl && key === focusedKey && isFocused && !shouldUseVirtualFocus && document.activeElement !== refEl) {
            if (props.focus) props.focus();
            else (0, _utils.focusWithoutScrolling)(refEl);
        }
    }));
    return {
        isSelected,
        isDisabled,
        allowsSelection,
        tabIndex,
        dataKey,
        onPointerDown,
        onPointerUp,
        onClick,
        onKeyDown,
        onMouseDown,
        onFocus
    };
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/SelectionManager.ts
 */ /**
 * An interface for reading and updating multiple selection state.
 */ class SelectionManager {
    constructor(collection, state){
        this.collection = collection;
        this.state = state;
    }
    /** The type of selection that is allowed in the collection. */ selectionMode() {
        return this.state.selectionMode();
    }
    /** Whether the collection allows empty selection. */ disallowEmptySelection() {
        return this.state.disallowEmptySelection();
    }
    /** The selection behavior for the collection. */ selectionBehavior() {
        return this.state.selectionBehavior();
    }
    /** Sets the selection behavior for the collection. */ setSelectionBehavior(selectionBehavior) {
        this.state.setSelectionBehavior(selectionBehavior);
    }
    /** Whether the collection is currently focused. */ isFocused() {
        return this.state.isFocused();
    }
    /** Sets whether the collection is focused. */ setFocused(isFocused) {
        this.state.setFocused(isFocused);
    }
    /** The current focused key in the collection. */ focusedKey() {
        return this.state.focusedKey();
    }
    /** Sets the focused key. */ setFocusedKey(key) {
        if (key == null || this.collection().getItem(key)) this.state.setFocusedKey(key);
    }
    /** The currently selected keys in the collection. */ selectedKeys() {
        return this.state.selectedKeys();
    }
    /** Returns whether a key is selected. */ isSelected(key) {
        if (this.state.selectionMode() === "none") return false;
        const retrievedKey = this.getKey(key);
        if (retrievedKey == null) return false;
        return this.state.selectedKeys().has(retrievedKey);
    }
    /** Whether the selection is empty. */ isEmpty() {
        return this.state.selectedKeys().size === 0;
    }
    /** Whether all items in the collection are selected. */ isSelectAll() {
        if (this.isEmpty()) return false;
        const selectedKeys = this.state.selectedKeys();
        return this.getAllSelectableKeys().every((k)=>selectedKeys.has(k));
    }
    firstSelectedKey() {
        let first;
        for (const key of this.state.selectedKeys()){
            const item = this.collection().getItem(key);
            const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;
            if (!first || isItemBeforeFirst) first = item;
        }
        return first?.key;
    }
    lastSelectedKey() {
        let last;
        for (const key of this.state.selectedKeys()){
            const item = this.collection().getItem(key);
            const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;
            if (!last || isItemAfterLast) last = item;
        }
        return last?.key;
    }
    /** Extends the selection to the given key. */ extendSelection(toKey) {
        if (this.selectionMode() === "none") return;
        if (this.selectionMode() === "single") {
            this.replaceSelection(toKey);
            return;
        }
        const retrievedToKey = this.getKey(toKey);
        if (retrievedToKey == null) return;
        const selectedKeys = this.state.selectedKeys();
        const anchorKey = selectedKeys.anchorKey || retrievedToKey;
        const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);
        for (const key of this.getKeyRange(anchorKey, selectedKeys.currentKey || retrievedToKey))selection.delete(key);
        for (const key1 of this.getKeyRange(retrievedToKey, anchorKey))if (this.canSelectItem(key1)) selection.add(key1);
        this.state.setSelectedKeys(selection);
    }
    getKeyRange(from, to) {
        const fromItem = this.collection().getItem(from);
        const toItem = this.collection().getItem(to);
        if (fromItem && toItem) {
            if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) return this.getKeyRangeInternal(from, to);
            return this.getKeyRangeInternal(to, from);
        }
        return [];
    }
    getKeyRangeInternal(from, to) {
        const keys = [];
        let key = from;
        while(key != null){
            const item = this.collection().getItem(key);
            if (item && item.type === "item") keys.push(key);
            if (key === to) return keys;
            key = this.collection().getKeyAfter(key);
        }
        return [];
    }
    getKey(key) {
        const item = this.collection().getItem(key);
        if (!item) return key;
        if (!item || item.type !== "item") return null;
        return item.key;
    }
    /** Toggles whether the given key is selected. */ toggleSelection(key) {
        if (this.selectionMode() === "none") return;
        if (this.selectionMode() === "single" && !this.isSelected(key)) {
            this.replaceSelection(key);
            return;
        }
        const retrievedKey = this.getKey(key);
        if (retrievedKey == null) return;
        const keys = new Selection(this.state.selectedKeys());
        if (keys.has(retrievedKey)) keys.delete(retrievedKey);
        else if (this.canSelectItem(retrievedKey)) {
            keys.add(retrievedKey);
            keys.anchorKey = retrievedKey;
            keys.currentKey = retrievedKey;
        }
        if (this.disallowEmptySelection() && keys.size === 0) return;
        this.state.setSelectedKeys(keys);
    }
    /** Replaces the selection with only the given key. */ replaceSelection(key) {
        if (this.selectionMode() === "none") return;
        const retrievedKey = this.getKey(key);
        if (retrievedKey == null) return;
        const selection = this.canSelectItem(retrievedKey) ? new Selection([
            retrievedKey
        ], retrievedKey, retrievedKey) : new Selection();
        this.state.setSelectedKeys(selection);
    }
    /** Replaces the selection with the given keys. */ setSelectedKeys(keys) {
        if (this.selectionMode() === "none") return;
        const selection = new Selection();
        for (const key of keys){
            const retrievedKey = this.getKey(key);
            if (retrievedKey != null) {
                selection.add(retrievedKey);
                if (this.selectionMode() === "single") break;
            }
        }
        this.state.setSelectedKeys(selection);
    }
    /** Selects all items in the collection. */ selectAll() {
        if (this.selectionMode() === "multiple") this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));
    }
    /**
   * Removes all keys from the selection.
   */ clearSelection() {
        const selectedKeys = this.state.selectedKeys();
        if (!this.disallowEmptySelection() && selectedKeys.size > 0) this.state.setSelectedKeys(new Selection());
    }
    /**
   * Toggles between select all and an empty selection.
   */ toggleSelectAll() {
        if (this.isSelectAll()) this.clearSelection();
        else this.selectAll();
    }
    select(key, e) {
        if (this.selectionMode() === "none") return;
        if (this.selectionMode() === "single") {
            if (this.isSelected(key) && !this.disallowEmptySelection()) this.toggleSelection(key);
            else this.replaceSelection(key);
        } else if (this.selectionBehavior() === "toggle" || e && e.pointerType === "touch") // if touch then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
        this.toggleSelection(key);
        else this.replaceSelection(key);
    }
    /** Returns whether the current selection is equal to the given selection. */ isSelectionEqual(selection) {
        if (selection === this.state.selectedKeys()) return true;
        // Check if the set of keys match.
        const selectedKeys = this.selectedKeys();
        if (selection.size !== selectedKeys.size) return false;
        for (const key of selection){
            if (!selectedKeys.has(key)) return false;
        }
        for (const key1 of selectedKeys){
            if (!selection.has(key1)) return false;
        }
        return true;
    }
    canSelectItem(key) {
        if (this.state.selectionMode() === "none") return false;
        const item = this.collection().getItem(key);
        return item != null && !item.disabled;
    }
    isDisabled(key) {
        const item = this.collection().getItem(key);
        return !item || item.disabled;
    }
    getAllSelectableKeys() {
        const keys = [];
        const addKeys = (key)=>{
            while(key != null){
                if (this.canSelectItem(key)) {
                    const item = this.collection().getItem(key);
                    if (!item) continue;
                    if (item.type === "item") keys.push(key);
                }
                key = this.collection().getKeyAfter(key);
            }
        };
        addKeys(this.collection().getFirstKey());
        return keys;
    }
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/list/src/ListCollection.ts
 */ class ListCollection {
    keyMap = new Map();
    constructor(nodes){
        this.iterable = nodes;
        for (const node of nodes)this.keyMap.set(node.key, node);
        if (this.keyMap.size === 0) return;
        let last;
        let index = 0;
        for (const [key, node1] of this.keyMap){
            if (last) {
                last.nextKey = key;
                node1.prevKey = last.key;
            } else {
                this.firstKey = key;
                node1.prevKey = undefined;
            }
            if (node1.type === "item") node1.index = index++;
            last = node1;
            // Set nextKey as undefined since this might be the last node
            // If it isn't the last node, last.nextKey will properly set at start of new loop
            last.nextKey = undefined;
        }
        this.lastKey = last.key;
    }
    *[Symbol.iterator]() {
        yield* this.iterable;
    }
    getSize() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        return this.keyMap.get(key)?.prevKey;
    }
    getKeyAfter(key) {
        return this.keyMap.get(key)?.nextKey;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        return this.lastKey;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/list/src/useListState.ts
 */ /**
 * Provides state management for list-like components.
 * Handles building a collection of items from props, and manages multiple selection state.
 */ function createListState(props) {
    const selectionState = createMultipleSelectionState(props);
    const factory = (nodes)=>{
        return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);
    };
    const collection = createCollection({
        dataSource: ()=>(0, _utils.access)(props.dataSource),
        getKey: ()=>(0, _utils.access)(props.getKey),
        getTextValue: ()=>(0, _utils.access)(props.getTextValue),
        getDisabled: ()=>(0, _utils.access)(props.getDisabled),
        getSectionChildren: ()=>(0, _utils.access)(props.getSectionChildren),
        factory
    }, [
        ()=>props.filter
    ]);
    const selectionManager = new SelectionManager(collection, selectionState);
    // Reset focused key if that item is deleted from the collection.
    (0, _solidJs.createComputed)(()=>{
        const focusedKey = selectionState.focusedKey();
        if (focusedKey != null && !collection().getItem(focusedKey)) selectionState.setFocusedKey(undefined);
    });
    return {
        collection,
        selectionManager: ()=>selectionManager
    };
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/ListKeyboardDelegate.ts
 */ class ListKeyboardDelegate {
    constructor(collection, ref, collator){
        this.collection = collection;
        this.ref = ref;
        this.collator = collator;
    }
    getKeyBelow(key) {
        let keyAfter = this.collection().getKeyAfter(key);
        while(keyAfter != null){
            const item = this.collection().getItem(keyAfter);
            if (item && item.type === "item" && !item.disabled) return keyAfter;
            keyAfter = this.collection().getKeyAfter(keyAfter);
        }
    }
    getKeyAbove(key) {
        let keyBefore = this.collection().getKeyBefore(key);
        while(keyBefore != null){
            const item = this.collection().getItem(keyBefore);
            if (item && item.type === "item" && !item.disabled) return keyBefore;
            keyBefore = this.collection().getKeyBefore(keyBefore);
        }
    }
    getFirstKey() {
        let key = this.collection().getFirstKey();
        while(key != null){
            const item = this.collection().getItem(key);
            if (item && item.type === "item" && !item.disabled) return key;
            key = this.collection().getKeyAfter(key);
        }
    }
    getLastKey() {
        let key = this.collection().getLastKey();
        while(key != null){
            const item = this.collection().getItem(key);
            if (item && item.type === "item" && !item.disabled) return key;
            key = this.collection().getKeyBefore(key);
        }
    }
    getItem(key) {
        return this.ref?.()?.querySelector(`[data-key="${key}"]`) ?? null;
    }
    // TODO: not working correctly
    getKeyPageAbove(key) {
        const menu = this.ref?.();
        let item = this.getItem(key);
        if (!menu || !item) return;
        const pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);
        let keyAbove = key;
        while(keyAbove && item && item.offsetTop > pageY){
            keyAbove = this.getKeyAbove(keyAbove);
            item = keyAbove != null ? this.getItem(keyAbove) : null;
        }
        return keyAbove;
    }
    // TODO: not working correctly
    getKeyPageBelow(key) {
        const menu = this.ref?.();
        let item = this.getItem(key);
        if (!menu || !item) return;
        const pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);
        let keyBelow = key;
        while(keyBelow && item && item.offsetTop < pageY){
            keyBelow = this.getKeyBelow(keyBelow);
            item = keyBelow != null ? this.getItem(keyBelow) : null;
        }
        return keyBelow;
    }
    getKeyForSearch(search, fromKey) {
        const collator = this.collator?.();
        if (!collator) return;
        // Prevent from getting the same key twice
        let key = fromKey != null ? this.getKeyBelow(fromKey) : this.getFirstKey();
        while(key != null){
            const item = this.collection().getItem(key);
            if (item) {
                const substring = item.textValue.slice(0, search.length);
                if (item.textValue && collator.compare(substring, search) === 0) return key;
            }
            key = this.getKeyBelow(key);
        }
    }
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableList.ts
 */ /**
 * Handles interactions with a selectable list.
 * @param props Props for the list.
 * @param ref A ref to the list element.
 * @param scrollRef The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections. If not provided, defaults to the collection ref.
 */ function createSelectableList(props, ref, scrollRef) {
    const collator = createCollator({
        usage: "search",
        sensitivity: "base"
    });
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    const delegate = (0, _solidJs.createMemo)(()=>{
        const keyboardDelegate = (0, _utils.access)(props.keyboardDelegate);
        if (keyboardDelegate) return keyboardDelegate;
        return new ListKeyboardDelegate(props.collection, ref, collator);
    });
    return createSelectableCollection({
        selectionManager: ()=>(0, _utils.access)(props.selectionManager),
        keyboardDelegate: delegate,
        autoFocus: ()=>(0, _utils.access)(props.autoFocus),
        deferAutoFocus: ()=>(0, _utils.access)(props.deferAutoFocus),
        shouldFocusWrap: ()=>(0, _utils.access)(props.shouldFocusWrap),
        disallowEmptySelection: ()=>(0, _utils.access)(props.disallowEmptySelection),
        selectOnFocus: ()=>(0, _utils.access)(props.selectOnFocus),
        disallowTypeAhead: ()=>(0, _utils.access)(props.disallowTypeAhead),
        shouldUseVirtualFocus: ()=>(0, _utils.access)(props.shouldUseVirtualFocus),
        allowsTabNavigation: ()=>(0, _utils.access)(props.allowsTabNavigation),
        isVirtualized: ()=>(0, _utils.access)(props.isVirtualized),
        scrollToKey: (key)=>(0, _utils.access)(props.scrollToKey)?.(key)
    }, ref, scrollRef);
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-stately/list/src/useSingleSelectListState.ts
 */ /**
 * Provides state management for list-like components with single selection.
 * Handles building a collection of items from props, and manages selection state.
 */ function createSingleSelectListState(props) {
    const [selectedKey, setSelectedKey] = createControllableSignal({
        value: ()=>(0, _utils.access)(props.selectedKey),
        defaultValue: ()=>(0, _utils.access)(props.defaultSelectedKey),
        onChange: (value)=>props.onSelectionChange?.(value)
    });
    const selectedKeys = (0, _solidJs.createMemo)(()=>{
        const selection = selectedKey();
        return selection != null ? [
            selection
        ] : [];
    });
    const [, defaultCreateListStateProps] = (0, _solidJs.splitProps)(props, [
        "onSelectionChange"
    ]);
    const createListStateProps = (0, _solidJs.mergeProps)(defaultCreateListStateProps, {
        selectionMode: "single",
        disallowEmptySelection: true,
        allowDuplicateSelectionEvents: true,
        selectedKeys,
        onSelectionChange: (keys)=>{
            const key = keys.values().next().value;
            // Always fire onSelectionChange, even if the key is the same
            // as the current key (createControllableSignal does not).
            if (key === selectedKey()) props.onSelectionChange?.(key);
            setSelectedKey(key);
        }
    });
    const { collection , selectionManager  } = createListState(createListStateProps);
    const selectedItem = (0, _solidJs.createMemo)(()=>{
        const selection = selectedKey();
        return selection != null ? collection().getItem(selection) : undefined;
    });
    return {
        collection,
        selectionManager,
        selectedKey,
        setSelectedKey,
        selectedItem
    };
}
const [state, setState] = (0, _store.createStore)({
    toasts: []
});
function add(toast) {
    setState("toasts", (prev)=>[
            ...prev,
            toast
        ]);
}
function get(id) {
    return state.toasts.find((toast)=>toast.id === id);
}
function update$1(id, toast) {
    const index = state.toasts.findIndex((toast)=>toast.id === id);
    if (index != -1) setState("toasts", (prev)=>[
            ...prev.slice(0, index),
            toast,
            ...prev.slice(index + 1)
        ]);
}
function dismiss$1(id) {
    setState("toasts", (toast)=>toast.id === id, "dismiss", true);
}
function remove(id) {
    setState("toasts", (prev)=>prev.filter((toast)=>toast.id !== id));
}
function clear$1() {
    setState("toasts", []);
}
const toastStore = {
    toasts: ()=>state.toasts,
    add,
    get,
    update: update$1,
    dismiss: dismiss$1,
    remove,
    clear: clear$1
};
let toastsCounter = 0;
/** Adds a new toast to the visible toasts or queue depending on current state and limit, and return the id of the created toast. */ function show(toastComponent, options) {
    const id = toastsCounter++;
    toastStore.add({
        id,
        toastComponent,
        dismiss: false,
        update: false,
        region: options?.region
    });
    return id;
}
/** Update the toast of the given id with a new rendered component. */ function update(id, toastComponent) {
    toastStore.update(id, {
        id,
        toastComponent,
        dismiss: false,
        update: true
    });
}
/** Adds a new promise-based toast to the visible toasts or queue depending on current state and limit, and return the id of the created toast. */ function promise(promise, toastComponent, options) {
    const id = show((props)=>{
        return toastComponent({
            get toastId () {
                return props.toastId;
            },
            state: "pending"
        });
    }, options);
    ((0, _utils.isFunction)(promise) ? promise() : promise).then((data)=>update(id, (props)=>{
            return toastComponent({
                get toastId () {
                    return props.toastId;
                },
                state: "fulfilled",
                data
            });
        })).catch((error)=>update(id, (props)=>{
            return toastComponent({
                get toastId () {
                    return props.toastId;
                },
                state: "rejected",
                error
            });
        }));
    return id;
}
/** Removes toast with given id from visible toasts and queue. */ function dismiss(id) {
    toastStore.dismiss(id);
    return id;
}
/** Removes all toasts from visible toasts and queue. */ function clear() {
    toastStore.clear();
}
// User facing API.
const toaster = {
    show,
    update,
    promise,
    dismiss,
    clear
};
const CollapsibleContext = (0, _solidJs.createContext)();
function useCollapsibleContext() {
    const context = (0, _solidJs.useContext)(CollapsibleContext);
    if (context === undefined) throw new Error("[kobalte]: `useCollapsibleContext` must be used within a `Collapsible.Root` component");
    return context;
}
/**
 * Contains the content to be rendered when the collapsible is expanded.
 */ function CollapsibleContent(props) {
    let ref;
    const context = useCollapsibleContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("content")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "style"
    ]);
    const presence = createPresence(()=>context.shouldMount());
    const [height, setHeight] = (0, _solidJs.createSignal)(0);
    const [width, setWidth] = (0, _solidJs.createSignal)(0);
    // When opening we want it to immediately open to retrieve dimensions.
    // When closing we delay `isPresent` to retrieve dimensions before closing.
    const isOpen = ()=>context.isOpen() || presence.isPresent();
    let isMountAnimationPrevented = isOpen();
    let originalStyles;
    (0, _solidJs.onMount)(()=>{
        const raf = requestAnimationFrame(()=>{
            isMountAnimationPrevented = false;
        });
        (0, _solidJs.onCleanup)(()=>{
            cancelAnimationFrame(raf);
        });
    });
    (0, _solidJs.createEffect)((0, _solidJs.on)(/**
   * depends on `presence.isPresent` because it will be `false` on
   * animation end (so when close finishes). This allows us to
   * retrieve the dimensions *before* closing.
   */ [
        ()=>presence.isPresent()
    ], ()=>{
        if (!ref) return;
        originalStyles = originalStyles || {
            transitionDuration: ref.style.transitionDuration,
            animationName: ref.style.animationName
        };
        // block any animations/transitions so the element renders at its full dimensions
        ref.style.transitionDuration = "0s";
        ref.style.animationName = "none";
        // get width and height from full dimensions
        const rect = ref.getBoundingClientRect();
        setHeight(rect.height);
        setWidth(rect.width);
        // kick off any animations/transitions that were originally set up if it isn't the initial mount
        if (!isMountAnimationPrevented) {
            ref.style.transitionDuration = originalStyles.transitionDuration;
            ref.style.animationName = originalStyles.animationName;
        }
    }));
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerContentId(local.id)));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return presence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>{
                        presence.setRef(el);
                        ref = el;
                    }, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                get id () {
                    return local.id;
                },
                get style () {
                    return {
                        "--kb-collapsible-content-height": height() ? `${height()}px` : undefined,
                        "--kb-collapsible-content-width": width() ? `${width()}px` : undefined,
                        ...local.style
                    };
                }
            }, ()=>context.dataset(), others));
        }
    });
}
/**
 * An interactive component which expands/collapses a content.
 */ function CollapsibleRoot(props) {
    const defaultId = `collapsible-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "open",
        "defaultOpen",
        "onOpenChange",
        "disabled",
        "forceMount"
    ]);
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined,
            "data-disabled": local.disabled ? "" : undefined
        }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        disabled: ()=>local.disabled ?? false,
        shouldMount: ()=>local.forceMount || disclosureState.isOpen(),
        contentId,
        toggle: disclosureState.toggle,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerContentId: createRegisterId(setContentId)
    };
    return (0, _web.createComponent)(CollapsibleContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div"
            }, dataset, others));
        }
    });
}
/*!
 * Portions of this file are based on code from ariakit
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the ariakit team:
 * https://github.com/hope-ui/hope-ui/blob/54125b130195f37161dbeeea0c21dc3b198bc3ac/packages/core/src/button/is-button.ts
 */ const BUTTON_INPUT_TYPES = [
    "button",
    "color",
    "file",
    "image",
    "reset",
    "submit"
];
/**
 * Checks whether `element` is a native HTML button element.
 * @example
 * isButton(document.querySelector("button")); // true
 * isButton(document.querySelector("input[type='button']")); // true
 * isButton(document.querySelector("div")); // false
 * isButton(document.querySelector("input[type='text']")); // false
 * isButton(document.querySelector("div[role='button']")); // false
 */ function isButton(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName === "button") return true;
    if (tagName === "input" && element.type) return BUTTON_INPUT_TYPES.indexOf(element.type) !== -1;
    return false;
}
/**
 * Button enables users to trigger an action or event, such as submitting a form,
 * opening a dialog, canceling an action, or performing a delete operation.
 * This component is based on the [WAI-ARIA Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/button/)
 */ function ButtonRoot(props) {
    let ref;
    props = (0, _utils.mergeDefaultProps)({
        type: "button"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "type",
        "disabled"
    ]);
    const tagName = createTagName(()=>ref, ()=>"button");
    const isNativeButton = (0, _solidJs.createMemo)(()=>{
        const elementTagName = tagName();
        if (elementTagName == null) return false;
        return isButton({
            tagName: elementTagName,
            type: local.type
        });
    });
    const isNativeInput = (0, _solidJs.createMemo)(()=>{
        return tagName() === "input";
    });
    const isNativeLink = (0, _solidJs.createMemo)(()=>{
        return tagName() === "a" && ref?.getAttribute("href") != null;
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "button",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get type () {
            return isNativeButton() || isNativeInput() ? local.type : undefined;
        },
        get role () {
            return !isNativeButton() && !isNativeLink() ? "button" : undefined;
        },
        get tabIndex () {
            return !isNativeButton() && !isNativeLink() && !local.disabled ? 0 : undefined;
        },
        get disabled () {
            return isNativeButton() || isNativeInput() ? local.disabled : undefined;
        },
        get ["aria-disabled"] () {
            return !isNativeButton() && !isNativeInput() && local.disabled ? true : undefined;
        },
        get ["data-disabled"] () {
            return local.disabled ? "" : undefined;
        }
    }, others));
}
var index$u = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Root: ButtonRoot
});
/**
 * The button that expands/collapses the collapsible content.
 */ function CollapsibleTrigger(props) {
    const context = useCollapsibleContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.toggle();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        get disabled () {
            return context.disabled();
        },
        onClick: onClick
    }, ()=>context.dataset(), others));
}
var index$t = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Content: CollapsibleContent,
    Root: CollapsibleRoot,
    Trigger: CollapsibleTrigger
});
const AccordionItemContext = (0, _solidJs.createContext)();
function useAccordionItemContext() {
    const context = (0, _solidJs.useContext)(AccordionItemContext);
    if (context === undefined) throw new Error("[kobalte]: `useAccordionItemContext` must be used within a `Accordion.Item` component");
    return context;
}
/**
 * Contains the content to be rendered when the `Accordion.Item` is expanded.
 */ function AccordionContent(props) {
    const itemContext = useAccordionItemContext();
    const defaultId = itemContext.generateId("content");
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "style"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(itemContext.registerContentId(others.id)));
    return (0, _web.createComponent)(CollapsibleContent, (0, _web.mergeProps)({
        role: "region",
        get ["aria-labelledby"] () {
            return itemContext.triggerId();
        },
        get style () {
            return {
                "--kb-accordion-content-height": "var(--kb-collapsible-content-height)",
                "--kb-accordion-content-width": "var(--kb-collapsible-content-width)",
                ...local.style
            };
        }
    }, others));
}
/**
 * Wraps an `Accordion.Trigger`.
 * Use the `as` prop to update it to the appropriate heading level for your page.
 */ function AccordionHeader(props) {
    // `Accordion.Item` is a `Collapsible.Root`.
    const context = useCollapsibleContext();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "h3"
    }, ()=>context.dataset(), props));
}
const AccordionContext = (0, _solidJs.createContext)();
function useAccordionContext() {
    const context = (0, _solidJs.useContext)(AccordionContext);
    if (context === undefined) throw new Error("[kobalte]: `useAccordionContext` must be used within a `Accordion.Root` component");
    return context;
}
/**
 * An item of the accordion, contains all the parts of a collapsible section.
 */ function AccordionItem(props) {
    const accordionContext = useAccordionContext();
    const defaultId = `${accordionContext.generateId("item")}-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "disabled"
    ]);
    const [triggerId, setTriggerId] = (0, _solidJs.createSignal)();
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const selectionManager = ()=>accordionContext.listState().selectionManager();
    const isExpanded = ()=>{
        return selectionManager().isSelected(local.value);
    };
    const context = {
        value: ()=>local.value,
        triggerId,
        contentId,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerTriggerId: createRegisterId(setTriggerId),
        registerContentId: createRegisterId(setContentId)
    };
    return (0, _web.createComponent)(AccordionItemContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(CollapsibleRoot, (0, _web.mergeProps)({
                get open () {
                    return isExpanded();
                },
                get disabled () {
                    return local.disabled;
                }
            }, others));
        }
    });
}
const DomCollectionContext = (0, _solidJs.createContext)();
function useOptionalDomCollectionContext() {
    return (0, _solidJs.useContext)(DomCollectionContext);
}
function useDomCollectionContext() {
    const context = useOptionalDomCollectionContext();
    if (context === undefined) throw new Error("[kobalte]: `useDomCollectionContext` must be used within a `DomCollectionProvider` component");
    return context;
}
/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-state.ts
 */ function isElementPreceding(a, b) {
    return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
    const itemEl = item.ref();
    if (!itemEl) return -1;
    let length = items.length;
    if (!length) return -1;
    // Most of the time, the new item will be added at the end of the list, so we
    // do a findIndex in reverse order, instead of wasting time searching the
    // index from the beginning.
    while(length--){
        const currentItemEl = items[length]?.ref();
        if (!currentItemEl) continue;
        if (isElementPreceding(currentItemEl, itemEl)) return length + 1;
    }
    return 0;
}
function sortBasedOnDOMPosition(items) {
    const pairs = items.map((item, index)=>[
            index,
            item
        ]);
    let isOrderDifferent = false;
    pairs.sort(([indexA, a], [indexB, b])=>{
        const elementA = a.ref();
        const elementB = b.ref();
        if (elementA === elementB) return 0;
        if (!elementA || !elementB) return 0;
        // a before b
        if (isElementPreceding(elementA, elementB)) {
            if (indexA > indexB) isOrderDifferent = true;
            return -1;
        }
        // a after b
        if (indexA < indexB) isOrderDifferent = true;
        return 1;
    });
    if (isOrderDifferent) return pairs.map(([_, item])=>item);
    return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
    const sortedItems = sortBasedOnDOMPosition(items);
    if (items !== sortedItems) setItems(sortedItems);
}
function getCommonParent(items) {
    const firstItem = items[0];
    const lastItemEl = items[items.length - 1]?.ref();
    let parentEl = firstItem?.ref()?.parentElement;
    while(parentEl){
        if (lastItemEl && parentEl.contains(lastItemEl)) return parentEl;
        parentEl = parentEl.parentElement;
    }
    return (0, _utils.getDocument)(parentEl).body;
}
function createTimeoutObserver(items, setItems) {
    (0, _solidJs.createEffect)(()=>{
        const timeout = setTimeout(()=>{
            setItemsBasedOnDOMPosition(items(), setItems);
        });
        (0, _solidJs.onCleanup)(()=>clearTimeout(timeout));
    });
}
function createSortBasedOnDOMPosition(items, setItems) {
    // JSDOM doesn't support IntersectionObserver. See https://github.com/jsdom/jsdom/issues/2032
    if (typeof IntersectionObserver !== "function") {
        createTimeoutObserver(items, setItems);
        return;
    }
    let previousItems = [];
    (0, _solidJs.createEffect)(()=>{
        const callback = ()=>{
            const hasPreviousItems = !!previousItems.length;
            previousItems = items();
            // We don't want to sort items if items have been just registered.
            if (!hasPreviousItems) return;
            setItemsBasedOnDOMPosition(items(), setItems);
        };
        const root = getCommonParent(items());
        const observer = new IntersectionObserver(callback, {
            root
        });
        items().forEach((item)=>{
            const itemEl = item.ref();
            if (itemEl) observer.observe(itemEl);
        });
        (0, _solidJs.onCleanup)(()=>observer.disconnect());
    });
}
/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection.tsx
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-state.ts
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-item.ts
 */ function createDomCollection(props = {}) {
    const [items, setItems] = createControllableArraySignal({
        value: ()=>(0, _utils.access)(props.items),
        onChange: (value)=>props.onItemsChange?.(value)
    });
    createSortBasedOnDOMPosition(items, setItems);
    const registerItem = (item)=>{
        setItems((prevItems)=>{
            // Finds the item group based on the DOM hierarchy
            const index = findDOMIndex(prevItems, item);
            return (0, _utils.addItemToArray)(prevItems, item, index);
        });
        return ()=>{
            setItems((prevItems)=>{
                const nextItems = prevItems.filter((prevItem)=>prevItem.ref() !== item.ref());
                if (prevItems.length === nextItems.length) // The item isn't registered, so do nothing
                return prevItems;
                return nextItems;
            });
        };
    };
    const DomCollectionProvider = (props)=>{
        return (0, _solidJs.createComponent)(DomCollectionContext.Provider, {
            value: {
                registerItem
            },
            get children () {
                return props.children;
            }
        });
    };
    return {
        DomCollectionProvider
    };
}
function createDomCollectionItem(props) {
    const context = useDomCollectionContext();
    props = (0, _utils.mergeDefaultProps)({
        shouldRegisterItem: true
    }, props);
    (0, _solidJs.createEffect)(()=>{
        if (!props.shouldRegisterItem) return;
        const unregister = context.registerItem(props.getItem());
        (0, _solidJs.onCleanup)(unregister);
    });
}
/**
 * A vertically stacked set of interactive headings that each reveal an associated section of content.
 */ function AccordionRoot(props) {
    let ref;
    const defaultId = `accordion-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        multiple: false,
        collapsible: false,
        shouldFocusWrap: true
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "value",
        "defaultValue",
        "onChange",
        "multiple",
        "collapsible",
        "shouldFocusWrap",
        "onKeyDown",
        "onMouseDown",
        "onFocusIn",
        "onFocusOut"
    ]);
    const [items, setItems] = (0, _solidJs.createSignal)([]);
    const { DomCollectionProvider  } = createDomCollection({
        items,
        onItemsChange: setItems
    });
    const listState = createListState({
        selectedKeys: ()=>local.value,
        defaultSelectedKeys: ()=>local.defaultValue,
        onSelectionChange: (value)=>local.onChange?.(Array.from(value)),
        disallowEmptySelection: ()=>!local.multiple && !local.collapsible,
        selectionMode: ()=>local.multiple ? "multiple" : "single",
        dataSource: items
    });
    const selectableList = createSelectableList({
        selectionManager: ()=>listState.selectionManager(),
        collection: ()=>listState.collection(),
        disallowEmptySelection: ()=>listState.selectionManager().disallowEmptySelection(),
        shouldFocusWrap: ()=>local.shouldFocusWrap,
        disallowTypeAhead: true,
        allowsTabNavigation: true
    }, ()=>ref);
    const context = {
        listState: ()=>listState,
        generateId: (0, _utils.createGenerateId)(()=>others.id)
    };
    return (0, _web.createComponent)(DomCollectionProvider, {
        get children () {
            return (0, _web.createComponent)(AccordionContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                        as: "div",
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        get onKeyDown () {
                            return (0, _utils.composeEventHandlers)([
                                local.onKeyDown,
                                selectableList.onKeyDown
                            ]);
                        },
                        get onMouseDown () {
                            return (0, _utils.composeEventHandlers)([
                                local.onMouseDown,
                                selectableList.onMouseDown
                            ]);
                        },
                        get onFocusIn () {
                            return (0, _utils.composeEventHandlers)([
                                local.onFocusIn,
                                selectableList.onFocusIn
                            ]);
                        },
                        get onFocusOut () {
                            return (0, _utils.composeEventHandlers)([
                                local.onFocusOut,
                                selectableList.onFocusOut
                            ]);
                        }
                    }, others));
                }
            });
        }
    });
}
/**
 * Toggles the collapsed state of its associated item. It should be nested inside an `Accordion.Header`.
 */ function AccordionTrigger(props) {
    let ref;
    const accordionContext = useAccordionContext();
    const itemContext = useAccordionItemContext();
    const collapsibleContext = useCollapsibleContext();
    const defaultId = itemContext.generateId("trigger");
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onPointerDown",
        "onPointerUp",
        "onClick",
        "onKeyDown",
        "onMouseDown",
        "onFocus"
    ]);
    createDomCollectionItem({
        getItem: ()=>({
                ref: ()=>ref,
                type: "item",
                key: itemContext.value(),
                textValue: "",
                // not applicable here
                disabled: collapsibleContext.disabled()
            })
    });
    const selectableItem = createSelectableItem({
        key: ()=>itemContext.value(),
        selectionManager: ()=>accordionContext.listState().selectionManager(),
        disabled: ()=>collapsibleContext.disabled(),
        shouldSelectOnPressUp: true
    }, ()=>ref);
    const onKeyDown = (e)=>{
        // Prevent `Enter` and `Space` default behavior which fires a click event when using a <button>.
        if ([
            "Enter",
            " "
        ].includes(e.key)) e.preventDefault();
        (0, _utils.callHandler)(e, local.onKeyDown);
        (0, _utils.callHandler)(e, selectableItem.onKeyDown);
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(itemContext.registerTriggerId(others.id)));
    return (0, _web.createComponent)(CollapsibleTrigger, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get ["data-key"] () {
            return selectableItem.dataKey();
        },
        get onPointerDown () {
            return (0, _utils.composeEventHandlers)([
                local.onPointerDown,
                selectableItem.onPointerDown
            ]);
        },
        get onPointerUp () {
            return (0, _utils.composeEventHandlers)([
                local.onPointerUp,
                selectableItem.onPointerUp
            ]);
        },
        get onClick () {
            return (0, _utils.composeEventHandlers)([
                local.onClick,
                selectableItem.onClick
            ]);
        },
        onKeyDown: onKeyDown,
        get onMouseDown () {
            return (0, _utils.composeEventHandlers)([
                local.onMouseDown,
                selectableItem.onMouseDown
            ]);
        },
        get onFocus () {
            return (0, _utils.composeEventHandlers)([
                local.onFocus,
                selectableItem.onFocus
            ]);
        }
    }, others));
}
var index$s = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Content: AccordionContent,
    Header: AccordionHeader,
    Item: AccordionItem,
    Root: AccordionRoot,
    Trigger: AccordionTrigger
});
/**
 * Alert displays a brief, important message
 * in a way that attracts the user's attention without interrupting the user's task.
 */ function AlertRoot(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        role: "alert"
    }, props));
}
var index$r = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Root: AlertRoot
});
const DialogContext = (0, _solidJs.createContext)();
function useDialogContext() {
    const context = (0, _solidJs.useContext)(DialogContext);
    if (context === undefined) throw new Error("[kobalte]: `useDialogContext` must be used within a `Dialog` component");
    return context;
}
/**
 * The button that closes the dialog.
 */ function DialogCloseButton(props) {
    const context = useDialogContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "aria-label",
        "onClick"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.close();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get ["aria-label"] () {
            return local["aria-label"] || context.translations().dismiss;
        },
        onClick: onClick
    }, others));
}
const DismissableLayerContext = (0, _solidJs.createContext)();
function useOptionalDismissableLayerContext() {
    return (0, _solidJs.useContext)(DismissableLayerContext);
}
function DismissableLayer(props) {
    let ref;
    const parentContext = useOptionalDismissableLayerContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "disableOutsidePointerEvents",
        "excludedElements",
        "onEscapeKeyDown",
        "onPointerDownOutside",
        "onFocusOutside",
        "onInteractOutside",
        "onDismiss",
        "bypassTopMostLayerCheck"
    ]);
    const nestedLayers = new Set([]);
    const registerNestedLayer = (element)=>{
        nestedLayers.add(element);
        const parentUnregister = parentContext?.registerNestedLayer(element);
        return ()=>{
            nestedLayers.delete(element);
            parentUnregister?.();
        };
    };
    const shouldExcludeElement = (element)=>{
        if (!ref) return false;
        return local.excludedElements?.some((node)=>(0, _utils.contains)(node(), element)) || [
            ...nestedLayers
        ].some((layer)=>(0, _utils.contains)(layer, element));
    };
    const onPointerDownOutside = (e)=>{
        if (!ref || layerStack.isBelowPointerBlockingLayer(ref)) return;
        if (!local.bypassTopMostLayerCheck && !layerStack.isTopMostLayer(ref)) return;
        local.onPointerDownOutside?.(e);
        local.onInteractOutside?.(e);
        if (!e.defaultPrevented) local.onDismiss?.();
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        local.onInteractOutside?.(e);
        if (!e.defaultPrevented) local.onDismiss?.();
    };
    createInteractOutside({
        shouldExcludeElement,
        onPointerDownOutside,
        onFocusOutside
    }, ()=>ref);
    createEscapeKeyDown({
        ownerDocument: ()=>(0, _utils.getDocument)(ref),
        onEscapeKeyDown: (e)=>{
            if (!ref || !layerStack.isTopMostLayer(ref)) return;
            local.onEscapeKeyDown?.(e);
            if (!e.defaultPrevented && local.onDismiss) {
                e.preventDefault();
                local.onDismiss();
            }
        }
    });
    (0, _solidJs.onMount)(()=>{
        if (!ref) return;
        layerStack.addLayer({
            node: ref,
            isPointerBlocking: local.disableOutsidePointerEvents,
            dismiss: local.onDismiss
        });
        const unregisterFromParentLayer = parentContext?.registerNestedLayer(ref);
        layerStack.assignPointerEventToLayers();
        layerStack.disableBodyPointerEvents(ref);
        (0, _solidJs.onCleanup)(()=>{
            if (!ref) return;
            layerStack.removeLayer(ref);
            unregisterFromParentLayer?.();
            // Re-assign pointer event to remaining layers.
            layerStack.assignPointerEventToLayers();
            layerStack.restoreBodyPointerEvents(ref);
        });
    });
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>ref,
        ()=>local.disableOutsidePointerEvents
    ], ([ref, disableOutsidePointerEvents])=>{
        if (!ref) return;
        const layer = layerStack.find(ref);
        if (layer && layer.isPointerBlocking !== disableOutsidePointerEvents) {
            // Keep layer in sync with the prop.
            layer.isPointerBlocking = disableOutsidePointerEvents;
            // Update layers pointer-events since this layer "isPointerBlocking" has changed.
            layerStack.assignPointerEventToLayers();
        }
        if (disableOutsidePointerEvents) layerStack.disableBodyPointerEvents(ref);
        (0, _solidJs.onCleanup)(()=>{
            layerStack.restoreBodyPointerEvents(ref);
        });
    }, {
        defer: true
    }));
    const context = {
        registerNestedLayer
    };
    return (0, _web.createComponent)(DismissableLayerContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                }
            }, others));
        }
    });
}
/**
 * Contains the content to be rendered when the dialog is open.
 */ function DialogContent(props) {
    let ref;
    const context = useDialogContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("content")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onOpenAutoFocus",
        "onCloseAutoFocus",
        "onPointerDownOutside",
        "onFocusOutside",
        "onInteractOutside"
    ]);
    let hasInteractedOutside = false;
    let hasPointerDownOutside = false;
    const onPointerDownOutside = (e)=>{
        local.onPointerDownOutside?.(e);
        // If the event is a right-click, we shouldn't close because
        // it is effectively as if we right-clicked the `Overlay`.
        if (context.modal() && e.detail.isContextMenu) e.preventDefault();
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.modal()) e.preventDefault();
    };
    const onInteractOutside = (e)=>{
        local.onInteractOutside?.(e);
        if (context.modal()) return;
        // Non-modal behavior below
        if (!e.defaultPrevented) {
            hasInteractedOutside = true;
            if (e.detail.originalEvent.type === "pointerdown") hasPointerDownOutside = true;
        }
        // Prevent dismissing when clicking the trigger.
        // As the trigger is already setup to close, without doing so would
        // cause it to close and immediately open.
        if ((0, _utils.contains)(context.triggerRef(), e.target)) e.preventDefault();
        // On Safari if the trigger is inside a container with tabIndex={0}, when clicked
        // we will get the pointer down outside event on the trigger, but then a subsequent
        // focus outside event on the container, we ignore any focus outside event when we've
        // already had a pointer down outside event.
        if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) e.preventDefault();
    };
    const onCloseAutoFocus = (e)=>{
        local.onCloseAutoFocus?.(e);
        if (context.modal()) {
            e.preventDefault();
            (0, _utils.focusWithoutScrolling)(context.triggerRef());
        } else {
            if (!e.defaultPrevented) {
                if (!hasInteractedOutside) (0, _utils.focusWithoutScrolling)(context.triggerRef());
                // Always prevent autofocus because we either focus manually or want user agent focus
                e.preventDefault();
            }
            hasInteractedOutside = false;
            hasPointerDownOutside = false;
        }
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: ()=>!(context.isOpen() && context.modal()),
        targets: ()=>ref ? [
                ref
            ] : []
    });
    createPreventScroll({
        ownerRef: ()=>ref,
        isDisabled: ()=>!(context.isOpen() && context.preventScroll())
    });
    createFocusScope({
        trapFocus: ()=>context.isOpen() && context.modal(),
        onMountAutoFocus: local.onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus
    }, ()=>ref);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerContentId(others.id)));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>{
                        context.contentPresence.setRef(el);
                        ref = el;
                    }, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                role: "dialog",
                tabIndex: -1,
                get disableOutsidePointerEvents () {
                    return (0, _web.memo)(()=>!!context.modal())() && context.isOpen();
                },
                get excludedElements () {
                    return [
                        context.triggerRef
                    ];
                },
                get ["aria-labelledby"] () {
                    return context.titleId();
                },
                get ["aria-describedby"] () {
                    return context.descriptionId();
                },
                get ["data-expanded"] () {
                    return context.isOpen() ? "" : undefined;
                },
                get ["data-closed"] () {
                    return !context.isOpen() ? "" : undefined;
                },
                onPointerDownOutside: onPointerDownOutside,
                onFocusOutside: onFocusOutside,
                onInteractOutside: onInteractOutside,
                get onDismiss () {
                    return context.close;
                }
            }, others));
        }
    });
}
/**
 * An optional accessible description to be announced when the dialog is open.
 */ function DialogDescription(props) {
    const context = useDialogContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescriptionId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "p",
        get id () {
            return local.id;
        }
    }, others));
}
/**
 * A layer that covers the inert portion of the view when the dialog is open.
 */ function DialogOverlay(props) {
    const context = useDialogContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onPointerDown"
    ]);
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846
        if (e.target === e.currentTarget) e.preventDefault();
    };
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.overlayPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)(context.overlayPresence.setRef, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                get style () {
                    return {
                        "pointer-events": "auto",
                        ...local.style
                    };
                },
                get ["data-expanded"] () {
                    return context.isOpen() ? "" : undefined;
                },
                get ["data-closed"] () {
                    return !context.isOpen() ? "" : undefined;
                },
                onPointerDown: onPointerDown
            }, others));
        }
    });
}
/**
 * Portals its children into the `body` when the dialog is open.
 */ function DialogPortal(props) {
    const context = useDialogContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent() || context.overlayPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
const DIALOG_INTL_TRANSLATIONS = {
    // `aria-label` of Dialog.CloseButton.
    dismiss: "Dismiss"
};
/**
 * A dialog is a window overlaid on either the primary window or another dialog window.
 */ function DialogRoot(props) {
    const defaultId = `dialog-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        modal: true,
        translations: DIALOG_INTL_TRANSLATIONS
    }, props);
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const [titleId, setTitleId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const disclosureState = createDisclosureState({
        open: ()=>props.open,
        defaultOpen: ()=>props.defaultOpen,
        onOpenChange: (isOpen)=>props.onOpenChange?.(isOpen)
    });
    const shouldMount = ()=>props.forceMount || disclosureState.isOpen();
    const overlayPresence = createPresence(shouldMount);
    const contentPresence = createPresence(shouldMount);
    const context = {
        translations: ()=>props.translations ?? DIALOG_INTL_TRANSLATIONS,
        isOpen: disclosureState.isOpen,
        modal: ()=>props.modal ?? true,
        preventScroll: ()=>props.preventScroll ?? context.modal(),
        contentId,
        titleId,
        descriptionId,
        triggerRef,
        overlayPresence,
        contentPresence,
        close: disclosureState.close,
        toggle: disclosureState.toggle,
        setTriggerRef,
        generateId: (0, _utils.createGenerateId)(()=>props.id),
        registerContentId: createRegisterId(setContentId),
        registerTitleId: createRegisterId(setTitleId),
        registerDescriptionId: createRegisterId(setDescriptionId)
    };
    return (0, _web.createComponent)(DialogContext.Provider, {
        value: context,
        get children () {
            return props.children;
        }
    });
}
/**
 * An accessible title to be announced when the dialog is open.
 */ function DialogTitle(props) {
    const context = useDialogContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("title")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTitleId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "h2",
        get id () {
            return local.id;
        }
    }, others));
}
/**
 * The button that opens the dialog.
 */ function DialogTrigger(props) {
    const context = useDialogContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onClick"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.toggle();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        "aria-haspopup": "dialog",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        get ["data-expanded"] () {
            return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"] () {
            return !context.isOpen() ? "" : undefined;
        },
        onClick: onClick
    }, others));
}
var index$q = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    CloseButton: DialogCloseButton,
    Content: DialogContent,
    Description: DialogDescription,
    Overlay: DialogOverlay,
    Portal: DialogPortal,
    Root: DialogRoot,
    Title: DialogTitle,
    Trigger: DialogTrigger
});
/**
 * Overrides the regular `Dialog.Content` with role="alertdialog" to interrupt the user.
 */ function AlertDialogContent(props) {
    return (0, _web.createComponent)(DialogContent, (0, _web.mergeProps)({
        role: "alertdialog"
    }, props));
}
var index$p = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    CloseButton: DialogCloseButton,
    Content: AlertDialogContent,
    Description: DialogDescription,
    Overlay: DialogOverlay,
    Portal: DialogPortal,
    Root: DialogRoot,
    Title: DialogTitle,
    Trigger: DialogTrigger
});
/**
 * Link allows a user to navigate to another page or resource within a web page or application.
 */ function LinkRoot(props) {
    let ref;
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "type",
        "href",
        "disabled"
    ]);
    const tagName = createTagName(()=>ref, ()=>"a");
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "a",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get role () {
            return tagName() !== "a" || local.disabled ? "link" : undefined;
        },
        get tabIndex () {
            return tagName() !== "a" && !local.disabled ? 0 : undefined;
        },
        get href () {
            return !local.disabled ? local.href : undefined;
        },
        get ["aria-disabled"] () {
            return local.disabled ? true : undefined;
        },
        get ["data-disabled"] () {
            return local.disabled ? "" : undefined;
        }
    }, others));
}
var index$o = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Root: LinkRoot
});
/**
 * The breadcrumbs link.
 */ function BreadcrumbsLink(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "current",
        "disabled",
        "aria-current"
    ]);
    const ariaCurrent = ()=>{
        if (!local.current) return undefined;
        return local["aria-current"] || "page";
    };
    return (0, _web.createComponent)(LinkRoot, (0, _web.mergeProps)({
        get disabled () {
            return local.disabled || local.current;
        },
        get ["aria-current"] () {
            return ariaCurrent();
        },
        get ["data-current"] () {
            return local.current ? "" : undefined;
        }
    }, others));
}
const BREADCRUMBS_INTL_TRANSLATIONS = {
    // `aria-label` of the navigation.
    breadcrumbs: "Breadcrumbs"
};
const BreadcrumbsContext = (0, _solidJs.createContext)();
function useBreadcrumbsContext() {
    const context = (0, _solidJs.useContext)(BreadcrumbsContext);
    if (context === undefined) throw new Error("[kobalte]: `useBreadcrumbsContext` must be used within a `Breadcrumbs.Root` component");
    return context;
}
/**
 * Breadcrumbs show hierarchy and navigational context for a user’s location within an application.
 */ function BreadcrumbsRoot(props) {
    props = (0, _utils.mergeDefaultProps)({
        separator: "/",
        translations: BREADCRUMBS_INTL_TRANSLATIONS
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "separator",
        "translations"
    ]);
    const context = {
        separator: ()=>local.separator
    };
    return (0, _web.createComponent)(BreadcrumbsContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "nav",
                get ["aria-label"] () {
                    return local.translations?.breadcrumbs;
                }
            }, others));
        }
    });
}
/**
 * The visual separator between each breadcrumb items.
 * It will not be visible by screen readers.
 */ function BreadcrumbsSeparator(props) {
    const context = useBreadcrumbsContext();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "span",
        get children () {
            return context.separator();
        },
        "aria-hidden": "true"
    }, props));
}
var index$n = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Link: BreadcrumbsLink,
    Root: BreadcrumbsRoot,
    Separator: BreadcrumbsSeparator
});
/**
 * Contains the calendar grids.
 */ function CalendarBody(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div"
    }, props));
}
const CalendarContext = (0, _solidJs.createContext)();
function useCalendarContext() {
    const context = (0, _solidJs.useContext)(CalendarContext);
    if (context === undefined) throw new Error("[kobalte]: `useCalendarContext` must be used within a `Calendar` component");
    return context;
}
const CalendarGridContext = (0, _solidJs.createContext)();
function useCalendarGridContext() {
    const context = (0, _solidJs.useContext)(CalendarGridContext);
    if (context === undefined) throw new Error("[kobalte]: `useCalendarGridContext` must be used within a `Calendar.Grid` component");
    return context;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/0a1d0cd4e1b2f77eed7c0ea08fce8a04f8de6921/packages/@react-stately/calendar/src/utils.ts
 *
 * Portions of this file are based on code from zag, based on code from react-spectrum.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/main/packages/utilities/date-utils/src/pagination.ts
 */ /* -----------------------------------------------------------------------------
 * Constrain a date to a range
 * -----------------------------------------------------------------------------*/ function constrainStart(date, aligned, duration, locale, min, max) {
    if (min && date.compare(min) >= 0) aligned = (0, _date.maxDate)(aligned, alignStart((0, _date.toCalendarDate)(min), duration, locale));
    if (max && date.compare(max) <= 0) aligned = (0, _date.minDate)(aligned, alignEnd((0, _date.toCalendarDate)(max), duration, locale));
    return aligned;
}
function constrainValue(date, min, max) {
    if (min) date = (0, _date.maxDate)(date, (0, _date.toCalendarDate)(min));
    if (max) date = (0, _date.minDate)(date, (0, _date.toCalendarDate)(max));
    return date;
}
/* -----------------------------------------------------------------------------
 * Align date to start, center, or end of a duration
 * -----------------------------------------------------------------------------*/ function alignStart(date, duration, locale, min, max) {
    // align to the start of the largest unit
    let aligned = date;
    if (duration.years) aligned = (0, _date.startOfYear)(date);
    else if (duration.months) aligned = (0, _date.startOfMonth)(date);
    else if (duration.weeks) aligned = (0, _date.startOfWeek)(date, locale);
    return constrainStart(date, aligned, duration, locale, min, max);
}
function alignCenter(date, duration, locale, min, max) {
    const halfDuration = {};
    for(const key in duration){
        // @ts-ignore
        halfDuration[key] = Math.floor(duration[key] / 2);
        // @ts-ignore
        if (halfDuration[key] > 0 && duration[key] % 2 === 0) // @ts-ignore
        halfDuration[key]--;
    }
    const aligned = alignStart(date, duration, locale).subtract(halfDuration);
    return constrainStart(date, aligned, duration, locale, min, max);
}
function alignEnd(date, duration, locale, min, max) {
    const d = {
        ...duration
    };
    // subtract 1 from the smallest unit
    if (d.days) d.days--;
    else if (d.weeks) d.weeks--;
    else if (d.months) d.months--;
    else if (d.years) d.years--;
    const aligned = alignStart(date, duration, locale).subtract(d);
    return constrainStart(date, aligned, duration, locale, min, max);
}
function alignDate(date, alignment, duration, locale, min, max) {
    switch(alignment){
        case "start":
            return alignStart(date, duration, locale, min, max);
        case "end":
            return alignEnd(date, duration, locale, min, max);
        case "center":
        default:
            return alignCenter(date, duration, locale, min, max);
    }
}
/* -----------------------------------------------------------------------------
 * Assertions
 * -----------------------------------------------------------------------------*/ function isDateInvalid(date, minValue, maxValue) {
    return date != null && (minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0);
}
function isPreviousVisibleRangeInvalid(startDate, min, max) {
    const prevDate = startDate.subtract({
        days: 1
    });
    return (0, _date.isSameDay)(prevDate, startDate) || isDateInvalid(prevDate, min, max);
}
function isNextVisibleRangeInvalid(endDate, min, max) {
    // Adding may return the same date if we reached the end of time
    // according to the calendar system (e.g. 9999-12-31).
    const nextDate = endDate.add({
        days: 1
    });
    return (0, _date.isSameDay)(nextDate, endDate) || isDateInvalid(nextDate, min, max);
}
/* -----------------------------------------------------------------------------
 * Getters
 * -----------------------------------------------------------------------------*/ function getEndDate(startDate, duration) {
    const d = {
        ...duration
    };
    if (d.days) d.days--;
    else d.days = -1;
    return startDate.add(d);
}
function getAdjustedDateFn(visibleDuration, locale, min, max) {
    return function getDate(options) {
        const { startDate , focusedDate  } = options;
        const endDate = getEndDate(startDate, visibleDuration);
        // If the focused date was moved to an invalid value, it can't be focused, so constrain it.
        if (isDateInvalid(focusedDate, min, max)) return {
            startDate,
            endDate,
            focusedDate: constrainValue(focusedDate, min, max)
        };
        if (focusedDate.compare(startDate) < 0) return {
            startDate: alignEnd(focusedDate, visibleDuration, locale, min, max),
            endDate,
            focusedDate: constrainValue(focusedDate, min, max)
        };
        if (focusedDate.compare(endDate) > 0) return {
            startDate: alignStart(focusedDate, visibleDuration, locale, min, max),
            endDate,
            focusedDate: constrainValue(focusedDate, min, max)
        };
        return {
            startDate,
            endDate,
            focusedDate: constrainValue(focusedDate, min, max)
        };
    };
}
function getUnitDuration(duration) {
    const unit = {
        ...duration
    };
    for(const key in unit)// @ts-ignore
    unit[key] = 1;
    return unit;
}
function getNextUnavailableDate(anchorDate, start, end, isDateUnavailableFn, dir) {
    let nextDate = anchorDate.add({
        days: dir
    });
    while((dir < 0 ? nextDate.compare(start) >= 0 : nextDate.compare(end) <= 0) && !isDateUnavailableFn(nextDate))nextDate = nextDate.add({
        days: dir
    });
    if (isDateUnavailableFn(nextDate)) return nextDate.add({
        days: -dir
    });
    return undefined;
}
function getPreviousAvailableDate(date, min, isDateUnavailable) {
    if (!isDateUnavailable) return date;
    while(date.compare(min) >= 0 && isDateUnavailable(date))date = date.subtract({
        days: 1
    });
    if (date.compare(min) >= 0) return date;
}
function getEraFormat(date) {
    return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : undefined;
}
/** Return the first value of the selection depending on the selection mode. */ function getFirstValueOfSelection(selectionMode, value) {
    let firstValue;
    if (selectionMode === "single") firstValue = asSingleValue(value);
    else if (selectionMode === "multiple") firstValue = asArrayValue(value)?.[0];
    else if (selectionMode === "range") {
        const { start  } = asRangeValue(value) ?? {};
        firstValue = start;
    }
    return firstValue;
}
/** Return an array of values for the selection depending on the selection mode. */ function getArrayValueOfSelection(selectionMode, value) {
    let values = [];
    if (selectionMode === "single") values = [
        asSingleValue(value)
    ];
    else if (selectionMode === "multiple") values = asArrayValue(value) ?? [];
    else if (selectionMode === "range") {
        const { start , end  } = asRangeValue(value) ?? {};
        values = [
            start,
            end
        ];
    }
    return values.filter(Boolean);
}
/* -----------------------------------------------------------------------------
 * Formatters
 * -----------------------------------------------------------------------------*/ function formatRange(dateFormatter, translations, start, end, timeZone) {
    const parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));
    // Find the separator between the start and end date. This is determined
    // by finding the last shared literal before the end range.
    let separatorIndex = -1;
    for(let i = 0; i < parts.length; i++){
        const part = parts[i];
        if (part.source === "shared" && part.type === "literal") separatorIndex = i;
        else if (part.source === "endRange") break;
    }
    // Now we can combine the parts into start and end strings.
    let startValue = "";
    let endValue = "";
    for(let i1 = 0; i1 < parts.length; i1++){
        if (i1 < separatorIndex) startValue += parts[i1].value;
        else if (i1 > separatorIndex) endValue += parts[i1].value;
    }
    return translations.dateRange(startValue, endValue);
}
/* -----------------------------------------------------------------------------
 * Descriptions
 * -----------------------------------------------------------------------------*/ function getSelectedDateDescription(translations, value, timeZone) {
    const dateFormatter = createDateFormatter(()=>({
            weekday: "long",
            month: "long",
            year: "numeric",
            day: "numeric",
            era: getEraFormat(value),
            timeZone: timeZone
        }));
    return translations.selectedDateDescription(dateFormatter().format(value.toDate(timeZone)));
}
function getSelectedDateRangeDescription(translations, highlightedRange, anchorDate, timeZone) {
    const start = highlightedRange.start;
    const end = highlightedRange.end;
    if (!anchorDate && start && end) {
        const dateFormatter = createDateFormatter(()=>({
                weekday: "long",
                month: "long",
                year: "numeric",
                day: "numeric",
                era: getEraFormat(start) || getEraFormat(end),
                timeZone: timeZone
            }));
        // Use a single date message if the start and end dates are the same day,
        // otherwise include both dates.
        if ((0, _date.isSameDay)(start, end)) {
            const date = dateFormatter().format(start.toDate(timeZone));
            return translations.selectedDateDescription(date);
        } else {
            const dateRange = formatRange(dateFormatter(), translations, start, end, timeZone);
            return translations.selectedRangeDescription(dateRange);
        }
    }
    // No message if currently selecting a range, or there is nothing highlighted.
    return "";
}
function getVisibleRangeDescription(translations, startDate, endDate, timeZone, isAria) {
    const era = getEraFormat(startDate) || getEraFormat(endDate);
    const monthFormatter = createDateFormatter(()=>({
            month: "long",
            year: "numeric",
            era,
            calendar: startDate.calendar.identifier,
            timeZone
        }));
    const dateFormatter = createDateFormatter(()=>({
            month: "long",
            year: "numeric",
            day: "numeric",
            era,
            calendar: startDate.calendar.identifier,
            timeZone
        }));
    // Special case for month granularity. Format as a single month if only a
    // single month is visible, otherwise format as a range of months.
    if ((0, _date.isSameDay)(startDate, (0, _date.startOfMonth)(startDate))) {
        if ((0, _date.isSameDay)(endDate, (0, _date.endOfMonth)(startDate))) return monthFormatter().format(startDate.toDate(timeZone));
        else if ((0, _date.isSameDay)(endDate, (0, _date.endOfMonth)(endDate))) {
            if (isAria) return formatRange(monthFormatter(), translations, startDate, endDate, timeZone);
            return monthFormatter().formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));
        }
    }
    if (isAria) return formatRange(dateFormatter(), translations, startDate, endDate, timeZone);
    return dateFormatter().formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));
}
/* -----------------------------------------------------------------------------
 *  Pagination
 * -----------------------------------------------------------------------------*/ function getNextPage(focusedDate, startDate, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    const start = startDate.add(visibleDuration);
    return adjust({
        focusedDate: focusedDate.add(visibleDuration),
        startDate: alignStart(constrainStart(focusedDate, start, visibleDuration, locale, min, max), visibleDuration, locale)
    });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    const start = startDate.subtract(visibleDuration);
    return adjust({
        focusedDate: focusedDate.subtract(visibleDuration),
        startDate: alignStart(constrainStart(focusedDate, start, visibleDuration, locale, min, max), visibleDuration, locale)
    });
}
function getNextRow(focusedDate, startDate, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    if (visibleDuration.days) return getNextPage(focusedDate, startDate, visibleDuration, locale, min, max);
    if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) return adjust({
        focusedDate: focusedDate.add({
            weeks: 1
        }),
        startDate
    });
}
function getPreviousRow(focusedDate, startDate, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    if (visibleDuration.days) return getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max);
    if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) return adjust({
        focusedDate: focusedDate.subtract({
            weeks: 1
        }),
        startDate
    });
}
function getSectionStart(focusedDate, startDate, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    if (visibleDuration.days) return adjust({
        focusedDate: startDate,
        startDate
    });
    if (visibleDuration.weeks) return adjust({
        focusedDate: (0, _date.startOfWeek)(focusedDate, locale),
        startDate
    });
    if (visibleDuration.months || visibleDuration.years) return adjust({
        focusedDate: (0, _date.startOfMonth)(focusedDate),
        startDate
    });
}
function getSectionEnd(focusedDate, startDate, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    const endDate = getEndDate(startDate, visibleDuration);
    if (visibleDuration.days) return adjust({
        focusedDate: endDate,
        startDate
    });
    if (visibleDuration.weeks) return adjust({
        //@ts-expect-error - endOfWeek is loosely typed
        focusedDate: (0, _date.endOfWeek)(focusedDate, locale),
        startDate
    });
    if (visibleDuration.months || visibleDuration.years) return adjust({
        focusedDate: (0, _date.endOfMonth)(focusedDate),
        startDate
    });
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    if (!larger && !visibleDuration.days) return adjust({
        focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
        startDate
    });
    if (visibleDuration.days) return getNextPage(focusedDate, startDate, visibleDuration, locale, min, max);
    if (visibleDuration.weeks) return adjust({
        focusedDate: focusedDate.add({
            months: 1
        }),
        startDate
    });
    if (visibleDuration.months || visibleDuration.years) return adjust({
        focusedDate: focusedDate.add({
            years: 1
        }),
        startDate
    });
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, min, max) {
    const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
    if (!larger && !visibleDuration.days) return adjust({
        focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
        startDate
    });
    if (visibleDuration.days) return getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max);
    if (visibleDuration.weeks) return adjust({
        focusedDate: focusedDate.subtract({
            months: 1
        }),
        startDate
    });
    if (visibleDuration.months || visibleDuration.years) return adjust({
        focusedDate: focusedDate.subtract({
            years: 1
        }),
        startDate
    });
}
/* -----------------------------------------------------------------------------
 *  Type narrowing
 * -----------------------------------------------------------------------------*/ /** Narrow the type of `value` to `DateValue`. */ function asSingleValue(value) {
    return value;
}
/** Narrow the type of `value` to `DateValue[]`. */ function asArrayValue(value) {
    return value;
}
/** Narrow the type of `value` to `RangeValue<DateValue>`. */ function asRangeValue(value) {
    return value;
}
/* -----------------------------------------------------------------------------
 *  Misc.
 * -----------------------------------------------------------------------------*/ function sortDates(values) {
    return values.sort((a, b)=>a.compare(b));
}
function makeCalendarDateRange(start, end) {
    if (!start || !end) return undefined;
    if (end.compare(start) < 0) [start, end] = [
        end,
        start
    ];
    return {
        start: (0, _date.toCalendarDate)(start),
        end: (0, _date.toCalendarDate)(end)
    };
}
/**
 * A calendar grid displays a single grid of days within a calendar or range calendar which
 * can be keyboard navigated and selected by the user.
 */ function CalendarGrid(props) {
    const rootContext = useCalendarContext();
    props = (0, _utils.mergeDefaultProps)({
        weekDayFormat: "short"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "offset",
        "weekDayFormat",
        "onKeyDown",
        "onFocusIn",
        "onFocusOut",
        "aria-label"
    ]);
    const startDate = (0, _solidJs.createMemo)(()=>{
        if (local.offset) return rootContext.startDate().add(local.offset);
        return rootContext.startDate();
    });
    const endDate = (0, _solidJs.createMemo)(()=>(0, _date.endOfMonth)(startDate()));
    const dayFormatter = createDateFormatter(()=>({
            weekday: local.weekDayFormat,
            timeZone: rootContext.timeZone()
        }));
    const weekDays = (0, _solidJs.createMemo)(()=>{
        const firstDayOfWeek = (0, _date.startOfWeek)((0, _date.today)(rootContext.timeZone()), rootContext.locale());
        return [
            ...new Array(7).keys()
        ].map((index)=>{
            const date = firstDayOfWeek.add({
                days: index
            });
            return dayFormatter().format(date.toDate(rootContext.timeZone()));
        });
    });
    const visibleRangeDescription = (0, _solidJs.createMemo)(()=>{
        return getVisibleRangeDescription(rootContext.translations(), startDate(), endDate(), rootContext.timeZone(), true);
    });
    const ariaLabel = ()=>{
        return [
            local["aria-label"],
            visibleRangeDescription()
        ].filter(Boolean).join(", ");
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        switch(e.key){
            case "Enter":
            case " ":
                e.preventDefault();
                rootContext.selectFocusedDate();
                break;
            case "PageUp":
                e.preventDefault();
                e.stopPropagation();
                rootContext.focusPreviousSection(e.shiftKey);
                break;
            case "PageDown":
                e.preventDefault();
                e.stopPropagation();
                rootContext.focusNextSection(e.shiftKey);
                break;
            case "End":
                e.preventDefault();
                e.stopPropagation();
                rootContext.focusSectionEnd();
                break;
            case "Home":
                e.preventDefault();
                e.stopPropagation();
                rootContext.focusSectionStart();
                break;
            case "ArrowLeft":
                e.preventDefault();
                e.stopPropagation();
                if (rootContext.direction() === "rtl") rootContext.focusNextDay();
                else rootContext.focusPreviousDay();
                break;
            case "ArrowUp":
                e.preventDefault();
                e.stopPropagation();
                rootContext.focusPreviousRow();
                break;
            case "ArrowRight":
                e.preventDefault();
                e.stopPropagation();
                if (rootContext.direction() === "rtl") rootContext.focusPreviousDay();
                else rootContext.focusNextDay();
                break;
            case "ArrowDown":
                e.preventDefault();
                e.stopPropagation();
                rootContext.focusNextRow();
                break;
            case "Escape":
                if (rootContext.selectionMode() === "range") {
                    e.preventDefault();
                    rootContext.setAnchorDate(undefined);
                }
                break;
        }
    };
    const onFocusIn = (e)=>{
        (0, _utils.callHandler)(e, local.onFocusIn);
        rootContext.setIsFocused(true);
    };
    const onFocusOut = (e)=>{
        (0, _utils.callHandler)(e, local.onFocusOut);
        rootContext.setIsFocused(false);
    };
    const context = {
        startDate,
        weekDays
    };
    return (0, _web.createComponent)(CalendarGridContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "table",
                role: "grid",
                get ["aria-readonly"] () {
                    return rootContext.isReadOnly() || undefined;
                },
                get ["aria-disabled"] () {
                    return rootContext.isDisabled() || undefined;
                },
                get ["aria-multiselectable"] () {
                    return rootContext.selectionMode() !== "single";
                },
                get ["aria-label"] () {
                    return ariaLabel();
                },
                onKeyDown: onKeyDown,
                onFocusIn: onFocusIn,
                onFocusOut: onFocusOut
            }, others));
        }
    });
}
/**
 * A calendar grid body displays a grid of calendar cells within a month.
 */ function CalendarGridBody(props) {
    const rootContext = useCalendarContext();
    const context = useCalendarGridContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "children"
    ]);
    const weekIndexes = (0, _solidJs.createMemo)(()=>{
        const weeksInMonth = (0, _date.getWeeksInMonth)(context.startDate(), rootContext.locale());
        return [
            ...new Array(weeksInMonth).keys()
        ];
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "tbody"
    }, others, {
        get children () {
            return (0, _web.createComponent)((0, _solidJs.Index), {
                get each () {
                    return weekIndexes();
                },
                get children () {
                    return local.children;
                }
            });
        }
    }));
}
const CalendarGridBodyCellContext = (0, _solidJs.createContext)();
function useCalendarGriBodyCellContext() {
    const context = (0, _solidJs.useContext)(CalendarGridBodyCellContext);
    if (context === undefined) throw new Error("[kobalte]: `useCalendarGriBodyCellContext` must be used within a `Calendar.GridBodyCell` component");
    return context;
}
/**
 * A calendar grid body cell displays a date cell within a calendar grid which can be selected by the user.
 */ function CalendarGridBodyCell(props) {
    const rootContext = useCalendarContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "date",
        "disabled"
    ]);
    const isSelected = (0, _solidJs.createMemo)(()=>{
        return rootContext.isCellSelected(local.date);
    });
    const isFocused = (0, _solidJs.createMemo)(()=>{
        return rootContext.isCellFocused(local.date);
    });
    const isDisabled = (0, _solidJs.createMemo)(()=>{
        return local.disabled || rootContext.isCellDisabled(local.date);
    });
    const isUnavailable = (0, _solidJs.createMemo)(()=>{
        return rootContext.isCellUnavailable(local.date);
    });
    const isSelectable = ()=>{
        return !rootContext.isReadOnly() && !isDisabled() && !isUnavailable();
    };
    const isInvalid = (0, _solidJs.createMemo)(()=>{
        return rootContext.validationState() === "invalid" && isSelected();
    });
    const isDateToday = ()=>(0, _date.isToday)(local.date, rootContext.timeZone());
    const context = {
        date: ()=>local.date,
        isSelected,
        isFocused,
        isUnavailable,
        isSelectable,
        isDisabled,
        isInvalid,
        isDateToday
    };
    return (0, _web.createComponent)(CalendarGridBodyCellContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "td",
                role: "gridcell",
                get ["aria-disabled"] () {
                    return !isSelectable() || undefined;
                },
                get ["aria-selected"] () {
                    return isSelected() || undefined;
                },
                get ["aria-invalid"] () {
                    return isInvalid() || undefined;
                },
                get ["aria-current"] () {
                    return isDateToday() ? "date" : undefined;
                },
                get ["data-value"] () {
                    return local.date.toString();
                }
            }, others));
        }
    });
}
function CalendarGridBodyCellTrigger(props) {
    let ref;
    const rootContext = useCalendarContext();
    const gridContext = useCalendarGridContext();
    const context = useCalendarGriBodyCellContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "disabled",
        "onPointerEnter",
        "onPointerDown",
        "onPointerUp",
        "onPointerLeave",
        "onClick",
        "onKeyDown"
    ]);
    const isDisabled = ()=>local.disabled || context.isDisabled();
    const isDateWeekend = ()=>{
        return (0, _date.isWeekend)(context.date(), rootContext.locale());
    };
    const isOutsideVisibleRange = ()=>{
        return context.date().compare(rootContext.startDate()) < 0 || context.date().compare(rootContext.endDate()) > 0;
    };
    const isOutsideMonth = ()=>{
        return !(0, _date.isSameMonth)(gridContext.startDate(), context.date());
    };
    const isSelectionStart = ()=>{
        if (rootContext.selectionMode() !== "range") return false;
        const start = rootContext.highlightedRange()?.start;
        return start != null && (0, _date.isSameDay)(context.date(), start);
    };
    const isSelectionEnd = ()=>{
        if (rootContext.selectionMode() !== "range") return false;
        const end = rootContext.highlightedRange()?.end;
        return end != null && (0, _date.isSameDay)(context.date(), end);
    };
    const tabIndex = (0, _solidJs.createMemo)(()=>{
        if (!isDisabled()) return (0, _date.isSameDay)(context.date(), rootContext.focusedDate()) ? 0 : -1;
        return undefined;
    });
    const labelDateFormatter = createDateFormatter(()=>({
            weekday: "long",
            day: "numeric",
            month: "long",
            year: "numeric",
            era: getEraFormat(context.date()),
            timeZone: rootContext.timeZone()
        }));
    const cellDateFormatter = createDateFormatter(()=>({
            day: "numeric",
            timeZone: rootContext.timeZone(),
            calendar: context.date().calendar.identifier
        }));
    const nativeDate = (0, _solidJs.createMemo)(()=>{
        return context.date().toDate(rootContext.timeZone());
    });
    const formattedDate = (0, _solidJs.createMemo)(()=>{
        return cellDateFormatter().formatToParts(nativeDate()).find((part)=>part.type === "day")?.value;
    });
    const ariaLabel = (0, _solidJs.createMemo)(()=>{
        let label = "";
        // If this is a range calendar, add a description of the full selected range
        // to the first and last selected date.
        if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
            const { start , end  } = asRangeValue(rootContext.value()) ?? {};
            if (start && end && ((0, _date.isSameDay)(context.date(), start) || (0, _date.isSameDay)(context.date(), end))) label = getSelectedDateDescription(rootContext.translations(), context.date(), rootContext.timeZone()) + ", ";
        }
        label += labelDateFormatter().format(nativeDate());
        if (context.isDateToday()) // If date is today, set appropriate string depending on selected state:
        label = rootContext.translations().todayDate(label, context.isSelected());
        else if (context.isSelected()) // If date is selected but not today:
        label = rootContext.translations().dateSelected(label);
        const min = rootContext.min();
        const max = rootContext.max();
        if (min && (0, _date.isSameDay)(context.date(), min)) label += ", " + rootContext.translations().minimumDate;
        else if (max && (0, _date.isSameDay)(context.date(), max)) label += ", " + rootContext.translations().maximumDate;
        return label;
    });
    let isPointerDown = false;
    let isAnchorPressed = false;
    let isRangeBoundaryPressed = false;
    let touchDragTimerRef;
    const onPressEnd = ()=>{
        isRangeBoundaryPressed = false;
        isAnchorPressed = false;
        if (touchDragTimerRef != null) {
            (0, _utils.getWindow)(ref).clearTimeout(touchDragTimerRef);
            touchDragTimerRef = undefined;
        }
    };
    const onPointerEnter = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerEnter);
        // Highlight the date on hover or drag over a date when selecting a range.
        if (rootContext.selectionMode() === "range" && (e.pointerType !== "touch" || rootContext.isDragging()) && context.isSelectable()) rootContext.highlightDate(context.date());
    };
    const onPointerLeave = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerLeave);
        if (isPointerDown) onPressEnd();
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        isPointerDown = true;
        // This is necessary on touch devices to allow dragging
        // outside the original pressed element.
        if ("releasePointerCapture" in e.target) e.target.releasePointerCapture(e.pointerId);
        if (rootContext.isReadOnly()) {
            rootContext.focusCell(context.date());
            return;
        }
        if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
            const highlightedRange = rootContext.highlightedRange();
            // Allow dragging the start or end date of a range to modify it
            // rather than starting a new selection.
            // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges
            // are constrained to available dates. The user will need to select a new range in this case.
            if (highlightedRange && !context.isInvalid()) {
                if ((0, _date.isSameDay)(context.date(), highlightedRange.start)) {
                    rootContext.setAnchorDate(highlightedRange.end);
                    rootContext.focusCell(context.date());
                    rootContext.setIsDragging(true);
                    isRangeBoundaryPressed = true;
                    return;
                } else if ((0, _date.isSameDay)(context.date(), highlightedRange.end)) {
                    rootContext.setAnchorDate(highlightedRange.start);
                    rootContext.focusCell(context.date());
                    rootContext.setIsDragging(true);
                    isRangeBoundaryPressed = true;
                    return;
                }
            }
            const startDragging = ()=>{
                rootContext.setIsDragging(true);
                touchDragTimerRef = undefined;
                rootContext.selectDate(context.date());
                rootContext.focusCell(context.date());
                isAnchorPressed = true;
            };
            // Start selection on mouse/touch down so users can drag to select a range.
            // On touch, delay dragging to determine if the user really meant to scroll.
            if (e.pointerType === "touch") touchDragTimerRef = (0, _utils.getWindow)(ref).setTimeout(startDragging, 200);
            else startDragging();
        }
    };
    const onPointerUp = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerUp);
        isPointerDown = false;
        if (rootContext.isReadOnly() || rootContext.selectionMode() !== "range") {
            onPressEnd();
            return;
        }
        // If the user tapped quickly, the date won't be selected yet and the
        // timer will still be in progress. In this case, select the date on touch up.
        if (touchDragTimerRef != null) {
            rootContext.selectDate(context.date());
            rootContext.focusCell(context.date());
        }
        if (isRangeBoundaryPressed) // When clicking on the start or end date of an already selected range,
        // start a new selection on press up to also allow dragging the date to
        // change the existing range.
        rootContext.setAnchorDate(context.date());
        else if (rootContext.anchorDate() && !isAnchorPressed) {
            // When releasing a drag or pressing the end date of a range, select it.
            rootContext.selectDate(context.date());
            rootContext.focusCell(context.date());
        }
        onPressEnd();
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        // For non-range selection, always select on press up.
        if (rootContext.selectionMode() !== "range" && context.isSelectable()) {
            rootContext.selectDate(context.date());
            rootContext.focusCell(context.date());
        }
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (![
            "Enter",
            " "
        ].includes(e.key)) return;
        if (rootContext.isReadOnly()) {
            rootContext.focusCell(context.date());
            return;
        }
        if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
            // Prevent `Calendar.Grid` to select the cell.
            e.stopPropagation();
            // For range selection, auto-advance the focused date by one if using keyboard.
            // This gives an indication that you're selecting a range rather than a single date.
            rootContext.selectDate(context.date());
            let nextDay = context.date().add({
                days: 1
            });
            if (rootContext.isCellInvalid(nextDay)) nextDay = context.date().subtract({
                days: 1
            });
            if (!rootContext.isCellInvalid(nextDay)) rootContext.focusCell(nextDay);
        }
    };
    // Focus the button in the DOM when the date become the focused/highlighted one.
    (0, _solidJs.createEffect)(()=>{
        if (ref && context.isFocused()) (0, _utils.focusWithoutScrolling)(ref);
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        role: "button",
        get tabIndex () {
            return tabIndex();
        },
        get disabled () {
            return isDisabled();
        },
        get ["aria-disabled"] () {
            return !context.isSelectable() || undefined;
        },
        get ["aria-invalid"] () {
            return context.isInvalid() || undefined;
        },
        get ["aria-label"] () {
            return ariaLabel();
        },
        get ["data-disabled"] () {
            return isDisabled() || undefined;
        },
        get ["data-invalid"] () {
            return context.isInvalid() || undefined;
        },
        get ["data-selected"] () {
            return context.isSelected() || undefined;
        },
        get ["data-value"] () {
            return context.date().toString();
        },
        "data-type": "day",
        get ["data-today"] () {
            return context.isDateToday() || undefined;
        },
        get ["data-weekend"] () {
            return isDateWeekend() || undefined;
        },
        get ["data-highlighted"] () {
            return context.isFocused() || undefined;
        },
        get ["data-unavailable"] () {
            return context.isUnavailable() || undefined;
        },
        get ["data-selection-start"] () {
            return isSelectionStart() || undefined;
        },
        get ["data-selection-end"] () {
            return isSelectionEnd() || undefined;
        },
        get ["data-outside-visible-range"] () {
            return isOutsideVisibleRange() || undefined;
        },
        get ["data-outside-month"] () {
            return isOutsideMonth() || undefined;
        },
        onPointerEnter: onPointerEnter,
        onPointerLeave: onPointerLeave,
        onPointerDown: onPointerDown,
        onPointerUp: onPointerUp,
        onClick: onClick,
        onKeyDown: onKeyDown,
        onContextMenu: (e)=>{
            // Prevent context menu on long press.
            e.preventDefault();
        }
    }, others, {
        get children () {
            return formattedDate();
        }
    }));
}
/**
 * A calendar grid body row displays a row of calendar cells within a month.
 */ function CalendarGridBodyRow(props) {
    const rootContext = useCalendarContext();
    const context = useCalendarGridContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "weekIndex",
        "children"
    ]);
    const datesInWeek = (0, _solidJs.createMemo)(()=>{
        return rootContext.getDatesInWeek(local.weekIndex, context.startDate());
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "tr"
    }, others, {
        get children () {
            return (0, _web.createComponent)((0, _solidJs.Index), {
                get each () {
                    return datesInWeek();
                },
                get children () {
                    return local.children;
                }
            });
        }
    }));
}
/**
 * A calendar grid header displays a row of week day names at the top of a month.
 */ function CalendarGridHeader(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "thead",
        "aria-hidden": "true"
    }, props));
}
/**
 * A calendar grid header cell displays a week day name at the top of a column within a calendar.
 */ function CalendarGridHeaderCell(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "th"
    }, props));
}
/**
 * A calendar grid header row displays week day names inside a `Calendar.GridHeader`.
 */ function CalendarGridHeaderRow(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "children"
    ]);
    const context = useCalendarGridContext();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "tr"
    }, others, {
        get children () {
            return (0, _web.createComponent)((0, _solidJs.Index), {
                get each () {
                    return context.weekDays();
                },
                get children () {
                    return local.children;
                }
            });
        }
    }));
}
/**
 * Contains the calendar heading and navigation triggers.
 */ function CalendarHeader(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "header"
    }, props));
}
function CalendarHeading(props) {
    const rootContext = useCalendarContext();
    const title = (0, _solidJs.createMemo)(()=>{
        return getVisibleRangeDescription(rootContext.translations(), rootContext.startDate(), rootContext.endDate(), rootContext.timeZone(), false);
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "h2"
    }, props, {
        get children () {
            return title();
        }
    }));
}
function CalendarNextTrigger(props) {
    const context = useCalendarContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "disabled",
        "onClick",
        "onFocus",
        "onBlur"
    ]);
    let nextTriggerFocused = false;
    const nextTriggerDisabled = (0, _solidJs.createMemo)(()=>{
        return local.disabled || context.isDisabled() || isNextVisibleRangeInvalid(context.endDate(), context.min(), context.max());
    });
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.focusNextPage();
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        nextTriggerFocused = true;
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        nextTriggerFocused = false;
    };
    // If the next trigger become disabled while they are focused, move focus to the calendar body.
    (0, _solidJs.createEffect)(()=>{
        if (nextTriggerDisabled() && nextTriggerFocused) {
            nextTriggerFocused = false;
            context.setIsFocused(true);
        }
    });
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get disabled () {
            return nextTriggerDisabled();
        },
        get ["aria-label"] () {
            return context.translations().next;
        },
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur
    }, others));
}
function CalendarPrevTrigger(props) {
    const context = useCalendarContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "disabled",
        "onClick",
        "onFocus",
        "onBlur"
    ]);
    let prevTriggerFocused = false;
    const prevTriggerDisabled = (0, _solidJs.createMemo)(()=>{
        return local.disabled || context.isDisabled() || isPreviousVisibleRangeInvalid(context.startDate(), context.min(), context.max());
    });
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.focusPreviousPage();
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        prevTriggerFocused = true;
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        prevTriggerFocused = false;
    };
    // If the prev trigger become disabled while they are focused, move focus to the calendar body.
    (0, _solidJs.createEffect)(()=>{
        if (prevTriggerDisabled() && prevTriggerFocused) {
            prevTriggerFocused = false;
            context.setIsFocused(true);
        }
    });
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get disabled () {
            return prevTriggerDisabled();
        },
        get ["aria-label"] () {
            return context.translations().previous;
        },
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur
    }, others));
}
const CALENDAR_INTL_MESSAGES = {
    previous: "Previous",
    next: "Next",
    selectedDateDescription: (date)=>`Selected Date: ${date}`,
    selectedRangeDescription: (dateRange)=>`Selected Range: ${dateRange}`,
    todayDate: (date, isSelected)=>`Today, ${date} ${isSelected ? " selected" : ""}`,
    dateSelected: (date)=>`${date} selected`,
    startRangeSelectionPrompt: "Click to start selecting date range",
    finishRangeSelectionPrompt: "Click to finish selecting date range",
    minimumDate: "First available date",
    maximumDate: "Last available date",
    dateRange: (startDate, endDate)=>`${startDate} to ${endDate}`
};
/**
 * A calendar displays one or more date grids and allows users to select a single, multiple or range of dates.
 */ function CalendarRoot(props) {
    let ref;
    props = (0, _utils.mergeDefaultProps)({
        visibleDuration: {
            months: 1
        },
        selectionMode: "single",
        translations: CALENDAR_INTL_MESSAGES
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "translations",
        "ref",
        "locale",
        "createCalendar",
        "visibleDuration",
        "selectionAlignment",
        "selectionMode",
        "value",
        "defaultValue",
        "onChange",
        "minValue",
        "maxValue",
        "isDateUnavailable",
        "allowsNonContiguousRanges",
        "autoFocus",
        "focusedValue",
        "defaultFocusedValue",
        "onFocusChange",
        "validationState",
        "disabled",
        "readOnly",
        "aria-label"
    ]);
    const locale = (0, _solidJs.createMemo)(()=>{
        return local.locale ?? useLocale().locale();
    });
    const resolvedOptions = (0, _solidJs.createMemo)(()=>{
        return new (0, _date.DateFormatter)(locale()).resolvedOptions();
    });
    const direction = (0, _solidJs.createMemo)(()=>{
        return getReadingDirection(locale());
    });
    const calendar = (0, _solidJs.createMemo)(()=>{
        return local.createCalendar(resolvedOptions().calendar);
    });
    const [value, setControlledValue] = createControllableSignal({
        value: ()=>local.value,
        defaultValue: ()=>local.defaultValue,
        onChange: (value)=>local.onChange?.(value)
    });
    const [availableRange, setAvailableRange] = (0, _solidJs.createSignal)();
    const selectionAlignment = (0, _solidJs.createMemo)(()=>{
        if (local.selectionMode === "range") {
            const valueRange = asRangeValue(value());
            if (valueRange?.start && valueRange.end) {
                const start = alignCenter((0, _date.toCalendarDate)(valueRange.start), local.visibleDuration, locale(), local.minValue, local.maxValue);
                const end = start.add(local.visibleDuration).subtract({
                    days: 1
                });
                if (valueRange.end.compare(end) > 0) return "start";
            }
            return "center";
        }
        return local.selectionAlignment ?? "center";
    });
    const min = (0, _solidJs.createMemo)(()=>{
        const startRange = availableRange()?.start;
        if (local.selectionMode === "range" && local.minValue && startRange) return (0, _date.maxDate)(local.minValue, startRange);
        return local.minValue;
    });
    const max = (0, _solidJs.createMemo)(()=>{
        const endRange = availableRange()?.end;
        if (local.selectionMode === "range" && local.maxValue && endRange) return (0, _date.minDate)(local.maxValue, endRange);
        return local.maxValue;
    });
    const calendarDateValue = (0, _solidJs.createMemo)(()=>{
        return getArrayValueOfSelection(local.selectionMode, value()).map((date)=>(0, _date.toCalendar)((0, _date.toCalendarDate)(date), calendar()));
    });
    const timeZone = (0, _solidJs.createMemo)(()=>{
        const firstValue = getFirstValueOfSelection(local.selectionMode, value());
        if (firstValue && "timeZone" in firstValue) return firstValue.timeZone;
        return resolvedOptions().timeZone;
    });
    const focusedCalendarDate = (0, _solidJs.createMemo)(()=>{
        if (local.focusedValue) return constrainValue((0, _date.toCalendar)((0, _date.toCalendarDate)(local.focusedValue), calendar()), min(), max());
        return undefined;
    });
    const defaultFocusedCalendarDate = (0, _solidJs.createMemo)(()=>{
        return constrainValue(local.defaultFocusedValue ? (0, _date.toCalendar)((0, _date.toCalendarDate)(local.defaultFocusedValue), calendar()) : calendarDateValue()[0] || (0, _date.toCalendar)((0, _date.today)(timeZone()), calendar()), min(), max());
    });
    const [focusedDate, setFocusedDate] = createControllableSignal({
        value: focusedCalendarDate,
        defaultValue: defaultFocusedCalendarDate,
        onChange: (value)=>local.onFocusChange?.(value)
    });
    const [startDate, setStartDate] = (0, _solidJs.createSignal)(alignDate(focusedDate(), selectionAlignment(), local.visibleDuration, locale(), min(), max()));
    const endDate = (0, _solidJs.createMemo)(()=>{
        return getEndDate(startDate(), local.visibleDuration);
    });
    const [isFocused, setIsFocused] = (0, _solidJs.createSignal)(local.autoFocus || false);
    const [isDragging, setIsDragging] = (0, _solidJs.createSignal)(false);
    const visibleRangeDescription = (0, _solidJs.createMemo)(()=>{
        return getVisibleRangeDescription(local.translations, startDate(), endDate(), timeZone(), true);
    });
    const ariaLabel = ()=>{
        return [
            local["aria-label"],
            visibleRangeDescription()
        ].filter(Boolean).join(", ");
    };
    const isCellDisabled = (date)=>{
        return local.disabled || date.compare(startDate()) < 0 || date.compare(endDate()) > 0 || isDateInvalid(date, min(), max());
    };
    const isCellUnavailable = (date)=>{
        return local.isDateUnavailable?.(date) ?? false;
    };
    const updateAvailableRange = (date)=>{
        if (date && local.isDateUnavailable && !local.allowsNonContiguousRanges) setAvailableRange({
            start: getNextUnavailableDate(date, startDate(), endDate(), isCellUnavailable, -1),
            end: getNextUnavailableDate(date, startDate(), endDate(), isCellUnavailable, 1)
        });
        else setAvailableRange(undefined);
    };
    const [anchorDate, setAnchorDate] = createControllableSignal({
        onChange: (value)=>updateAvailableRange(value)
    });
    const highlightedRange = (0, _solidJs.createMemo)(()=>{
        if (local.selectionMode !== "range") return undefined;
        const resolvedAnchorDate = anchorDate();
        if (resolvedAnchorDate) return makeCalendarDateRange(resolvedAnchorDate, focusedDate());
        const { start , end  } = asRangeValue(value()) ?? {};
        return makeCalendarDateRange(start, end);
    });
    const validationState = (0, _solidJs.createMemo)(()=>{
        if (local.validationState) return local.validationState;
        if (calendarDateValue().length <= 0) return null;
        if (local.selectionMode === "range" && anchorDate()) return null;
        const isSomeDateInvalid = calendarDateValue().some((date)=>{
            return local.isDateUnavailable?.(date) || isDateInvalid(date, min(), max());
        });
        return isSomeDateInvalid ? "invalid" : null;
    });
    const isCellSelected = (cellDate)=>{
        const isAvailable = !isCellDisabled(cellDate) && !isCellUnavailable(cellDate);
        if (local.selectionMode === "range") {
            const { start , end  } = highlightedRange() ?? {};
            const isInRange = start != null && cellDate.compare(start) >= 0 && end != null && cellDate.compare(end) <= 0;
            return isInRange && isAvailable;
        }
        return calendarDateValue().some((date)=>(0, _date.isSameDay)(cellDate, date)) && isAvailable;
    };
    const isCellFocused = (date)=>{
        const resolvedFocusedDate = focusedDate();
        return isFocused() && resolvedFocusedDate != null && (0, _date.isSameDay)(date, resolvedFocusedDate);
    };
    const isCellInvalid = (date)=>{
        if (local.selectionMode === "range") return isDateInvalid(date, min(), max()) || isDateInvalid(date, availableRange()?.start, availableRange()?.end);
        return isDateInvalid(date, min(), max());
    };
    const selectDate = (date)=>{
        if (local.readOnly || local.disabled) return;
        let newValue = getPreviousAvailableDate(constrainValue(date, min(), max()), startDate(), local.isDateUnavailable);
        if (!newValue) return;
        if (local.selectionMode === "single") setControlledValue((prev)=>{
            const prevValue = asSingleValue(prev);
            if (!newValue) return prevValue;
            return convertValue$1(newValue, prevValue);
        });
        else if (local.selectionMode === "multiple") setControlledValue((prev)=>{
            const prevValue = asArrayValue(prev) ?? [];
            if (!newValue) return prevValue;
            newValue = convertValue$1(newValue, prevValue[0]);
            const index = prevValue.findIndex((date)=>newValue != null && (0, _date.isSameDay)(date, newValue));
            // If new value is already selected, remove it.
            if (index !== -1) {
                const nextValues = [
                    ...prevValue
                ];
                nextValues.splice(index, 1);
                return sortDates(nextValues);
            } else return sortDates([
                ...prevValue,
                newValue
            ]);
        });
        else if (local.selectionMode === "range") {
            if (!anchorDate()) setAnchorDate(newValue);
            else {
                setControlledValue((prev)=>{
                    const prevRange = asRangeValue(prev);
                    const range = makeCalendarDateRange(anchorDate(), newValue);
                    if (!range) return prevRange;
                    return {
                        start: convertValue$1(range.start, prevRange?.start),
                        end: convertValue$1(range.end, prevRange?.end)
                    };
                });
                setAnchorDate(undefined);
            }
        }
    };
    const selectFocusedDate = ()=>{
        selectDate(focusedDate());
    };
    const focusCell = (date)=>{
        setFocusedDate(constrainValue(date, min(), max()));
        if (!isFocused()) setIsFocused(true);
    };
    const highlightDate = (date)=>{
        if (anchorDate()) focusCell(date);
    };
    const focusNextDay = ()=>{
        focusCell(focusedDate().add({
            days: 1
        }));
    };
    const focusPreviousDay = ()=>{
        focusCell(focusedDate().subtract({
            days: 1
        }));
    };
    const focusNextRow = ()=>{
        const row = getNextRow(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
        if (row) {
            setStartDate(row.startDate);
            focusCell(row.focusedDate);
        }
    };
    const focusPreviousRow = ()=>{
        const row = getPreviousRow(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
        if (row) {
            setStartDate(row.startDate);
            focusCell(row.focusedDate);
        }
    };
    const focusNextPage = ()=>{
        const page = getNextPage(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
        setFocusedDate(constrainValue(page.focusedDate, min(), max()));
        setStartDate(page.startDate);
    };
    const focusPreviousPage = ()=>{
        const page = getPreviousPage(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
        setFocusedDate(constrainValue(page.focusedDate, min(), max()));
        setStartDate(page.startDate);
    };
    const focusSectionStart = ()=>{
        const section = getSectionStart(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
        if (section) {
            setStartDate(section.startDate);
            focusCell(section.focusedDate);
        }
    };
    const focusSectionEnd = ()=>{
        const section = getSectionEnd(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
        if (section) {
            setStartDate(section.startDate);
            focusCell(section.focusedDate);
        }
    };
    const focusNextSection = (larger)=>{
        const section = getNextSection(focusedDate(), startDate(), larger, local.visibleDuration, locale(), min(), max());
        if (section) {
            setStartDate(section.startDate);
            focusCell(section.focusedDate);
        }
    };
    const focusPreviousSection = (larger)=>{
        const section = getPreviousSection(focusedDate(), startDate(), larger, local.visibleDuration, locale(), min(), max());
        if (section) {
            setStartDate(section.startDate);
            focusCell(section.focusedDate);
        }
    };
    const getDatesInWeek = (weekIndex, from)=>{
        let date = from.add({
            weeks: weekIndex
        });
        const dates = [];
        date = (0, _date.startOfWeek)(date, locale());
        // startOfWeek will clamp dates within the calendar system's valid range, which may
        // start in the middle of a week. In this case, add null placeholders.
        const dayOfWeek = (0, _date.getDayOfWeek)(date, locale());
        for(let i = 0; i < dayOfWeek; i++)dates.push(null);
        while(dates.length < 7){
            dates.push(date);
            const nextDate = date.add({
                days: 1
            });
            if ((0, _date.isSameDay)(date, nextDate)) break;
            date = nextDate;
        }
        // Add null placeholders if at the end of the calendar system.
        while(dates.length < 7)dates.push(null);
        return dates;
    };
    createInteractOutside({
        onInteractOutside: (e)=>{
            // Stop range selection on interaction outside the calendar, e.g. tabbing away from the calendar.
            if (local.selectionMode === "range" && anchorDate()) selectFocusedDate();
        }
    }, ()=>ref);
    // Reset focused date and visible range when calendar changes.
    let lastCalendarIdentifier = calendar().identifier;
    (0, _solidJs.createEffect)((0, _solidJs.on)(calendar, (calendar)=>{
        if (calendar.identifier !== lastCalendarIdentifier) {
            const newFocusedDate = (0, _date.toCalendar)(focusedDate(), calendar);
            setStartDate(alignCenter(newFocusedDate, local.visibleDuration, locale(), min(), max()));
            setFocusedDate(newFocusedDate);
            lastCalendarIdentifier = calendar.identifier;
        }
    }));
    (0, _solidJs.createEffect)(()=>{
        const adjust = getAdjustedDateFn(local.visibleDuration, locale(), min(), max());
        const adjustment = adjust({
            startDate: startDate(),
            focusedDate: focusedDate()
        });
        setStartDate(adjustment.startDate);
        setFocusedDate(adjustment.focusedDate);
    });
    // Announce when the visible date range changes only when pressing the Previous or Next triggers.
    (0, _solidJs.createEffect)(()=>{
        if (!isFocused()) announce(visibleRangeDescription());
    });
    // Announce when the selected value changes
    (0, _solidJs.createEffect)(()=>{
        let description;
        if (local.selectionMode === "single") {
            const date = asSingleValue(value());
            description = date && getSelectedDateDescription(local.translations, date, timeZone());
        } else if (local.selectionMode === "multiple") {
            const dates = asArrayValue(value());
            description = dates?.map((date)=>getSelectedDateDescription(local.translations, date, timeZone())).join(", ");
        } else if (local.selectionMode === "range") {
            const dateRange = asRangeValue(value()) ?? {};
            description = getSelectedDateRangeDescription(local.translations, dateRange, anchorDate(), timeZone());
        }
        if (description) announce(description, "polite", 4000);
    });
    // In "range" selection mode, update the available range if the visible range changes.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        startDate,
        endDate
    ], ()=>{
        if (local.selectionMode === "range") updateAvailableRange(anchorDate());
    }));
    let isVirtualClick = false;
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        if (local.selectionMode !== "range" || !ref) return;
        const win = (0, _utils.getWindow)(ref);
        const doc = (0, _utils.getDocument)(ref);
        // We need to ignore virtual pointer events from VoiceOver due to these bugs.
        // https://bugs.webkit.org/show_bug.cgi?id=222627
        // https://bugs.webkit.org/show_bug.cgi?id=223202
        const onWindowPointerDown = (e)=>{
            isVirtualClick = e.width === 0 && e.height === 0;
        };
        // Stop range selection when pressing or releasing a pointer outside the calendar body,
        // except when pressing the next or previous buttons to switch months.
        const endDragging = (e)=>{
            if (isVirtualClick) {
                isVirtualClick = false;
                return;
            }
            setIsDragging(false);
            if (!anchorDate()) return;
            const target = e.target;
            if ((0, _utils.contains)(ref, doc.activeElement) && (!(0, _utils.contains)(ref, target) || !target.closest('button, [role="button"]'))) selectFocusedDate();
        };
        // Prevent touch scrolling while dragging
        const onTouchMove = (e)=>{
            if (isDragging()) e.preventDefault();
        };
        win.addEventListener("pointerdown", onWindowPointerDown);
        win.addEventListener("pointerup", endDragging);
        win.addEventListener("pointercancel", endDragging);
        ref.addEventListener("touchmove", onTouchMove, {
            passive: false,
            capture: true
        });
        (0, _solidJs.onCleanup)(()=>{
            win.removeEventListener("pointerdown", onWindowPointerDown);
            win.removeEventListener("pointerup", endDragging);
            win.removeEventListener("pointercancel", endDragging);
            ref?.removeEventListener("touchmove", onTouchMove, {
                capture: true
            });
        });
    });
    const dataset = (0, _solidJs.createMemo)(()=>({}));
    const context = {
        dataset,
        value,
        isDisabled: ()=>local.disabled ?? false,
        isReadOnly: ()=>local.readOnly ?? false,
        isDragging,
        isCellUnavailable,
        isCellDisabled,
        isCellSelected,
        isCellFocused,
        isCellInvalid,
        validationState,
        startDate,
        endDate,
        anchorDate,
        focusedDate: ()=>focusedDate(),
        visibleDuration: ()=>local.visibleDuration,
        selectionMode: ()=>local.selectionMode,
        locale,
        highlightedRange,
        direction,
        min,
        max,
        timeZone,
        translations: ()=>local.translations,
        setStartDate,
        setAnchorDate,
        setIsFocused,
        setIsDragging,
        selectFocusedDate,
        selectDate,
        highlightDate,
        focusCell,
        focusNextDay,
        focusPreviousDay,
        focusNextPage,
        focusPreviousPage,
        focusNextRow,
        focusPreviousRow,
        focusSectionStart,
        focusSectionEnd,
        focusNextSection,
        focusPreviousSection,
        getDatesInWeek
    };
    return (0, _web.createComponent)(CalendarContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                as: "div",
                role: "group",
                get ["aria-label"] () {
                    return ariaLabel();
                }
            }, others));
        }
    });
}
function convertValue$1(newValue, oldValue) {
    // The display calendar should not have any effect on the emitted value.
    // Emit dates in the same calendar as the original value, if any, otherwise gregorian.
    newValue = (0, _date.toCalendar)(newValue, oldValue?.calendar || new (0, _date.GregorianCalendar)());
    // Preserve time if the input value had one.
    if (oldValue && "hour" in oldValue) return oldValue.set(newValue);
    return newValue;
}
var index$m = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Body: CalendarBody,
    Grid: CalendarGrid,
    GridBody: CalendarGridBody,
    GridBodyCell: CalendarGridBodyCell,
    GridBodyCellTrigger: CalendarGridBodyCellTrigger,
    GridBodyRow: CalendarGridBodyRow,
    GridHeader: CalendarGridHeader,
    GridHeaderCell: CalendarGridHeaderCell,
    GridHeaderRow: CalendarGridHeaderRow,
    Header: CalendarHeader,
    Heading: CalendarHeading,
    NextTrigger: CalendarNextTrigger,
    PrevTrigger: CalendarPrevTrigger,
    Root: CalendarRoot
});
const CheckboxContext = (0, _solidJs.createContext)();
function useCheckboxContext() {
    const context = (0, _solidJs.useContext)(CheckboxContext);
    if (context === undefined) throw new Error("[kobalte]: `useCheckboxContext` must be used within a `Checkbox` component");
    return context;
}
/**
 * The element that visually represents a checkbox.
 */ function CheckboxControl(props) {
    const formControlContext = useFormControlContext();
    const context = useCheckboxContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("control")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick",
        "onKeyDown"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.toggle();
        context.inputRef()?.focus();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (e.key === (0, _utils.EventKey).Space) {
            context.toggle();
            context.inputRef()?.focus();
        }
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        onClick: onClick,
        onKeyDown: onKeyDown
    }, ()=>formControlContext.dataset(), ()=>context.dataset(), others));
}
/**
 * The description that gives the user more information on the checkbox.
 */ function CheckboxDescription(props) {
    const context = useCheckboxContext();
    return (0, _web.createComponent)(FormControlDescription, (0, _web.mergeProps)(()=>context.dataset(), props));
}
/**
 * The error message that gives the user information about how to fix a validation error on the checkbox.
 */ function CheckboxErrorMessage(props) {
    const context = useCheckboxContext();
    return (0, _web.createComponent)(FormControlErrorMessage, (0, _web.mergeProps)(()=>context.dataset(), props));
}
/**
 * The visual indicator rendered when the checkbox is in a checked or indeterminate state.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */ function CheckboxIndicator(props) {
    const formControlContext = useFormControlContext();
    const context = useCheckboxContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("indicator")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "forceMount"
    ]);
    const presence = createPresence(()=>local.forceMount || context.indeterminate() || context.checked());
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return presence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)(presence.setRef, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                }
            }, ()=>formControlContext.dataset(), ()=>context.dataset(), others));
        }
    });
}
const _tmpl$$g = /*#__PURE__*/ (0, _web.template)(`<input type="checkbox">`);
/**
 * The native html input that is visually hidden in the checkbox.
 */ function CheckboxInput(props) {
    let ref;
    const formControlContext = useFormControlContext();
    const context = useCheckboxContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("input")
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onChange",
        "onFocus",
        "onBlur"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    const [isInternalChangeEvent, setIsInternalChangeEvent] = (0, _solidJs.createSignal)(false);
    const onChange = (e)=>{
        (0, _utils.callHandler)(e, local.onChange);
        e.stopPropagation();
        if (!isInternalChangeEvent()) {
            const target = e.target;
            context.setIsChecked(target.checked);
            // Unlike in React, inputs `checked` state can be out of sync with our toggle state.
            // for example a readonly `<input type="checkbox" />` is always "checkable".
            //
            // Also, even if an input is controlled (ex: `<input type="checkbox" checked={isChecked} />`,
            // clicking on the input will change its internal `checked` state.
            //
            // To prevent this, we need to force the input `checked` state to be in sync with the toggle state.
            target.checked = context.checked();
        }
        setIsInternalChangeEvent(false);
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        context.setIsFocused(true);
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        context.setIsFocused(false);
    };
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>context.checked(),
        ()=>context.value()
    ], ()=>{
        setIsInternalChangeEvent(true);
        ref?.dispatchEvent(new Event("input", {
            bubbles: true,
            cancelable: true
        }));
        ref?.dispatchEvent(new Event("change", {
            bubbles: true,
            cancelable: true
        }));
    }, {
        defer: true
    }));
    // indeterminate is a property, but it can only be set via javascript
    // https://css-tricks.com/indeterminate-checkboxes/
    // Unlike in React, inputs `indeterminate` state can be out of sync with our.
    // Clicking on the input will change its internal `indeterminate` state.
    // To prevent this, we need to force the input `indeterminate` state to be in sync with our.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>ref,
        ()=>context.indeterminate(),
        ()=>context.checked()
    ], ([ref, indeterminate])=>{
        if (ref) ref.indeterminate = !!indeterminate;
    }));
    return (()=>{
        const _el$ = _tmpl$$g();
        _el$.addEventListener("blur", onBlur);
        _el$.addEventListener("focus", onFocus);
        _el$.addEventListener("change", onChange);
        const _ref$ = (0, _utils.mergeRefs)((el)=>{
            context.setInputRef(el);
            ref = el;
        }, local.ref);
        typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$);
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get id () {
                return fieldProps.id();
            },
            get name () {
                return formControlContext.name();
            },
            get value () {
                return context.value();
            },
            get checked () {
                return context.checked();
            },
            get required () {
                return formControlContext.isRequired();
            },
            get disabled () {
                return formControlContext.isDisabled();
            },
            get readonly () {
                return formControlContext.isReadOnly();
            },
            get style () {
                return {
                    ...(0, _utils.visuallyHiddenStyles),
                    ...local.style
                };
            },
            get ["aria-label"] () {
                return fieldProps.ariaLabel();
            },
            get ["aria-labelledby"] () {
                return fieldProps.ariaLabelledBy();
            },
            get ["aria-describedby"] () {
                return fieldProps.ariaDescribedBy();
            },
            get ["aria-invalid"] () {
                return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"] () {
                return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"] () {
                return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"] () {
                return formControlContext.isReadOnly() || undefined;
            }
        }, ()=>formControlContext.dataset(), ()=>context.dataset(), others), false, false);
        return _el$;
    })();
}
/**
 * The label that gives the user information on the checkbox.
 */ function CheckboxLabel(props) {
    const context = useCheckboxContext();
    return (0, _web.createComponent)(FormControlLabel, (0, _web.mergeProps)(()=>context.dataset(), props));
}
/**
 * A control that allows the user to toggle between checked and not checked.
 */ function CheckboxRoot(props) {
    let ref;
    const defaultId = `checkbox-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        value: "on",
        id: defaultId
    }, props);
    const [local, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "children",
        "value",
        "checked",
        "defaultChecked",
        "indeterminate",
        "onChange",
        "onPointerDown"
    ], FORM_CONTROL_PROP_NAMES);
    const [inputRef, setInputRef] = (0, _solidJs.createSignal)();
    const [isFocused, setIsFocused] = (0, _solidJs.createSignal)(false);
    const { formControlContext  } = createFormControl(formControlProps);
    const state = createToggleState({
        isSelected: ()=>local.checked,
        defaultIsSelected: ()=>local.defaultChecked,
        onSelectedChange: (selected)=>local.onChange?.(selected),
        isDisabled: ()=>formControlContext.isDisabled(),
        isReadOnly: ()=>formControlContext.isReadOnly()
    });
    createFormResetListener(()=>ref, ()=>state.setIsSelected(local.defaultChecked ?? false));
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        // For consistency with native, prevent the input blurs on pointer down.
        if (isFocused()) e.preventDefault();
    };
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-checked": state.isSelected() ? "" : undefined,
            "data-indeterminate": local.indeterminate ? "" : undefined
        }));
    const context = {
        value: ()=>local.value,
        dataset,
        checked: ()=>state.isSelected(),
        indeterminate: ()=>local.indeterminate ?? false,
        inputRef,
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        toggle: ()=>state.toggle(),
        setIsChecked: (isChecked)=>state.setIsSelected(isChecked),
        setIsFocused,
        setInputRef
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(CheckboxContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                        as: "div",
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "group",
                        get id () {
                            return (0, _utils.access)(formControlProps.id);
                        },
                        onPointerDown: onPointerDown
                    }, ()=>formControlContext.dataset(), dataset, others, {
                        get children () {
                            return (0, _web.createComponent)(CheckboxRootChild, {
                                state: context,
                                get children () {
                                    return local.children;
                                }
                            });
                        }
                    }));
                }
            });
        }
    });
}
function CheckboxRootChild(props) {
    const resolvedChildren = (0, _solidJs.children)(()=>{
        const body = props.children;
        return (0, _utils.isFunction)(body) ? body(props.state) : body;
    });
    return (0, _web.memo)(resolvedChildren);
}
var index$l = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Control: CheckboxControl,
    Description: CheckboxDescription,
    ErrorMessage: CheckboxErrorMessage,
    Indicator: CheckboxIndicator,
    Input: CheckboxInput,
    Label: CheckboxLabel,
    Root: CheckboxRoot
});
const PopperContext = (0, _solidJs.createContext)();
function usePopperContext() {
    const context = (0, _solidJs.useContext)(PopperContext);
    if (context === undefined) throw new Error("[kobalte]: `usePopperContext` must be used within a `Popper` component");
    return context;
}
const _tmpl$$f = /*#__PURE__*/ (0, _web.template)(`<svg display="block" viewBox="0 0 30 30"><g><path fill="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"></path><path stroke="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z">`);
const DEFAULT_SIZE = 30;
const HALF_DEFAULT_SIZE = DEFAULT_SIZE / 2;
const ROTATION_DEG = {
    top: 180,
    right: -90,
    bottom: 0,
    left: 90
};
/**
 * An optional arrow element to render alongside the popper content.
 * Must be rendered in the popper content.
 */ function PopperArrow(props) {
    const context = usePopperContext();
    props = (0, _utils.mergeDefaultProps)({
        size: DEFAULT_SIZE
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "children",
        "size"
    ]);
    const dir = ()=>context.currentPlacement().split("-")[0];
    const contentStyle = createComputedStyle(context.contentRef);
    const fill = ()=>contentStyle()?.getPropertyValue("background-color") || "none";
    const stroke = ()=>contentStyle()?.getPropertyValue(`border-${dir()}-color`) || "none";
    const borderWidth = ()=>contentStyle()?.getPropertyValue(`border-${dir()}-width`) || "0px";
    const strokeWidth = ()=>{
        return parseInt(borderWidth()) * 2 * (DEFAULT_SIZE / local.size);
    };
    const rotate = ()=>{
        return `rotate(${ROTATION_DEG[dir()]} ${HALF_DEFAULT_SIZE} ${HALF_DEFAULT_SIZE})`;
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setArrowRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        "aria-hidden": "true",
        get style () {
            return {
                // server side rendering
                position: "absolute",
                "font-size": `${local.size}px`,
                width: "1em",
                height: "1em",
                "pointer-events": "none",
                fill: fill(),
                stroke: stroke(),
                "stroke-width": strokeWidth(),
                ...local.style
            };
        }
    }, others, {
        get children () {
            const _el$ = _tmpl$$f(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
            _el$3.nextSibling;
            (0, _web.effect)(()=>(0, _web.setAttribute)(_el$2, "transform", rotate()));
            return _el$;
        }
    }));
}
function createComputedStyle(element) {
    const [style, setStyle] = (0, _solidJs.createSignal)();
    (0, _solidJs.createEffect)(()=>{
        const el = element();
        el && setStyle((0, _utils.getWindow)(el).getComputedStyle(el));
    });
    return style;
}
/**
 * The wrapper component that positions the popper content relative to the popper anchor.
 */ function PopperPositioner(props) {
    const context = usePopperContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style"
    ]);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setPositionerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        "data-popper-positioner": "",
        get style () {
            return {
                position: "absolute",
                top: 0,
                left: 0,
                "min-width": "max-content",
                ...local.style
            };
        }
    }, others));
}
function createDOMRect(anchorRect) {
    const { x =0 , y =0 , width =0 , height =0  } = anchorRect ?? {};
    if (typeof DOMRect === "function") return new DOMRect(x, y, width, height);
    // JSDOM doesn't support DOMRect constructor.
    const rect = {
        x,
        y,
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x
    };
    return {
        ...rect,
        toJSON: ()=>rect
    };
}
function getAnchorElement(anchor, getAnchorRect) {
    // https://floating-ui.com/docs/virtual-elements
    const contextElement = anchor;
    return {
        contextElement,
        getBoundingClientRect: ()=>{
            const anchorRect = getAnchorRect(anchor);
            if (anchorRect) return createDOMRect(anchorRect);
            if (anchor) return anchor.getBoundingClientRect();
            return createDOMRect();
        }
    };
}
function isValidPlacement(flip) {
    return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip);
}
const REVERSE_BASE_PLACEMENT = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
};
function getTransformOrigin(placement, readingDirection) {
    const [basePlacement, alignment] = placement.split("-");
    const reversePlacement = REVERSE_BASE_PLACEMENT[basePlacement];
    if (!alignment) return `${reversePlacement} center`;
    if (basePlacement === "left" || basePlacement === "right") return `${reversePlacement} ${alignment === "start" ? "top" : "bottom"}`;
    if (alignment === "start") return `${reversePlacement} ${readingDirection === "rtl" ? "right" : "left"}`;
    return `${reversePlacement} ${readingDirection === "rtl" ? "left" : "right"}`;
}
/**
 * Display a floating content relative to an anchor element with an optional arrow.
 */ function PopperRoot(props) {
    props = (0, _utils.mergeDefaultProps)({
        getAnchorRect: (anchor)=>anchor?.getBoundingClientRect(),
        placement: "bottom",
        gutter: 0,
        shift: 0,
        flip: true,
        slide: true,
        overlap: false,
        sameWidth: false,
        fitViewport: false,
        hideWhenDetached: false,
        detachedPadding: 0,
        arrowPadding: 4,
        overflowPadding: 8
    }, props);
    const [positionerRef, setPositionerRef] = (0, _solidJs.createSignal)();
    const [arrowRef, setArrowRef] = (0, _solidJs.createSignal)();
    const [currentPlacement, setCurrentPlacement] = (0, _solidJs.createSignal)(props.placement);
    // Floating UI - reference element.
    const anchorRef = ()=>getAnchorElement(props.anchorRef(), props.getAnchorRect);
    const { direction  } = useLocale();
    async function updatePosition() {
        const referenceEl = anchorRef();
        const floatingEl = positionerRef();
        const arrowEl = arrowRef();
        if (!referenceEl || !floatingEl) return;
        const arrowOffset = (arrowEl?.clientHeight || 0) / 2;
        const finalGutter = typeof props.gutter === "number" ? props.gutter + arrowOffset : props.gutter ?? arrowOffset;
        floatingEl.style.setProperty("--kb-popper-content-overflow-padding", `${props.overflowPadding}px`);
        // Virtual element doesn't work without this ¯\_(ツ)_/¯
        referenceEl.getBoundingClientRect();
        const middleware = [
            // https://floating-ui.com/docs/offset
            (0, _dom.offset)(({ placement  })=>{
                // If there's no placement alignment (*-start or *-end), we'll
                // fall back to the crossAxis offset as it also works for
                // center-aligned placements.
                const hasAlignment = !!placement.split("-")[1];
                return {
                    mainAxis: finalGutter,
                    crossAxis: !hasAlignment ? props.shift : undefined,
                    alignmentAxis: props.shift
                };
            })
        ];
        if (props.flip !== false) {
            const fallbackPlacements = typeof props.flip === "string" ? props.flip.split(" ") : undefined;
            if (fallbackPlacements !== undefined && !fallbackPlacements.every(isValidPlacement)) throw new Error("`flip` expects a spaced-delimited list of placements");
            // https://floating-ui.com/docs/flip
            middleware.push((0, _dom.flip)({
                padding: props.overflowPadding,
                fallbackPlacements: fallbackPlacements
            }));
        }
        if (props.slide || props.overlap) // https://floating-ui.com/docs/shift
        middleware.push((0, _dom.shift)({
            mainAxis: props.slide,
            crossAxis: props.overlap,
            padding: props.overflowPadding
        }));
        // https://floating-ui.com/docs/size
        middleware.push((0, _dom.size)({
            padding: props.overflowPadding,
            apply ({ availableWidth , availableHeight , rects  }) {
                const referenceWidth = Math.round(rects.reference.width);
                availableWidth = Math.floor(availableWidth);
                availableHeight = Math.floor(availableHeight);
                floatingEl.style.setProperty("--kb-popper-anchor-width", `${referenceWidth}px`);
                floatingEl.style.setProperty("--kb-popper-content-available-width", `${availableWidth}px`);
                floatingEl.style.setProperty("--kb-popper-content-available-height", `${availableHeight}px`);
                if (props.sameWidth) floatingEl.style.width = `${referenceWidth}px`;
                if (props.fitViewport) {
                    floatingEl.style.maxWidth = `${availableWidth}px`;
                    floatingEl.style.maxHeight = `${availableHeight}px`;
                }
            }
        }));
        // https://floating-ui.com/docs/hide
        if (props.hideWhenDetached) middleware.push((0, _dom.hide)({
            padding: props.detachedPadding
        }));
        // https://floating-ui.com/docs/arrow
        if (arrowEl) middleware.push((0, _dom.arrow)({
            element: arrowEl,
            padding: props.arrowPadding
        }));
        // https://floating-ui.com/docs/computePosition
        const pos = await (0, _dom.computePosition)(referenceEl, floatingEl, {
            placement: props.placement,
            strategy: "absolute",
            middleware,
            platform: {
                ...(0, _dom.platform),
                isRTL: ()=>direction() === "rtl"
            }
        });
        // Sync the new updated placement of floating-ui with our current placement and notify parent.
        setCurrentPlacement(pos.placement);
        props.onCurrentPlacementChange?.(pos.placement);
        if (!floatingEl) return;
        floatingEl.style.setProperty("--kb-popper-content-transform-origin", getTransformOrigin(pos.placement, direction()));
        const x = Math.round(pos.x);
        const y = Math.round(pos.y);
        let visibility;
        if (props.hideWhenDetached) visibility = pos.middlewareData.hide?.referenceHidden ? "hidden" : "visible";
        // https://floating-ui.com/docs/misc#subpixel-and-accelerated-positioning
        Object.assign(floatingEl.style, {
            top: "0",
            left: "0",
            transform: `translate3d(${x}px, ${y}px, 0)`,
            visibility
        });
        // https://floating-ui.com/docs/arrow#usage
        if (arrowEl && pos.middlewareData.arrow) {
            const { x: arrowX , y: arrowY  } = pos.middlewareData.arrow;
            const dir = pos.placement.split("-")[0];
            Object.assign(arrowEl.style, {
                left: arrowX != null ? `${arrowX}px` : "",
                top: arrowY != null ? `${arrowY}px` : "",
                [dir]: "100%"
            });
        }
    }
    (0, _solidJs.createEffect)(()=>{
        const referenceEl = anchorRef();
        const floatingEl = positionerRef();
        if (!referenceEl || !floatingEl) return;
        // https://floating-ui.com/docs/autoUpdate
        const cleanupAutoUpdate = (0, _dom.autoUpdate)(referenceEl, floatingEl, updatePosition, {
            // JSDOM doesn't support ResizeObserver
            elementResize: typeof ResizeObserver === "function"
        });
        (0, _solidJs.onCleanup)(cleanupAutoUpdate);
    });
    // Makes sure the positioner element has the same z-index as the popper content element,
    // so users only need to set the z-index once.
    (0, _solidJs.createEffect)(()=>{
        const positioner = positionerRef();
        const content = props.contentRef();
        if (!positioner || !content) return;
        queueMicrotask(()=>{
            positioner.style.zIndex = getComputedStyle(content).zIndex;
        });
    });
    const context = {
        currentPlacement,
        contentRef: ()=>props.contentRef(),
        setPositionerRef,
        setArrowRef
    };
    return (0, _web.createComponent)(PopperContext.Provider, {
        value: context,
        get children () {
            return props.children;
        }
    });
}
const ComboboxContext = (0, _solidJs.createContext)();
function useComboboxContext() {
    const context = (0, _solidJs.useContext)(ComboboxContext);
    if (context === undefined) throw new Error("[kobalte]: `useComboboxContext` must be used within a `Combobox` component");
    return context;
}
/**
 * The component that pops out when the combobox is open.
 */ function ComboboxContent(props) {
    let ref;
    const context = useComboboxContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "style",
        "onCloseAutoFocus",
        "onFocusOutside"
    ]);
    const close = ()=>{
        context.resetInputValue(context.listState().selectionManager().selectedKeys());
        context.close();
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        // When focus is trapped (in modal mode), a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.isOpen() && context.isModal()) e.preventDefault();
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: ()=>!(context.isOpen() && context.isModal()),
        targets: ()=>{
            const excludedElements = [];
            if (ref) excludedElements.push(ref);
            const controlEl = context.controlRef();
            if (controlEl) excludedElements.push(controlEl);
            return excludedElements;
        }
    });
    createPreventScroll({
        ownerRef: ()=>ref,
        isDisabled: ()=>!(context.isOpen() && context.preventScroll())
    });
    createFocusScope({
        trapFocus: ()=>context.isOpen() && context.isModal(),
        onMountAutoFocus: (e)=>{
            // We prevent open autofocus because it's handled by the `Listbox`.
            e.preventDefault();
        },
        onUnmountAutoFocus: (e)=>{
            local.onCloseAutoFocus?.(e);
            if (!e.defaultPrevented) {
                (0, _utils.focusWithoutScrolling)(context.inputRef());
                e.preventDefault();
            }
        }
    }, ()=>ref);
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                                ref = el;
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        get disableOutsidePointerEvents () {
                            return (0, _web.memo)(()=>!!context.isModal())() && context.isOpen();
                        },
                        get excludedElements () {
                            return [
                                context.controlRef
                            ];
                        },
                        get style () {
                            return {
                                "--kb-combobox-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        onFocusOutside: onFocusOutside,
                        onDismiss: close
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
function ComboboxInput(props) {
    let ref;
    const formControlContext = useFormControlContext();
    const context = useComboboxContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("input")
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "disabled",
        "onInput",
        "onPointerDown",
        "onClick",
        "onKeyDown",
        "onFocus",
        "onBlur"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const collection = ()=>context.listState().collection();
    const selectionManager = ()=>context.listState().selectionManager();
    const isDisabled = ()=>{
        return local.disabled || context.isDisabled() || formControlContext.isDisabled();
    };
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    const onInput = (e)=>{
        (0, _utils.callHandler)(e, local.onInput);
        if (formControlContext.isReadOnly() || isDisabled()) return;
        const target = e.target;
        context.setInputValue(target.value);
        // Unlike in React, inputs `value` can be out of sync with our value state.
        // even if an input is controlled (ex: `<input value="foo" />`,
        // typing on the input will change its internal `value`.
        //
        // To prevent this, we need to force the input `value` to be in sync with the input value state.
        target.value = context.inputValue() ?? "";
        if (context.isOpen()) {
            if (collection().getSize() <= 0 && !context.allowsEmptyCollection()) context.close();
        } else if (collection().getSize() > 0) context.open(false, "input");
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (formControlContext.isReadOnly() || isDisabled()) return;
        if (context.isOpen()) (0, _utils.callHandler)(e, context.onInputKeyDown);
        switch(e.key){
            case "Enter":
                // Prevent form submission if menu is open since we may be selecting an option.
                if (context.isOpen()) {
                    e.preventDefault();
                    const focusedKey = selectionManager().focusedKey();
                    if (focusedKey != null) selectionManager().select(focusedKey);
                }
                break;
            case "Tab":
                if (context.isOpen()) {
                    context.close();
                    context.resetInputValue(context.listState().selectionManager().selectedKeys());
                }
                break;
            case "Escape":
                if (context.isOpen()) {
                    context.close();
                    context.resetInputValue(context.listState().selectionManager().selectedKeys());
                } else // trigger a remove selection.
                context.setInputValue("");
                break;
            case "ArrowDown":
                if (!context.isOpen()) context.open(e.altKey ? false : "first", "manual");
                break;
            case "ArrowUp":
                if (!context.isOpen()) context.open("last", "manual");
                else if (e.altKey) {
                    context.close();
                    context.resetInputValue(context.listState().selectionManager().selectedKeys());
                }
                break;
            case "ArrowLeft":
            case "ArrowRight":
                selectionManager().setFocusedKey(undefined);
                break;
            case "Backspace":
                // Remove last selection in multiple mode if input is empty.
                if (context.removeOnBackspace() && selectionManager().selectionMode() === "multiple" && context.inputValue() === "") {
                    const lastSelectedKey = [
                        ...selectionManager().selectedKeys()
                    ].pop() ?? "";
                    selectionManager().toggleSelection(lastSelectedKey);
                }
                break;
        }
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        if (context.isInputFocused()) return;
        context.setIsInputFocused(true);
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        // Ignore blur if focused moved into the control or menu.
        if ((0, _utils.contains)(context.controlRef(), e.relatedTarget) || (0, _utils.contains)(context.contentRef(), e.relatedTarget)) return;
        context.setIsInputFocused(false);
    };
    // If a touch happens on direct center of Combobox input, might be virtual click from iPad so open ComboBox menu
    let lastEventTime = 0;
    const onTouchEnd = (e)=>{
        if (!ref || formControlContext.isReadOnly() || isDisabled()) return;
        // Sometimes VoiceOver on iOS fires two touchend events in quick succession. Ignore the second one.
        if (e.timeStamp - lastEventTime < 500) {
            e.preventDefault();
            ref.focus();
            return;
        }
        const rect = e.target.getBoundingClientRect();
        const touch = e.changedTouches[0];
        const centerX = Math.ceil(rect.left + 0.5 * rect.width);
        const centerY = Math.ceil(rect.top + 0.5 * rect.height);
        if (touch.clientX === centerX && touch.clientY === centerY) {
            e.preventDefault();
            ref.focus();
            context.toggle(false, "manual");
            lastEventTime = e.timeStamp;
        }
    };
    // Omit `formControlContext.name()` here because it's used in the hidden select.
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "input",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                context.setInputRef(el);
                ref = el;
            }, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return fieldProps.id();
        },
        get value () {
            return context.inputValue();
        },
        get required () {
            return formControlContext.isRequired();
        },
        get disabled () {
            return formControlContext.isDisabled();
        },
        get readonly () {
            return formControlContext.isReadOnly();
        },
        get placeholder () {
            return context.placeholder();
        },
        type: "text",
        role: "combobox",
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        "aria-haspopup": "listbox",
        "aria-autocomplete": "list",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.listboxId() : undefined;
        },
        get ["aria-activedescendant"] () {
            return context.activeDescendant();
        },
        get ["aria-label"] () {
            return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"] () {
            return fieldProps.ariaLabelledBy();
        },
        get ["aria-describedby"] () {
            return fieldProps.ariaDescribedBy();
        },
        get ["aria-invalid"] () {
            return formControlContext.validationState() === "invalid" || undefined;
        },
        get ["aria-required"] () {
            return formControlContext.isRequired() || undefined;
        },
        get ["aria-disabled"] () {
            return formControlContext.isDisabled() || undefined;
        },
        get ["aria-readonly"] () {
            return formControlContext.isReadOnly() || undefined;
        },
        onInput: onInput,
        onKeyDown: onKeyDown,
        onFocus: onFocus,
        onBlur: onBlur,
        onTouchEnd: onTouchEnd
    }, ()=>context.dataset(), ()=>formControlContext.dataset(), others));
}
const ListboxContext = (0, _solidJs.createContext)();
function useListboxContext() {
    const context = (0, _solidJs.useContext)(ListboxContext);
    if (context === undefined) throw new Error("[kobalte]: `useListboxContext` must be used within a `Listbox` component");
    return context;
}
const ListboxItemContext = (0, _solidJs.createContext)();
function useListboxItemContext() {
    const context = (0, _solidJs.useContext)(ListboxItemContext);
    if (context === undefined) throw new Error("[kobalte]: `useListboxItemContext` must be used within a `Listbox.Item` component");
    return context;
}
/**
 * An item of the listbox.
 */ function ListboxItem(props) {
    let ref;
    const listBoxContext = useListboxContext();
    const defaultId = `${listBoxContext.generateId("item")}-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "item",
        "aria-label",
        "aria-labelledby",
        "aria-describedby",
        "onPointerMove",
        "onPointerDown",
        "onPointerUp",
        "onClick",
        "onKeyDown",
        "onMouseDown",
        "onFocus"
    ]);
    const [labelId, setLabelId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const selectionManager = ()=>listBoxContext.listState().selectionManager();
    const isHighlighted = ()=>selectionManager().focusedKey() === local.item.key;
    const selectableItem = createSelectableItem({
        key: ()=>local.item.key,
        selectionManager: selectionManager,
        shouldSelectOnPressUp: listBoxContext.shouldSelectOnPressUp,
        allowsDifferentPressOrigin: ()=>{
            return listBoxContext.shouldSelectOnPressUp() && listBoxContext.shouldFocusOnHover();
        },
        shouldUseVirtualFocus: listBoxContext.shouldUseVirtualFocus,
        disabled: ()=>local.item.disabled
    }, ()=>ref);
    const ariaSelected = ()=>{
        if (selectionManager().selectionMode() === "none") return undefined;
        return selectableItem.isSelected();
    };
    // Safari with VoiceOver on macOS misreads options with aria-labelledby or aria-label as simply "text".
    // We should not map slots to the label and description on Safari and instead just have VoiceOver read the textContent.
    // https://bugs.webkit.org/show_bug.cgi?id=209279
    const isNotSafariMacOS = (0, _solidJs.createMemo)(()=>!((0, _utils.isMac)() && (0, _utils.isWebKit)()));
    const ariaLabel = ()=>isNotSafariMacOS() ? local["aria-label"] : undefined;
    const ariaLabelledBy = ()=>isNotSafariMacOS() ? labelId() : undefined;
    const ariaDescribedBy = ()=>isNotSafariMacOS() ? descriptionId() : undefined;
    const ariaPosInSet = ()=>{
        if (!listBoxContext.isVirtualized()) return undefined;
        const index = listBoxContext.listState().collection().getItem(local.item.key)?.index;
        return index != null ? index + 1 : undefined;
    };
    const ariaSetSize = ()=>{
        if (!listBoxContext.isVirtualized()) return undefined;
        return getItemCount(listBoxContext.listState().collection());
    };
    /**
   * We focus items on `pointerMove` to achieve the following:
   *
   * - Mouse over an item (it focuses)
   * - Leave mouse where it is and use keyboard to focus a different item
   * - Wiggle mouse without it leaving previously focused item
   * - Previously focused item should re-focus
   *
   * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse
   * wiggles. This is to match native select implementation.
   */ const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (e.pointerType !== "mouse") return;
        if (!selectableItem.isDisabled() && listBoxContext.shouldFocusOnHover()) {
            (0, _utils.focusWithoutScrolling)(e.currentTarget);
            selectionManager().setFocused(true);
            selectionManager().setFocusedKey(local.item.key);
        }
    };
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-disabled": selectableItem.isDisabled() ? "" : undefined,
            "data-selected": selectableItem.isSelected() ? "" : undefined,
            "data-highlighted": isHighlighted() ? "" : undefined
        }));
    const context = {
        isSelected: selectableItem.isSelected,
        dataset,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerLabelId: createRegisterId(setLabelId),
        registerDescriptionId: createRegisterId(setDescriptionId)
    };
    return (0, _web.createComponent)(ListboxItemContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "li",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                role: "option",
                get tabIndex () {
                    return selectableItem.tabIndex();
                },
                get ["aria-disabled"] () {
                    return selectableItem.isDisabled();
                },
                get ["aria-selected"] () {
                    return ariaSelected();
                },
                get ["aria-label"] () {
                    return ariaLabel();
                },
                get ["aria-labelledby"] () {
                    return ariaLabelledBy();
                },
                get ["aria-describedby"] () {
                    return ariaDescribedBy();
                },
                get ["aria-posinset"] () {
                    return ariaPosInSet();
                },
                get ["aria-setsize"] () {
                    return ariaSetSize();
                },
                get ["data-key"] () {
                    return selectableItem.dataKey();
                },
                get onPointerDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onPointerDown,
                        selectableItem.onPointerDown
                    ]);
                },
                get onPointerUp () {
                    return (0, _utils.composeEventHandlers)([
                        local.onPointerUp,
                        selectableItem.onPointerUp
                    ]);
                },
                get onClick () {
                    return (0, _utils.composeEventHandlers)([
                        local.onClick,
                        selectableItem.onClick
                    ]);
                },
                get onKeyDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onKeyDown,
                        selectableItem.onKeyDown
                    ]);
                },
                get onMouseDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onMouseDown,
                        selectableItem.onMouseDown
                    ]);
                },
                get onFocus () {
                    return (0, _utils.composeEventHandlers)([
                        local.onFocus,
                        selectableItem.onFocus
                    ]);
                },
                onPointerMove: onPointerMove
            }, dataset, others));
        }
    });
}
/**
 * An optional accessible description to be announced for the item.
 * Useful for items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */ function ListboxItemDescription(props) {
    const context = useListboxItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescriptionId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * The visual indicator rendered when the item is selected.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */ function ListboxItemIndicator(props) {
    const context = useListboxItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("indicator")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "forceMount"
    ]);
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return local.forceMount || context.isSelected();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                "aria-hidden": "true"
            }, ()=>context.dataset(), others));
        }
    });
}
/**
 * An accessible label to be announced for the item.
 * Useful for items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */ function ListboxItemLabel(props) {
    const context = useListboxItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("label")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerLabelId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * Listbox presents a list of options and allows a user to select one or more of them.
 */ function ListboxRoot(props) {
    let ref;
    const defaultId = `listbox-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        selectionMode: "single",
        virtualized: false
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "children",
        "renderItem",
        "renderSection",
        "value",
        "defaultValue",
        "onChange",
        "options",
        "optionValue",
        "optionTextValue",
        "optionDisabled",
        "optionGroupChildren",
        "state",
        "keyboardDelegate",
        "autoFocus",
        "selectionMode",
        "shouldFocusWrap",
        "shouldUseVirtualFocus",
        "shouldSelectOnPressUp",
        "shouldFocusOnHover",
        "allowDuplicateSelectionEvents",
        "disallowEmptySelection",
        "selectionBehavior",
        "selectOnFocus",
        "disallowTypeAhead",
        "allowsTabNavigation",
        "virtualized",
        "scrollToItem",
        "scrollRef",
        "onKeyDown",
        "onMouseDown",
        "onFocusIn",
        "onFocusOut"
    ]);
    const listState = (0, _solidJs.createMemo)(()=>{
        if (local.state) return local.state;
        return createListState({
            selectedKeys: ()=>local.value,
            defaultSelectedKeys: ()=>local.defaultValue,
            onSelectionChange: local.onChange,
            allowDuplicateSelectionEvents: ()=>(0, _utils.access)(local.allowDuplicateSelectionEvents),
            disallowEmptySelection: ()=>(0, _utils.access)(local.disallowEmptySelection),
            selectionBehavior: ()=>(0, _utils.access)(local.selectionBehavior),
            selectionMode: ()=>(0, _utils.access)(local.selectionMode),
            dataSource: ()=>local.options ?? [],
            getKey: ()=>local.optionValue,
            getTextValue: ()=>local.optionTextValue,
            getDisabled: ()=>local.optionDisabled,
            getSectionChildren: ()=>local.optionGroupChildren
        });
    });
    const selectableList = createSelectableList({
        selectionManager: ()=>listState().selectionManager(),
        collection: ()=>listState().collection(),
        autoFocus: ()=>(0, _utils.access)(local.autoFocus),
        shouldFocusWrap: ()=>(0, _utils.access)(local.shouldFocusWrap),
        keyboardDelegate: ()=>local.keyboardDelegate,
        disallowEmptySelection: ()=>(0, _utils.access)(local.disallowEmptySelection),
        selectOnFocus: ()=>(0, _utils.access)(local.selectOnFocus),
        disallowTypeAhead: ()=>(0, _utils.access)(local.disallowTypeAhead),
        shouldUseVirtualFocus: ()=>(0, _utils.access)(local.shouldUseVirtualFocus),
        allowsTabNavigation: ()=>(0, _utils.access)(local.allowsTabNavigation),
        isVirtualized: ()=>local.virtualized,
        scrollToKey: ()=>local.scrollToItem
    }, ()=>ref, ()=>local.scrollRef?.());
    const context = {
        listState,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        shouldUseVirtualFocus: ()=>props.shouldUseVirtualFocus,
        shouldSelectOnPressUp: ()=>props.shouldSelectOnPressUp,
        shouldFocusOnHover: ()=>props.shouldFocusOnHover,
        isVirtualized: ()=>local.virtualized
    };
    return (0, _web.createComponent)(ListboxContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "ul",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                role: "listbox",
                get tabIndex () {
                    return selectableList.tabIndex();
                },
                get ["aria-multiselectable"] () {
                    return listState().selectionManager().selectionMode() === "multiple" ? true : undefined;
                },
                get onKeyDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onKeyDown,
                        selectableList.onKeyDown
                    ]);
                },
                get onMouseDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onMouseDown,
                        selectableList.onMouseDown
                    ]);
                },
                get onFocusIn () {
                    return (0, _utils.composeEventHandlers)([
                        local.onFocusIn,
                        selectableList.onFocusIn
                    ]);
                },
                get onFocusOut () {
                    return (0, _utils.composeEventHandlers)([
                        local.onFocusOut,
                        selectableList.onFocusOut
                    ]);
                }
            }, others, {
                get children () {
                    return (0, _web.createComponent)((0, _solidJs.Show), {
                        get when () {
                            return !local.virtualized;
                        },
                        get fallback () {
                            return local.children?.(listState().collection);
                        },
                        get children () {
                            return (0, _web.createComponent)((0, _utils.Key), {
                                get each () {
                                    return [
                                        ...listState().collection()
                                    ];
                                },
                                by: "key",
                                children: (item)=>(0, _web.createComponent)((0, _solidJs.Switch), {
                                        get children () {
                                            return [
                                                (0, _web.createComponent)((0, _solidJs.Match), {
                                                    get when () {
                                                        return item().type === "section";
                                                    },
                                                    get children () {
                                                        return local.renderSection?.(item());
                                                    }
                                                }),
                                                (0, _web.createComponent)((0, _solidJs.Match), {
                                                    get when () {
                                                        return item().type === "item";
                                                    },
                                                    get children () {
                                                        return local.renderItem?.(item());
                                                    }
                                                })
                                            ];
                                        }
                                    })
                            });
                        }
                    });
                }
            }));
        }
    });
}
/**
 * A component used to render the label of a listbox option group.
 * It won't be focusable using arrow keys.
 */ function ListboxSection(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "li",
        role: "presentation"
    }, props));
}
var index$k = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Item: ListboxItem,
    ItemDescription: ListboxItemDescription,
    ItemIndicator: ListboxItemIndicator,
    ItemLabel: ListboxItemLabel,
    Root: ListboxRoot,
    Section: ListboxSection
});
/**
 * Contains all the items of a `Combobox`.
 */ function ComboboxListbox(props) {
    const formControlContext = useFormControlContext();
    const context = useComboboxContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("listbox")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref"
    ]);
    const ariaLabelledBy = ()=>{
        return formControlContext.getAriaLabelledBy(others.id, context.listboxAriaLabel(), undefined);
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerListboxId(others.id)));
    return (0, _web.createComponent)(ListboxRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setListboxRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get state () {
            return context.listState();
        },
        get autoFocus () {
            return context.autoFocus();
        },
        shouldUseVirtualFocus: true,
        shouldSelectOnPressUp: true,
        shouldFocusOnHover: true,
        get ["aria-label"] () {
            return context.listboxAriaLabel();
        },
        get ["aria-labelledby"] () {
            return ariaLabelledBy();
        },
        get renderItem () {
            return context.renderItem;
        },
        get renderSection () {
            return context.renderSection;
        }
    }, others));
}
/**
 * Portals its children into the `body` when the combobox is open.
 */ function ComboboxPortal(props) {
    const context = useComboboxContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
/**
 * Contains the combobox input and trigger.
 */ function ComboboxControl(props) {
    const formControlContext = useFormControlContext();
    const context = useComboboxContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "children"
    ]);
    const selectionManager = ()=>context.listState().selectionManager();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setControlRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        }
    }, ()=>context.dataset(), ()=>formControlContext.dataset(), others, {
        get children () {
            return (0, _web.createComponent)(ComboboxControlChild, {
                state: {
                    selectedOptions: ()=>context.selectedOptions(),
                    remove: (option)=>context.removeOptionFromSelection(option),
                    clear: ()=>selectionManager().clearSelection()
                },
                get children () {
                    return local.children;
                }
            });
        }
    }));
}
function ComboboxControlChild(props) {
    const resolvedChildren = (0, _solidJs.children)(()=>{
        const body = props.children;
        return (0, _utils.isFunction)(body) ? body(props.state) : body;
    });
    return (0, _web.memo)(resolvedChildren);
}
const _tmpl$$e = /*#__PURE__*/ (0, _web.template)(`<option>`), _tmpl$2 = /*#__PURE__*/ (0, _web.template)(`<div aria-hidden="true"><input type="text"><select tabindex="-1"><option>`);
// In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
// In Firefox, there must be a <label> to identify the <select> whereas other browsers
// seem to identify it just by surrounding text.
// The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
// 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
// non tabbable with tabIndex={-1}.
//
// In mobile browsers, there are next/previous buttons above the software keyboard for navigating
// between fields in a form. These only support native form inputs that are tabbable. In order to
// support those, an additional hidden input is used to marshall focus to the button. It is tabbable
// except when the button is focused, so that shift tab works properly to go to the actual previous
// input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
// the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
// prevent Safari from zooming in on the input when it is focused.
//
// If the current interaction modality is null, then the user hasn't interacted with the page yet.
// In this case, we set the tabIndex to -1 on the input element so that automated accessibility
// checkers don't throw false-positives about focusable elements inside an aria-hidden parent.
/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */ function HiddenSelectBase(props) {
    let ref;
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onChange",
        "collection",
        "selectionManager",
        "isOpen",
        "isMultiple",
        "isVirtualized",
        "focusTrigger"
    ]);
    const formControlContext = useFormControlContext();
    const [isInternalChangeEvent, setIsInternalChangeEvent] = (0, _solidJs.createSignal)(false);
    const renderOption = (key)=>{
        const item = local.collection.getItem(key);
        return (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return item?.type === "item";
            },
            get children () {
                const _el$ = _tmpl$$e();
                _el$.value = key;
                (0, _web.insert)(_el$, ()=>item?.textValue);
                (0, _web.effect)(()=>_el$.selected = local.selectionManager.isSelected(key));
                return _el$;
            }
        });
    };
    // Dispatch native event on selection change for form libraries.
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>local.selectionManager.selectedKeys(), (keys, prevKeys)=>{
        if (prevKeys && isSameSelection(keys, prevKeys)) return;
        setIsInternalChangeEvent(true);
        ref?.dispatchEvent(new Event("input", {
            bubbles: true,
            cancelable: true
        }));
        ref?.dispatchEvent(new Event("change", {
            bubbles: true,
            cancelable: true
        }));
    }, {
        defer: true
    }));
    // If virtualized, only render the selected options in the hidden <select> so the value can be submitted to a server.
    // Otherwise, render all options so that browser autofill will work.
    return (()=>{
        const _el$2 = _tmpl$2(), _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling;
        _el$4.firstChild;
        _el$3.addEventListener("focus", ()=>local.focusTrigger());
        _el$3.style.setProperty("font-size", "16px");
        _el$4.addEventListener("change", (e)=>{
            (0, _utils.callHandler)(e, local.onChange);
            // Prevent internally fired change event to update the selection
            // which would result in an infinite loop.
            if (!isInternalChangeEvent()) // enable form autofill
            local.selectionManager.setSelectedKeys(new Set([
                e.target.value
            ]));
            setIsInternalChangeEvent(false);
        });
        const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
        typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$4);
        (0, _web.spread)(_el$4, (0, _web.mergeProps)({
            get multiple () {
                return local.isMultiple;
            },
            get name () {
                return formControlContext.name();
            },
            get required () {
                return formControlContext.isRequired();
            },
            get disabled () {
                return formControlContext.isDisabled();
            },
            get size () {
                return local.collection.getSize();
            },
            get value () {
                return local.selectionManager.firstSelectedKey() ?? "";
            }
        }, others), false, true);
        (0, _web.insert)(_el$4, (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return local.isVirtualized;
            },
            get fallback () {
                return (0, _web.createComponent)((0, _solidJs.For), {
                    get each () {
                        return [
                            ...local.collection.getKeys()
                        ];
                    },
                    children: renderOption
                });
            },
            get children () {
                return (0, _web.createComponent)((0, _solidJs.For), {
                    get each () {
                        return [
                            ...local.selectionManager.selectedKeys()
                        ];
                    },
                    children: renderOption
                });
            }
        }), null);
        (0, _web.effect)((_p$)=>{
            const _v$ = (0, _utils.visuallyHiddenStyles), _v$2 = local.selectionManager.isFocused() || local.isOpen ? -1 : 0, _v$3 = formControlContext.isRequired(), _v$4 = formControlContext.isDisabled(), _v$5 = formControlContext.isReadOnly();
            _p$._v$ = (0, _web.style)(_el$2, _v$, _p$._v$);
            _v$2 !== _p$._v$2 && (0, _web.setAttribute)(_el$3, "tabindex", _p$._v$2 = _v$2);
            _v$3 !== _p$._v$3 && (_el$3.required = _p$._v$3 = _v$3);
            _v$4 !== _p$._v$4 && (_el$3.disabled = _p$._v$4 = _v$4);
            _v$5 !== _p$._v$5 && (_el$3.readOnly = _p$._v$5 = _v$5);
            return _p$;
        }, {
            _v$: undefined,
            _v$2: undefined,
            _v$3: undefined,
            _v$4: undefined,
            _v$5: undefined
        });
        return _el$2;
    })();
}
function ComboboxHiddenSelect(props) {
    const context = useComboboxContext();
    return (0, _web.createComponent)(HiddenSelectBase, (0, _web.mergeProps)({
        get collection () {
            return context.listState().collection();
        },
        get selectionManager () {
            return context.listState().selectionManager();
        },
        get isOpen () {
            return context.isOpen();
        },
        get isMultiple () {
            return context.isMultiple();
        },
        get isVirtualized () {
            return context.isVirtualized();
        },
        focusTrigger: ()=>context.inputRef()?.focus()
    }, props));
}
/**
 * A small icon often displayed next to the value as a visual affordance for the fact it can be open.
 * It renders a `▼` by default, but you can use your own icon `children`.
 */ function ComboboxIcon(props) {
    const context = useComboboxContext();
    props = (0, _utils.mergeDefaultProps)({
        children: "▼"
    }, props);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "span",
        "aria-hidden": "true"
    }, ()=>context.dataset(), props));
}
const COMBOBOX_INTL_TRANSLATIONS = {
    // Annouce option to screen readers on focus.
    focusAnnouncement: (optionText, isSelected)=>`${optionText}${isSelected ? ", selected" : ""}`,
    // Annouce the number of options available to screen readers on open.
    countAnnouncement: (optionCount)=>{
        switch(optionCount){
            case 1:
                return "one option available";
        }
    },
    // Annouce the selection of an option to screen readers.
    selectedAnnouncement: (optionText)=>`${optionText}, selected`,
    // `aria-label` of Combobox.Trigger.
    triggerLabel: "Show suggestions",
    // `aria-label` of Combobox.Listbox.
    listboxLabel: "Suggestions"
};
/**
 * Base component for a combobox, provide context for its children.
 */ function ComboboxBase(props) {
    const defaultId = `combobox-${(0, _solidJs.createUniqueId)()}`;
    const filter = createFilter({
        sensitivity: "base"
    });
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        selectionMode: "single",
        allowsEmptyCollection: false,
        disallowEmptySelection: false,
        allowDuplicateSelectionEvents: true,
        removeOnBackspace: true,
        gutter: 8,
        sameWidth: true,
        modal: false,
        defaultFilter: "contains",
        triggerMode: "input",
        translations: COMBOBOX_INTL_TRANSLATIONS
    }, props);
    const [local, popperProps, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "translations",
        "itemComponent",
        "sectionComponent",
        "open",
        "defaultOpen",
        "onOpenChange",
        "onInputChange",
        "value",
        "defaultValue",
        "onChange",
        "triggerMode",
        "placeholder",
        "options",
        "optionValue",
        "optionTextValue",
        "optionLabel",
        "optionDisabled",
        "optionGroupChildren",
        "keyboardDelegate",
        "allowDuplicateSelectionEvents",
        "disallowEmptySelection",
        "defaultFilter",
        "shouldFocusWrap",
        "allowsEmptyCollection",
        "removeOnBackspace",
        "selectionBehavior",
        "selectionMode",
        "virtualized",
        "modal",
        "preventScroll",
        "forceMount"
    ], [
        "getAnchorRect",
        "placement",
        "gutter",
        "shift",
        "flip",
        "slide",
        "overlap",
        "sameWidth",
        "fitViewport",
        "hideWhenDetached",
        "detachedPadding",
        "arrowPadding",
        "overflowPadding"
    ], FORM_CONTROL_PROP_NAMES);
    const [listboxId, setListboxId] = (0, _solidJs.createSignal)();
    const [controlRef, setControlRef] = (0, _solidJs.createSignal)();
    const [inputRef, setInputRef] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const [listboxRef, setListboxRef] = (0, _solidJs.createSignal)();
    const [focusStrategy, setFocusStrategy] = (0, _solidJs.createSignal)(false);
    const [isInputFocused, setIsInputFocusedState] = (0, _solidJs.createSignal)(false);
    const [showAllOptions, setShowAllOptions] = (0, _solidJs.createSignal)(false);
    const [lastDisplayedOptions, setLastDisplayedOptions] = (0, _solidJs.createSignal)(local.options);
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen, openTriggerMode)
    });
    const [inputValue, setInputValue] = createControllableSignal({
        defaultValue: ()=>"",
        onChange: (value)=>{
            local.onInputChange?.(value);
            // Remove selection when input is cleared and value is uncontrolled (in single selection mode).
            // If controlled, this is the application developer's responsibility.
            if (value === "" && local.selectionMode === "single" && !listState.selectionManager().isEmpty() && local.value === undefined) // Bypass `disallowEmptySelection`.
            listState.selectionManager().setSelectedKeys([]);
            // Clear focused key when input value changes.
            listState.selectionManager().setFocusedKey(undefined);
        }
    });
    const getOptionValue = (option)=>{
        const optionValue = local.optionValue;
        if (optionValue == null) // If no `optionValue`, the option itself is the value (ex: string[] of options).
        return String(option);
        // Get the value from the option object as a string.
        return String((0, _utils.isFunction)(optionValue) ? optionValue(option) : option[optionValue]);
    };
    const getOptionLabel = (option)=>{
        const optionLabel = local.optionLabel;
        if (optionLabel == null) // If no `optionLabel`, the option itself is the label (ex: string[] of options).
        return String(option);
        // Get the label from the option object as a string.
        return String((0, _utils.isFunction)(optionLabel) ? optionLabel(option) : option[optionLabel]);
    };
    // All options flattened without option groups.
    const allOptions = (0, _solidJs.createMemo)(()=>{
        const optionGroupChildren = local.optionGroupChildren;
        // The combobox doesn't contains option groups.
        if (optionGroupChildren == null) return local.options;
        return local.options.flatMap((item)=>item[optionGroupChildren] ?? item);
    });
    const filterFn = (option)=>{
        const inputVal = inputValue() ?? "";
        if ((0, _utils.isFunction)(local.defaultFilter)) return local.defaultFilter?.(option, inputVal);
        const textVal = getOptionLabel(option);
        switch(local.defaultFilter){
            case "startsWith":
                return filter.startsWith(textVal, inputVal);
            case "endsWith":
                return filter.endsWith(textVal, inputVal);
            case "contains":
                return filter.contains(textVal, inputVal);
        }
    };
    // Filtered options with same structure as `local.options`
    const filteredOptions = (0, _solidJs.createMemo)(()=>{
        const optionGroupChildren = local.optionGroupChildren;
        // The combobox doesn't contains option groups.
        if (optionGroupChildren == null) return local.options.filter(filterFn);
        const filteredGroups = [];
        for (const optGroup of local.options){
            // Filter options of the group
            const filteredChildrenOptions = optGroup[optionGroupChildren].filter(filterFn);
            // Don't add any groups that are empty
            if (filteredChildrenOptions.length === 0) continue;
            // Add the group with the filtered options
            filteredGroups.push({
                ...optGroup,
                [optionGroupChildren]: filteredChildrenOptions
            });
        }
        return filteredGroups;
    });
    const displayedOptions = (0, _solidJs.createMemo)(()=>{
        if (disclosureState.isOpen()) {
            if (showAllOptions()) return local.options;
            else return filteredOptions();
        } else return lastDisplayedOptions();
    });
    // Track what action is attempting to open the combobox.
    let openTriggerMode = "focus";
    const getOptionsFromValues = (values)=>{
        return [
            ...values
        ].map((value)=>allOptions().find((option)=>getOptionValue(option) === value)).filter((option)=>option != null);
    };
    const listState = createListState({
        selectedKeys: ()=>{
            if (local.value != null) return local.value.map(getOptionValue);
            return local.value;
        },
        defaultSelectedKeys: ()=>{
            if (local.defaultValue != null) return local.defaultValue.map(getOptionValue);
            return local.defaultValue;
        },
        onSelectionChange: (selectedKeys)=>{
            local.onChange?.(getOptionsFromValues(selectedKeys));
            if (local.selectionMode === "single") // Only close if an option is selected.
            // Prevents the combobox to close and reopen when the input is cleared.
            {
                if (disclosureState.isOpen() && selectedKeys.size > 0) close();
            }
            const inputEl = inputRef();
            if (inputEl) {
                // Move cursor to the end of the input.
                inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
                (0, _utils.focusWithoutScrolling)(inputEl);
            }
        },
        allowDuplicateSelectionEvents: ()=>(0, _utils.access)(local.allowDuplicateSelectionEvents),
        disallowEmptySelection: ()=>local.disallowEmptySelection,
        selectionBehavior: ()=>(0, _utils.access)(local.selectionBehavior),
        selectionMode: ()=>local.selectionMode,
        dataSource: displayedOptions,
        getKey: ()=>local.optionValue,
        getTextValue: ()=>local.optionTextValue,
        getDisabled: ()=>local.optionDisabled,
        getSectionChildren: ()=>local.optionGroupChildren
    });
    const selectedOptions = (0, _solidJs.createMemo)(()=>{
        return getOptionsFromValues(listState.selectionManager().selectedKeys());
    });
    const removeOptionFromSelection = (option)=>{
        listState.selectionManager().toggleSelection(getOptionValue(option));
    };
    const contentPresence = createPresence(()=>local.forceMount || disclosureState.isOpen());
    const open = (focusStrategy, triggerMode)=>{
        // Show all option if menu is manually opened.
        const showAllOptions = setShowAllOptions(triggerMode === "manual");
        const hasOptions = showAllOptions ? local.options.length > 0 : filteredOptions().length > 0;
        // Don't open if there is no option.
        if (!hasOptions && !local.allowsEmptyCollection) return;
        openTriggerMode = triggerMode;
        setFocusStrategy(focusStrategy);
        disclosureState.open();
        let focusedKey = listState.selectionManager().firstSelectedKey();
        if (focusedKey == null) {
            if (focusStrategy === "first") focusedKey = listState.collection().getFirstKey();
            else if (focusStrategy === "last") focusedKey = listState.collection().getLastKey();
        }
        listState.selectionManager().setFocused(true);
        listState.selectionManager().setFocusedKey(focusedKey);
    };
    const close = ()=>{
        disclosureState.close();
        listState.selectionManager().setFocused(false);
        listState.selectionManager().setFocusedKey(undefined);
    };
    const toggle = (focusStrategy, triggerMode)=>{
        if (disclosureState.isOpen()) close();
        else open(focusStrategy, triggerMode);
    };
    const { formControlContext  } = createFormControl(formControlProps);
    createFormResetListener(inputRef, ()=>{
        const defaultSelectedKeys = local.defaultValue ? [
            ...local.defaultValue
        ].map(getOptionValue) : new Selection();
        listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
    });
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    const delegate = (0, _solidJs.createMemo)(()=>{
        const keyboardDelegate = (0, _utils.access)(local.keyboardDelegate);
        if (keyboardDelegate) return keyboardDelegate;
        return new ListKeyboardDelegate(listState.collection, listboxRef, undefined);
    });
    // Use `createSelectableCollection` to get the keyboard handlers to apply to the input.
    const selectableCollection = createSelectableCollection({
        selectionManager: ()=>listState.selectionManager(),
        keyboardDelegate: delegate,
        disallowTypeAhead: true,
        disallowEmptySelection: true,
        shouldFocusWrap: ()=>local.shouldFocusWrap,
        // Prevent item scroll behavior from being applied here, handled in the Listbox component.
        isVirtualized: true
    }, inputRef);
    const setIsInputFocused = (isFocused)=>{
        if (isFocused && local.triggerMode === "focus") open(false, "focus");
        setIsInputFocusedState(isFocused);
        listState.selectionManager().setFocused(isFocused);
    };
    const activeDescendant = (0, _solidJs.createMemo)(()=>{
        const focusedKey = listState.selectionManager().focusedKey();
        if (focusedKey) return listboxRef()?.querySelector(`[data-key="${focusedKey}"]`)?.id;
        return undefined;
    });
    const resetInputValue = (selectedKeys)=>{
        if (local.selectionMode === "single") {
            const selectedKey = [
                ...selectedKeys
            ][0];
            const selectedOption = allOptions().find((option)=>getOptionValue(option) === selectedKey);
            setInputValue(selectedOption ? getOptionLabel(selectedOption) : "");
        } else setInputValue("");
    };
    const renderItem = (item)=>{
        return local.itemComponent?.({
            item
        });
    };
    const renderSection = (section)=>{
        return local.sectionComponent?.({
            section
        });
    };
    // If combobox is going to close, freeze the displayed options
    // Prevents the popover contents from updating as the combobox closes.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        filteredOptions,
        showAllOptions
    ], (input, prevInput)=>{
        if (disclosureState.isOpen() && prevInput != null) {
            const prevFilteredOptions = prevInput[0];
            const prevShowAllOptions = prevInput[1];
            setLastDisplayedOptions(prevShowAllOptions ? local.options : prevFilteredOptions);
        } else {
            const filteredOptions = input[0];
            const showAllOptions = input[1];
            setLastDisplayedOptions(showAllOptions ? local.options : filteredOptions);
        }
    }));
    // Display filtered collection again when input value changes.
    (0, _solidJs.createEffect)((0, _solidJs.on)(inputValue, ()=>{
        if (showAllOptions()) setShowAllOptions(false);
    }));
    // Reset input value when selection change
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>listState.selectionManager().selectedKeys(), resetInputValue));
    // VoiceOver has issues with announcing aria-activedescendant properly on change.
    // We use a live region announcer to announce focus changes manually.
    let lastAnnouncedFocusedKey = "";
    (0, _solidJs.createEffect)(()=>{
        const focusedKey = listState.selectionManager().focusedKey() ?? "";
        const focusedItem = listState.collection().getItem(focusedKey);
        if ((0, _utils.isAppleDevice)() && focusedItem != null && focusedKey !== lastAnnouncedFocusedKey) {
            const isSelected = listState.selectionManager().isSelected(focusedKey);
            const announcement = local.translations?.focusAnnouncement(focusedItem?.textValue || "", isSelected) ?? "";
            announce(announcement);
        }
        if (focusedKey) lastAnnouncedFocusedKey = focusedKey;
    });
    // Announce the number of available suggestions when it changes.
    let lastOptionCount = getItemCount(listState.collection());
    let lastOpen = disclosureState.isOpen();
    (0, _solidJs.createEffect)(()=>{
        const optionCount = getItemCount(listState.collection());
        const isOpen = disclosureState.isOpen();
        // Only announce the number of options available when the menu opens if there is no
        // focused item, otherwise screen readers will typically read e.g. "1 of 6".
        // The exception is VoiceOver since this isn't included in the message above.
        const didOpenWithoutFocusedItem = isOpen !== lastOpen && (listState.selectionManager().focusedKey() == null || (0, _utils.isAppleDevice)());
        if (isOpen && (didOpenWithoutFocusedItem || optionCount !== lastOptionCount)) {
            const announcement = local.translations?.countAnnouncement(optionCount) ?? "";
            announce(announcement);
        }
        lastOptionCount = optionCount;
        lastOpen = isOpen;
    });
    // Announce when a selection occurs for VoiceOver.
    // Other screen readers typically do this automatically.
    let lastAnnouncedSelectedKey = "";
    (0, _solidJs.createEffect)(()=>{
        const lastSelectedKey = [
            ...listState.selectionManager().selectedKeys()
        ].pop() ?? "";
        const lastSelectedItem = listState.collection().getItem(lastSelectedKey);
        if ((0, _utils.isAppleDevice)() && isInputFocused() && lastSelectedItem && lastSelectedKey !== lastAnnouncedSelectedKey) {
            const announcement = local.translations?.selectedAnnouncement(lastSelectedItem?.textValue || "") ?? "";
            announce(announcement);
        }
        if (lastSelectedKey) lastAnnouncedSelectedKey = lastSelectedKey;
    });
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        isDisabled: ()=>formControlContext.isDisabled() ?? false,
        isMultiple: ()=>(0, _utils.access)(local.selectionMode) === "multiple",
        isVirtualized: ()=>local.virtualized ?? false,
        isModal: ()=>local.modal ?? false,
        preventScroll: ()=>local.preventScroll ?? context.isModal(),
        allowsEmptyCollection: ()=>local.allowsEmptyCollection ?? false,
        shouldFocusWrap: ()=>local.shouldFocusWrap ?? false,
        removeOnBackspace: ()=>local.removeOnBackspace ?? true,
        selectedOptions,
        isInputFocused,
        contentPresence,
        autoFocus: focusStrategy,
        inputValue,
        triggerMode: ()=>local.triggerMode,
        activeDescendant,
        controlRef,
        inputRef,
        triggerRef,
        contentRef,
        listState: ()=>listState,
        keyboardDelegate: delegate,
        listboxId,
        triggerAriaLabel: ()=>local.translations?.triggerLabel,
        listboxAriaLabel: ()=>local.translations?.listboxLabel,
        setIsInputFocused,
        resetInputValue,
        setInputValue,
        setControlRef,
        setInputRef,
        setTriggerRef,
        setContentRef,
        setListboxRef,
        open,
        close,
        toggle,
        placeholder: ()=>local.placeholder,
        renderItem,
        renderSection,
        removeOptionFromSelection,
        onInputKeyDown: (e)=>selectableCollection.onKeyDown(e),
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        registerListboxId: createRegisterId(setListboxId)
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(ComboboxContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                        anchorRef: controlRef,
                        contentRef: contentRef
                    }, popperProps, {
                        get children () {
                            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                                as: "div",
                                role: "group",
                                get id () {
                                    return (0, _utils.access)(formControlProps.id);
                                }
                            }, ()=>formControlContext.dataset(), dataset, others));
                        }
                    }));
                }
            });
        }
    });
}
/**
 * A combo box combines a text input with a listbox, allowing users to filter a list of options to items matching a query.
 */ function ComboboxRoot(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "defaultValue",
        "onChange",
        "multiple"
    ]);
    const value = (0, _solidJs.createMemo)(()=>{
        if (local.value != null) return local.multiple ? local.value : [
            local.value
        ];
        return local.value;
    });
    const defaultValue = (0, _solidJs.createMemo)(()=>{
        if (local.defaultValue != null) return local.multiple ? local.defaultValue : [
            local.defaultValue
        ];
        return local.defaultValue;
    });
    const onChange = (value)=>{
        if (local.multiple) local.onChange?.(value);
        else // use `null` as "no value" because `undefined` mean the component is "uncontrolled".
        local.onChange?.(value[0] ?? null);
    };
    return (0, _web.createComponent)(ComboboxBase, (0, _web.mergeProps)({
        get value () {
            return value();
        },
        get defaultValue () {
            return defaultValue();
        },
        onChange: onChange,
        get selectionMode () {
            return local.multiple ? "multiple" : "single";
        }
    }, others));
}
function ComboboxTrigger(props) {
    const formControlContext = useFormControlContext();
    const context = useComboboxContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("trigger")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "disabled",
        "onPointerDown",
        "onClick",
        "aria-labelledby"
    ]);
    const isDisabled = ()=>{
        return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        e.currentTarget.dataset.pointerType = e.pointerType;
        // For consistency with native, open the combobox on mouse down (main button), but touch up.
        if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
            // prevent trigger from stealing focus from the active item after opening.
            e.preventDefault();
            context.toggle(false, "manual");
        }
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        if (!isDisabled()) {
            if (e.currentTarget.dataset.pointerType === "touch") context.toggle(false, "manual");
            // Focus the input field in case it isn't focused yet.
            context.inputRef()?.focus();
        }
    };
    const ariaLabelledBy = ()=>{
        return formControlContext.getAriaLabelledBy(others.id, context.triggerAriaLabel(), local["aria-labelledby"]);
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get disabled () {
            return isDisabled();
        },
        tabIndex: "-1",
        "aria-haspopup": "listbox",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.listboxId() : undefined;
        },
        get ["aria-label"] () {
            return context.triggerAriaLabel();
        },
        get ["aria-labelledby"] () {
            return ariaLabelledBy();
        },
        onPointerDown: onPointerDown,
        onClick: onClick
    }, ()=>context.dataset(), others));
}
var index$j = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    Content: ComboboxContent,
    Control: ComboboxControl,
    Description: FormControlDescription,
    ErrorMessage: FormControlErrorMessage,
    HiddenSelect: ComboboxHiddenSelect,
    Icon: ComboboxIcon,
    Input: ComboboxInput,
    Item: ListboxItem,
    ItemDescription: ListboxItemDescription,
    ItemIndicator: ListboxItemIndicator,
    ItemLabel: ListboxItemLabel,
    Label: FormControlLabel,
    Listbox: ComboboxListbox,
    Portal: ComboboxPortal,
    Root: ComboboxRoot,
    Section: ListboxSection,
    Trigger: ComboboxTrigger
});
const MenuContext = (0, _solidJs.createContext)();
function useOptionalMenuContext() {
    return (0, _solidJs.useContext)(MenuContext);
}
function useMenuContext() {
    const context = useOptionalMenuContext();
    if (context === undefined) throw new Error("[kobalte]: `useMenuContext` must be used within a `Menu` component");
    return context;
}
const MenuRootContext = (0, _solidJs.createContext)();
function useMenuRootContext() {
    const context = (0, _solidJs.useContext)(MenuRootContext);
    if (context === undefined) throw new Error("[kobalte]: `useMenuRootContext` must be used within a `MenuRoot` component");
    return context;
}
/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/menu/src/Menu.tsx
 */ /**
 * Construct a polygon based on pointer clientX/clientY and an element bounding rect.
 */ function getPointerGraceArea(placement, event, contentEl) {
    const basePlacement = placement.split("-")[0];
    const contentRect = contentEl.getBoundingClientRect();
    const polygon = [];
    const pointerX = event.clientX;
    const pointerY = event.clientY;
    switch(basePlacement){
        case "top":
            polygon.push([
                pointerX,
                pointerY + 5
            ]);
            polygon.push([
                contentRect.left,
                contentRect.bottom
            ]);
            polygon.push([
                contentRect.left,
                contentRect.top
            ]);
            polygon.push([
                contentRect.right,
                contentRect.top
            ]);
            polygon.push([
                contentRect.right,
                contentRect.bottom
            ]);
            break;
        case "right":
            polygon.push([
                pointerX - 5,
                pointerY
            ]);
            polygon.push([
                contentRect.left,
                contentRect.top
            ]);
            polygon.push([
                contentRect.right,
                contentRect.top
            ]);
            polygon.push([
                contentRect.right,
                contentRect.bottom
            ]);
            polygon.push([
                contentRect.left,
                contentRect.bottom
            ]);
            break;
        case "bottom":
            polygon.push([
                pointerX,
                pointerY - 5
            ]);
            polygon.push([
                contentRect.right,
                contentRect.top
            ]);
            polygon.push([
                contentRect.right,
                contentRect.bottom
            ]);
            polygon.push([
                contentRect.left,
                contentRect.bottom
            ]);
            polygon.push([
                contentRect.left,
                contentRect.top
            ]);
            break;
        case "left":
            polygon.push([
                pointerX + 5,
                pointerY
            ]);
            polygon.push([
                contentRect.right,
                contentRect.bottom
            ]);
            polygon.push([
                contentRect.left,
                contentRect.bottom
            ]);
            polygon.push([
                contentRect.left,
                contentRect.top
            ]);
            polygon.push([
                contentRect.right,
                contentRect.top
            ]);
            break;
    }
    return polygon;
}
function isPointerInGraceArea(event, area) {
    if (!area) return false;
    return (0, _utils.isPointInPolygon)([
        event.clientX,
        event.clientY
    ], area);
}
/**
 * Container for menu items and nested menu, provide context for its children.
 */ function Menu(props) {
    const rootContext = useMenuRootContext();
    const parentDomCollectionContext = useOptionalDomCollectionContext();
    const parentMenuContext = useOptionalMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        placement: "bottom-start"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "open",
        "defaultOpen",
        "onOpenChange"
    ]);
    let pointerGraceTimeoutId = 0;
    let pointerGraceIntent = null;
    let pointerDir = "right";
    const [triggerId, setTriggerId] = (0, _solidJs.createSignal)();
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const [focusStrategy, setFocusStrategy] = (0, _solidJs.createSignal)(true);
    const [currentPlacement, setCurrentPlacement] = (0, _solidJs.createSignal)(others.placement);
    const [nestedMenus, setNestedMenus] = (0, _solidJs.createSignal)([]);
    const [items, setItems] = (0, _solidJs.createSignal)([]);
    const { DomCollectionProvider  } = createDomCollection({
        items,
        onItemsChange: setItems
    });
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const contentPresence = createPresence(()=>rootContext.forceMount() || disclosureState.isOpen());
    const listState = createListState({
        selectionMode: "none",
        dataSource: items
    });
    const open = (focusStrategy)=>{
        setFocusStrategy(focusStrategy);
        disclosureState.open();
    };
    const close = (recursively = false)=>{
        disclosureState.close();
        if (recursively && parentMenuContext) parentMenuContext.close(true);
    };
    const toggle = (focusStrategy)=>{
        setFocusStrategy(focusStrategy);
        disclosureState.toggle();
    };
    const focusContent = ()=>{
        const content = contentRef();
        if (content) {
            (0, _utils.focusWithoutScrolling)(content);
            listState.selectionManager().setFocused(true);
            listState.selectionManager().setFocusedKey(undefined);
        }
    };
    const registerNestedMenu = (element)=>{
        setNestedMenus((prev)=>[
                ...prev,
                element
            ]);
        const parentUnregister = parentMenuContext?.registerNestedMenu(element);
        return ()=>{
            setNestedMenus((prev)=>(0, _utils.removeItemFromArray)(prev, element));
            parentUnregister?.();
        };
    };
    const isPointerMovingToSubmenu = (e)=>{
        const isMovingTowards = pointerDir === pointerGraceIntent?.side;
        return isMovingTowards && isPointerInGraceArea(e, pointerGraceIntent?.area);
    };
    const onItemEnter = (e)=>{
        if (isPointerMovingToSubmenu(e)) e.preventDefault();
    };
    const onItemLeave = (e)=>{
        if (isPointerMovingToSubmenu(e)) return;
        focusContent();
    };
    const onTriggerLeave = (e)=>{
        if (isPointerMovingToSubmenu(e)) e.preventDefault();
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: ()=>{
            // Apply only on root menu when opened and modal.
            return !(parentMenuContext == null && disclosureState.isOpen() && rootContext.isModal());
        },
        targets: ()=>[
                contentRef(),
                ...nestedMenus()
            ].filter(Boolean)
    });
    (0, _solidJs.createEffect)(()=>{
        const contentEl = contentRef();
        if (!contentEl || !parentMenuContext) return;
        const parentUnregister = parentMenuContext.registerNestedMenu(contentEl);
        (0, _solidJs.onCleanup)(()=>{
            parentUnregister();
        });
    });
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        contentPresence,
        currentPlacement,
        pointerGraceTimeoutId: ()=>pointerGraceTimeoutId,
        autoFocus: focusStrategy,
        listState: ()=>listState,
        parentMenuContext: ()=>parentMenuContext,
        triggerRef,
        contentRef,
        triggerId,
        contentId,
        setTriggerRef,
        setContentRef,
        open,
        close,
        toggle,
        focusContent,
        onItemEnter,
        onItemLeave,
        onTriggerLeave,
        setPointerDir: (dir)=>pointerDir = dir,
        setPointerGraceTimeoutId: (id)=>pointerGraceTimeoutId = id,
        setPointerGraceIntent: (intent)=>pointerGraceIntent = intent,
        registerNestedMenu,
        registerItemToParentDomCollection: parentDomCollectionContext?.registerItem,
        registerTriggerId: createRegisterId(setTriggerId),
        registerContentId: createRegisterId(setContentId)
    };
    return (0, _web.createComponent)(DomCollectionProvider, {
        get children () {
            return (0, _web.createComponent)(MenuContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                        anchorRef: triggerRef,
                        contentRef: contentRef,
                        onCurrentPlacementChange: setCurrentPlacement
                    }, others));
                }
            });
        }
    });
}
const MenuItemContext = (0, _solidJs.createContext)();
function useMenuItemContext() {
    const context = (0, _solidJs.useContext)(MenuItemContext);
    if (context === undefined) throw new Error("[kobalte]: `useMenuItemContext` must be used within a `Menu.Item` component");
    return context;
}
/**
 * Base component for a menu item.
 */ function MenuItemBase(props) {
    let ref;
    const rootContext = useMenuRootContext();
    const menuContext = useMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        id: rootContext.generateId(`item-${(0, _solidJs.createUniqueId)()}`)
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "textValue",
        "disabled",
        "closeOnSelect",
        "checked",
        "indeterminate",
        "onSelect",
        "onPointerMove",
        "onPointerLeave",
        "onPointerDown",
        "onPointerUp",
        "onClick",
        "onKeyDown",
        "onMouseDown",
        "onFocus"
    ]);
    const [labelId, setLabelId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const [labelRef, setLabelRef] = (0, _solidJs.createSignal)();
    const selectionManager = ()=>menuContext.listState().selectionManager();
    const key = ()=>others.id;
    const isHighlighted = ()=>selectionManager().focusedKey() === key();
    const onSelect = ()=>{
        local.onSelect?.();
        if (local.closeOnSelect) menuContext.close(true);
    };
    createDomCollectionItem({
        getItem: ()=>({
                ref: ()=>ref,
                type: "item",
                key: key(),
                textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
                disabled: local.disabled ?? false
            })
    });
    const selectableItem = createSelectableItem({
        key,
        selectionManager: selectionManager,
        shouldSelectOnPressUp: true,
        allowsDifferentPressOrigin: true,
        disabled: ()=>local.disabled
    }, ()=>ref);
    /**
   * We focus items on `pointerMove` to achieve the following:
   *
   * - Mouse over an item (it focuses)
   * - Leave mouse where it is and use keyboard to focus a different item
   * - Wiggle mouse without it leaving previously focused item
   * - Previously focused item should re-focus
   *
   * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse
   * wiggles. This is to match native menu implementation.
   */ const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (e.pointerType !== "mouse") return;
        if (local.disabled) menuContext.onItemLeave(e);
        else {
            menuContext.onItemEnter(e);
            if (!e.defaultPrevented) {
                (0, _utils.focusWithoutScrolling)(e.currentTarget);
                menuContext.listState().selectionManager().setFocused(true);
                menuContext.listState().selectionManager().setFocusedKey(key());
            }
        }
    };
    const onPointerLeave = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerLeave);
        if (e.pointerType !== "mouse") return;
        menuContext.onItemLeave(e);
    };
    const onPointerUp = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerUp);
        // Selection occurs on pointer up (main button).
        if (!local.disabled && e.button === 0) onSelect();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        // Ignore repeating events, which may have started on the menu trigger before moving
        // focus to the menu item. We want to wait for a second complete key press sequence.
        if (e.repeat) return;
        if (local.disabled) return;
        switch(e.key){
            case "Enter":
            case " ":
                onSelect();
                break;
        }
    };
    const ariaChecked = (0, _solidJs.createMemo)(()=>{
        if (local.indeterminate) return "mixed";
        if (local.checked == null) return undefined;
        return local.checked;
    });
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-indeterminate": local.indeterminate ? "" : undefined,
            "data-checked": local.checked && !local.indeterminate ? "" : undefined,
            "data-disabled": local.disabled ? "" : undefined,
            "data-highlighted": isHighlighted() ? "" : undefined
        }));
    const context = {
        isChecked: ()=>local.checked,
        dataset,
        setLabelRef,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerLabel: createRegisterId(setLabelId),
        registerDescription: createRegisterId(setDescriptionId)
    };
    return (0, _web.createComponent)(MenuItemContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                get tabIndex () {
                    return selectableItem.tabIndex();
                },
                get ["aria-checked"] () {
                    return ariaChecked();
                },
                get ["aria-disabled"] () {
                    return local.disabled;
                },
                get ["aria-labelledby"] () {
                    return labelId();
                },
                get ["aria-describedby"] () {
                    return descriptionId();
                },
                get ["data-key"] () {
                    return selectableItem.dataKey();
                },
                get onPointerDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onPointerDown,
                        selectableItem.onPointerDown
                    ]);
                },
                get onPointerUp () {
                    return (0, _utils.composeEventHandlers)([
                        onPointerUp,
                        selectableItem.onPointerUp
                    ]);
                },
                get onClick () {
                    return (0, _utils.composeEventHandlers)([
                        local.onClick,
                        selectableItem.onClick
                    ]);
                },
                get onKeyDown () {
                    return (0, _utils.composeEventHandlers)([
                        onKeyDown,
                        selectableItem.onKeyDown
                    ]);
                },
                get onMouseDown () {
                    return (0, _utils.composeEventHandlers)([
                        local.onMouseDown,
                        selectableItem.onMouseDown
                    ]);
                },
                get onFocus () {
                    return (0, _utils.composeEventHandlers)([
                        local.onFocus,
                        selectableItem.onFocus
                    ]);
                },
                onPointerMove: onPointerMove,
                onPointerLeave: onPointerLeave
            }, dataset, others));
        }
    });
}
/**
 * An item that can be controlled and rendered like a checkbox.
 */ function MenuCheckboxItem(props) {
    props = (0, _utils.mergeDefaultProps)({
        closeOnSelect: false
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "checked",
        "defaultChecked",
        "onChange",
        "onSelect"
    ]);
    const state = createToggleState({
        isSelected: ()=>local.checked,
        defaultIsSelected: ()=>local.defaultChecked,
        onSelectedChange: (checked)=>local.onChange?.(checked),
        isDisabled: ()=>others.disabled
    });
    const onSelect = ()=>{
        local.onSelect?.();
        state.toggle();
    };
    return (0, _web.createComponent)(MenuItemBase, (0, _web.mergeProps)({
        role: "menuitemcheckbox",
        get checked () {
            return state.isSelected();
        },
        onSelect: onSelect
    }, others));
}
function MenuContentBase(props) {
    let ref;
    const rootContext = useMenuRootContext();
    const context = useMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        id: rootContext.generateId(`content-${(0, _solidJs.createUniqueId)()}`)
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "style",
        "onOpenAutoFocus",
        "onCloseAutoFocus",
        "onEscapeKeyDown",
        "onFocusOutside",
        "onPointerEnter",
        "onPointerMove",
        "onKeyDown",
        "onMouseDown",
        "onFocusIn",
        "onFocusOut"
    ]);
    let lastPointerX = 0;
    // Only the root menu can apply "modal" behavior (block pointer-events and trap focus).
    const isRootModalContent = ()=>{
        return context.parentMenuContext() == null && rootContext.isModal();
    };
    const selectableList = createSelectableList({
        selectionManager: context.listState().selectionManager,
        collection: context.listState().collection,
        autoFocus: context.autoFocus,
        deferAutoFocus: true,
        // ensure all menu items are mounted and collection is not empty before trying to autofocus.
        shouldFocusWrap: true,
        disallowTypeAhead: ()=>!context.listState().selectionManager().isFocused()
    }, ()=>ref);
    createFocusScope({
        trapFocus: ()=>isRootModalContent() && context.isOpen(),
        onMountAutoFocus: local.onOpenAutoFocus,
        onUnmountAutoFocus: local.onCloseAutoFocus
    }, ()=>ref);
    const onKeyDown = (e)=>{
        // Submenu key events bubble through portals. We only care about keys in this menu.
        if (!(0, _utils.contains)(e.currentTarget, e.target)) return;
        // Menus should not be navigated using tab key, so we prevent it.
        if (e.key === "Tab" && context.isOpen()) e.preventDefault();
    };
    const onEscapeKeyDown = (e)=>{
        local.onEscapeKeyDown?.(e);
        // `createSelectableList` prevent escape key down,
        // which prevent our `onDismiss` in `DismissableLayer` to run,
        // so we force "close on escape" here.
        context.close(true);
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        if (rootContext.isModal()) // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        e.preventDefault();
    };
    const onPointerEnter = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerEnter);
        if (!context.isOpen()) return;
        // Remove visual focus from parent menu content.
        context.parentMenuContext()?.listState().selectionManager().setFocused(false);
        context.parentMenuContext()?.listState().selectionManager().setFocusedKey(undefined);
    };
    const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (e.pointerType !== "mouse") return;
        const target = e.target;
        const pointerXHasChanged = lastPointerX !== e.clientX;
        // We don't use `event.movementX` for this check because Safari will
        // always return `0` on a pointer event.
        if ((0, _utils.contains)(e.currentTarget, target) && pointerXHasChanged) {
            context.setPointerDir(e.clientX > lastPointerX ? "right" : "left");
            lastPointerX = e.clientX;
        }
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerContentId(local.id)));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                                ref = el;
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "menu",
                        get id () {
                            return local.id;
                        },
                        get tabIndex () {
                            return selectableList.tabIndex();
                        },
                        get disableOutsidePointerEvents () {
                            return (0, _web.memo)(()=>!!isRootModalContent())() && context.isOpen();
                        },
                        get excludedElements () {
                            return [
                                context.triggerRef
                            ];
                        },
                        bypassTopMostLayerCheck: true,
                        get style () {
                            return {
                                "--kb-menu-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        get ["aria-labelledby"] () {
                            return context.triggerId();
                        },
                        onEscapeKeyDown: onEscapeKeyDown,
                        onFocusOutside: onFocusOutside,
                        get onDismiss () {
                            return context.close;
                        },
                        get onKeyDown () {
                            return (0, _utils.composeEventHandlers)([
                                local.onKeyDown,
                                selectableList.onKeyDown,
                                onKeyDown
                            ]);
                        },
                        get onMouseDown () {
                            return (0, _utils.composeEventHandlers)([
                                local.onMouseDown,
                                selectableList.onMouseDown
                            ]);
                        },
                        get onFocusIn () {
                            return (0, _utils.composeEventHandlers)([
                                local.onFocusIn,
                                selectableList.onFocusIn
                            ]);
                        },
                        get onFocusOut () {
                            return (0, _utils.composeEventHandlers)([
                                local.onFocusOut,
                                selectableList.onFocusOut
                            ]);
                        },
                        onPointerEnter: onPointerEnter,
                        onPointerMove: onPointerMove
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
function MenuContent(props) {
    let ref;
    const rootContext = useMenuRootContext();
    const context = useMenuContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref"
    ]);
    createPreventScroll({
        ownerRef: ()=>ref,
        isDisabled: ()=>!(context.isOpen() && rootContext.preventScroll())
    });
    return (0, _web.createComponent)(MenuContentBase, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        }
    }, others));
}
const MenuGroupContext = (0, _solidJs.createContext)();
function useMenuGroupContext() {
    const context = (0, _solidJs.useContext)(MenuGroupContext);
    if (context === undefined) throw new Error("[kobalte]: `useMenuGroupContext` must be used within a `Menu.Group` component");
    return context;
}
/**
 * A container used to group multiple `Menu.Item`s.
 */ function MenuGroup(props) {
    const rootContext = useMenuRootContext();
    props = (0, _utils.mergeDefaultProps)({
        id: rootContext.generateId(`group-${(0, _solidJs.createUniqueId)()}`)
    }, props);
    const [labelId, setLabelId] = (0, _solidJs.createSignal)();
    const context = {
        generateId: (0, _utils.createGenerateId)(()=>props.id),
        registerLabelId: createRegisterId(setLabelId)
    };
    return (0, _web.createComponent)(MenuGroupContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                role: "group",
                get ["aria-labelledby"] () {
                    return labelId();
                }
            }, props));
        }
    });
}
/**
 * A component used to render the label of a `Menu.Group`.
 * It won't be focusable using arrow keys.
 */ function MenuGroupLabel(props) {
    const context = useMenuGroupContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("label")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerLabelId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "span",
        get id () {
            return local.id;
        },
        "aria-hidden": "true"
    }, others));
}
/**
 * A small icon often displayed inside the menu trigger as a visual affordance for the fact it can be open.
 * It renders a `▼` by default, but you can use your own icon by providing a `children`.
 */ function MenuIcon(props) {
    const context = useMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        children: "▼"
    }, props);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "span",
        "aria-hidden": "true"
    }, ()=>context.dataset(), props));
}
/**
 * An item of the menu.
 */ function MenuItem(props) {
    return (0, _web.createComponent)(MenuItemBase, (0, _web.mergeProps)({
        role: "menuitem",
        closeOnSelect: true
    }, props));
}
/**
 * An optional accessible description to be announced for the menu item.
 * Useful for menu items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */ function MenuItemDescription(props) {
    const context = useMenuItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescription(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * The visual indicator rendered when the parent menu `CheckboxItem` or `RadioItem` is checked.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */ function MenuItemIndicator(props) {
    const context = useMenuItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("indicator")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "forceMount"
    ]);
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return local.forceMount || context.isChecked();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div"
            }, ()=>context.dataset(), others));
        }
    });
}
/**
 * An accessible label to be announced for the menu item.
 * Useful for menu items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */ function MenuItemLabel(props) {
    const context = useMenuItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("label")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerLabel(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setLabelRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * Portals its children into the `body` when the menu is open.
 */ function MenuPortal(props) {
    const context = useMenuContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
const MenuRadioGroupContext = (0, _solidJs.createContext)();
function useMenuRadioGroupContext() {
    const context = (0, _solidJs.useContext)(MenuRadioGroupContext);
    if (context === undefined) throw new Error("[kobalte]: `useMenuRadioGroupContext` must be used within a `Menu.RadioGroup` component");
    return context;
}
/**
 * A container used to group multiple `Menu.RadioItem`s and manage the selection.
 */ function MenuRadioGroup(props) {
    const rootContext = useMenuRootContext();
    const defaultId = rootContext.generateId(`radiogroup-${(0, _solidJs.createUniqueId)()}`);
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "defaultValue",
        "onChange",
        "disabled"
    ]);
    const [selected, setSelected] = createControllableSignal({
        value: ()=>local.value,
        defaultValue: ()=>local.defaultValue,
        onChange: (value)=>local.onChange?.(value)
    });
    const context = {
        isDisabled: ()=>local.disabled,
        isSelectedValue: (value)=>value === selected(),
        setSelectedValue: setSelected
    };
    return (0, _web.createComponent)(MenuRadioGroupContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(MenuGroup, others);
        }
    });
}
/**
 * An item that can be controlled and rendered like a radio.
 */ function MenuRadioItem(props) {
    const context = useMenuRadioGroupContext();
    props = (0, _utils.mergeDefaultProps)({
        closeOnSelect: false
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "onSelect"
    ]);
    const onSelect = ()=>{
        local.onSelect?.();
        context.setSelectedValue(local.value);
    };
    return (0, _web.createComponent)(MenuItemBase, (0, _web.mergeProps)({
        role: "menuitemradio",
        get checked () {
            return context.isSelectedValue(local.value);
        },
        onSelect: onSelect
    }, others));
}
/**
 * Root component for a menu, provide context for its children.
 * Used to build dropdown menu, context menu and menubar.
 */ function MenuRoot(props) {
    const defaultId = `menu-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        modal: true
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id",
        "modal",
        "preventScroll",
        "forceMount",
        "open",
        "defaultOpen",
        "onOpenChange"
    ]);
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const context = {
        isModal: ()=>local.modal ?? true,
        preventScroll: ()=>local.preventScroll ?? context.isModal(),
        forceMount: ()=>local.forceMount ?? false,
        generateId: (0, _utils.createGenerateId)(()=>local.id)
    };
    return (0, _web.createComponent)(MenuRootContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Menu, (0, _web.mergeProps)({
                get open () {
                    return disclosureState.isOpen();
                },
                get onOpenChange () {
                    return disclosureState.setIsOpen;
                }
            }, others));
        }
    });
}
/**
 * Contains all the parts of a submenu.
 */ function MenuSub(props) {
    const { direction  } = useLocale();
    return (0, _web.createComponent)(Menu, (0, _web.mergeProps)({
        get placement () {
            return direction() === "rtl" ? "left-start" : "right-start";
        },
        flip: true
    }, props));
}
const SUB_CLOSE_KEYS = {
    ltr: [
        "ArrowLeft"
    ],
    rtl: [
        "ArrowRight"
    ]
};
/**
 * The component that pops out when a submenu is open.
 */ function MenuSubContent(props) {
    const context = useMenuContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onFocusOutside",
        "onKeyDown",
        "onFocusOut"
    ]);
    const { direction  } = useLocale();
    const onOpenAutoFocus = (e)=>{
        // when opening a submenu, focus content for keyboard users only (handled by `MenuSubTrigger`).
        e.preventDefault();
    };
    const onCloseAutoFocus = (e)=>{
        // The menu might close because of focusing another menu item in the parent menu.
        // We don't want it to refocus the trigger in that case, so we handle trigger focus ourselves.
        e.preventDefault();
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        const target = e.target;
        // We prevent closing when the trigger is focused to avoid triggering a re-open animation
        // on pointer interaction.
        if (!(0, _utils.contains)(context.triggerRef(), target)) context.close();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        // Submenu key events bubble through portals. We only care about keys in this menu.
        const isKeyDownInside = (0, _utils.contains)(e.currentTarget, e.target);
        const isCloseKey = SUB_CLOSE_KEYS[direction()].includes(e.key);
        const isSubMenu = context.parentMenuContext() != null;
        if (isKeyDownInside && isCloseKey && isSubMenu) {
            context.close();
            // We focus manually because we prevented it in `onCloseAutoFocus`.
            (0, _utils.focusWithoutScrolling)(context.triggerRef());
        }
    };
    return (0, _web.createComponent)(MenuContentBase, (0, _web.mergeProps)({
        onOpenAutoFocus: onOpenAutoFocus,
        onCloseAutoFocus: onCloseAutoFocus,
        onFocusOutside: onFocusOutside,
        onKeyDown: onKeyDown
    }, others));
}
const SELECTION_KEYS = [
    "Enter",
    " "
];
const SUB_OPEN_KEYS = {
    ltr: [
        ...SELECTION_KEYS,
        "ArrowRight"
    ],
    rtl: [
        ...SELECTION_KEYS,
        "ArrowLeft"
    ]
};
/**
 * An item that opens a submenu.
 */ function MenuSubTrigger(props) {
    let ref;
    const rootContext = useMenuRootContext();
    const context = useMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        id: rootContext.generateId(`sub-trigger-${(0, _solidJs.createUniqueId)()}`)
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "textValue",
        "disabled",
        "onPointerMove",
        "onPointerLeave",
        "onPointerDown",
        "onPointerUp",
        "onClick",
        "onKeyDown",
        "onMouseDown",
        "onFocus"
    ]);
    let openTimeoutId = null;
    const clearOpenTimeout = ()=>{
        if (0, _web.isServer) return;
        if (openTimeoutId) window.clearTimeout(openTimeoutId);
        openTimeoutId = null;
    };
    const { direction  } = useLocale();
    const key = ()=>local.id;
    const parentSelectionManager = ()=>{
        const parentMenuContext = context.parentMenuContext();
        if (parentMenuContext == null) throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
        return parentMenuContext.listState().selectionManager();
    };
    const collection = ()=>context.listState().collection();
    const isHighlighted = ()=>parentSelectionManager().focusedKey() === key();
    const selectableItem = createSelectableItem({
        key,
        selectionManager: parentSelectionManager,
        shouldSelectOnPressUp: true,
        allowsDifferentPressOrigin: true,
        disabled: ()=>local.disabled
    }, ()=>ref);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        if (!context.isOpen() && !local.disabled) context.open(true);
    };
    const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (e.pointerType !== "mouse") return;
        const parentMenuContext = context.parentMenuContext();
        parentMenuContext?.onItemEnter(e);
        if (e.defaultPrevented) return;
        if (local.disabled) {
            parentMenuContext?.onItemLeave(e);
            return;
        }
        if (!context.isOpen() && !openTimeoutId) {
            context.parentMenuContext()?.setPointerGraceIntent(null);
            openTimeoutId = window.setTimeout(()=>{
                context.open(false);
                clearOpenTimeout();
            }, 100);
        }
        parentMenuContext?.onItemEnter(e);
        if (!e.defaultPrevented) {
            // Remove visual focus from sub menu content.
            if (context.listState().selectionManager().isFocused()) {
                context.listState().selectionManager().setFocused(false);
                context.listState().selectionManager().setFocusedKey(undefined);
            }
            // Restore visual focus to parent menu content.
            (0, _utils.focusWithoutScrolling)(e.currentTarget);
            parentMenuContext?.listState().selectionManager().setFocused(true);
            parentMenuContext?.listState().selectionManager().setFocusedKey(key());
        }
    };
    const onPointerLeave = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerLeave);
        if (e.pointerType !== "mouse") return;
        clearOpenTimeout();
        const parentMenuContext = context.parentMenuContext();
        const contentEl = context.contentRef();
        if (contentEl) {
            parentMenuContext?.setPointerGraceIntent({
                area: getPointerGraceArea(context.currentPlacement(), e, contentEl),
                // Safe because sub menu always open "left" or "right".
                side: context.currentPlacement().split("-")[0]
            });
            window.clearTimeout(parentMenuContext?.pointerGraceTimeoutId());
            const pointerGraceTimeoutId = window.setTimeout(()=>{
                parentMenuContext?.setPointerGraceIntent(null);
            }, 300);
            parentMenuContext?.setPointerGraceTimeoutId(pointerGraceTimeoutId);
        } else {
            parentMenuContext?.onTriggerLeave(e);
            if (e.defaultPrevented) return;
            // There's 100ms where the user may leave an item before the submenu was opened.
            parentMenuContext?.setPointerGraceIntent(null);
        }
        parentMenuContext?.onItemLeave(e);
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        // Ignore repeating events, which may have started on the menu trigger before moving
        // focus to the menu item. We want to wait for a second complete key press sequence.
        if (e.repeat) return;
        if (local.disabled) return;
        // For consistency with native, open the menu on key down.
        if (SUB_OPEN_KEYS[direction()].includes(e.key)) {
            e.stopPropagation();
            e.preventDefault();
            // Clear focus on parent menu (e.g. the menu containing the trigger).
            parentSelectionManager().setFocused(false);
            parentSelectionManager().setFocusedKey(undefined);
            if (!context.isOpen()) context.open("first");
            // We focus manually because we prevented it in MenuSubContent's `onOpenAutoFocus`.
            context.focusContent();
            context.listState().selectionManager().setFocused(true);
            context.listState().selectionManager().setFocusedKey(collection().getFirstKey());
        }
    };
    (0, _solidJs.createEffect)(()=>{
        // Not able to register the trigger as a menu item on parent menu means
        // `Menu.SubTrigger` is not used in the correct place, so throw an error.
        if (context.registerItemToParentDomCollection == null) throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
        // Register the item trigger on the parent menu that contains it.
        const unregister = context.registerItemToParentDomCollection({
            ref: ()=>ref,
            type: "item",
            key: key(),
            textValue: local.textValue ?? ref?.textContent ?? "",
            disabled: local.disabled ?? false
        });
        (0, _solidJs.onCleanup)(unregister);
    });
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>context.parentMenuContext()?.pointerGraceTimeoutId(), (pointerGraceTimer)=>{
        (0, _solidJs.onCleanup)(()=>{
            window.clearTimeout(pointerGraceTimer);
            context.parentMenuContext()?.setPointerGraceIntent(null);
        });
    }));
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTriggerId(local.id)));
    (0, _solidJs.onCleanup)(()=>{
        clearOpenTimeout();
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                context.setTriggerRef(el);
                ref = el;
            }, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return local.id;
        },
        role: "menuitem",
        get tabIndex () {
            return selectableItem.tabIndex();
        },
        "aria-haspopup": "true",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        get ["aria-disabled"] () {
            return local.disabled;
        },
        get ["data-key"] () {
            return selectableItem.dataKey();
        },
        get ["data-highlighted"] () {
            return isHighlighted() ? "" : undefined;
        },
        get ["data-disabled"] () {
            return local.disabled ? "" : undefined;
        },
        get onPointerDown () {
            return (0, _utils.composeEventHandlers)([
                local.onPointerDown,
                selectableItem.onPointerDown
            ]);
        },
        get onPointerUp () {
            return (0, _utils.composeEventHandlers)([
                local.onPointerUp,
                selectableItem.onPointerUp
            ]);
        },
        get onClick () {
            return (0, _utils.composeEventHandlers)([
                onClick,
                selectableItem.onClick
            ]);
        },
        get onKeyDown () {
            return (0, _utils.composeEventHandlers)([
                onKeyDown,
                selectableItem.onKeyDown
            ]);
        },
        get onMouseDown () {
            return (0, _utils.composeEventHandlers)([
                local.onMouseDown,
                selectableItem.onMouseDown
            ]);
        },
        get onFocus () {
            return (0, _utils.composeEventHandlers)([
                local.onFocus,
                selectableItem.onFocus
            ]);
        },
        onPointerMove: onPointerMove,
        onPointerLeave: onPointerLeave
    }, ()=>context.dataset(), others));
}
/**
 * The button that toggles the menu.
 */ function MenuTrigger(props) {
    const rootContext = useMenuRootContext();
    const context = useMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        id: rootContext.generateId("trigger")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "disabled",
        "onPointerDown",
        "onClick",
        "onKeyDown"
    ]);
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        e.currentTarget.dataset.pointerType = e.pointerType;
        // For consistency with native, open the select on mouse down (main button), but touch up.
        if (!local.disabled && e.pointerType !== "touch" && e.button === 0) context.toggle(true);
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        if (!local.disabled && e.currentTarget.dataset.pointerType === "touch") context.toggle(true);
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (local.disabled) return;
        // For consistency with native, open the menu on key down.
        switch(e.key){
            case "Enter":
            case " ":
            case "ArrowDown":
                e.stopPropagation();
                e.preventDefault();
                context.toggle("first");
                break;
            case "ArrowUp":
                e.stopPropagation();
                e.preventDefault();
                context.toggle("last");
                break;
        }
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTriggerId(local.id)));
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return local.id;
        },
        get disabled () {
            return local.disabled;
        },
        "aria-haspopup": "true",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        onPointerDown: onPointerDown,
        onClick: onClick,
        onKeyDown: onKeyDown
    }, ()=>context.dataset(), others));
}
/**
 * A separator visually or semantically separates content.
 */ function SeparatorRoot(props) {
    let ref;
    props = (0, _utils.mergeDefaultProps)({
        orientation: "horizontal"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "orientation"
    ]);
    const tagName = createTagName(()=>ref, ()=>"hr");
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "hr",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get role () {
            return tagName() !== "hr" ? "separator" : undefined;
        },
        get ["aria-orientation"] () {
            return local.orientation === "vertical" ? "vertical" : undefined;
        },
        get ["data-orientation"] () {
            return local.orientation;
        }
    }, others));
}
var index$i = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Root: SeparatorRoot
});
function ContextMenuContent(props) {
    const rootContext = useMenuRootContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onCloseAutoFocus",
        "onInteractOutside"
    ]);
    let hasInteractedOutside = false;
    const onCloseAutoFocus = (e)=>{
        local.onCloseAutoFocus?.(e);
        if (!e.defaultPrevented && hasInteractedOutside) e.preventDefault();
        hasInteractedOutside = false;
    };
    const onInteractOutside = (e)=>{
        local.onInteractOutside?.(e);
        if (!e.defaultPrevented && !rootContext.isModal()) hasInteractedOutside = true;
    };
    return (0, _web.createComponent)(MenuContent, (0, _web.mergeProps)({
        onCloseAutoFocus: onCloseAutoFocus,
        onInteractOutside: onInteractOutside
    }, others));
}
const ContextMenuContext = (0, _solidJs.createContext)();
function useOptionalContextMenuContext() {
    return (0, _solidJs.useContext)(ContextMenuContext);
}
function useContextMenuContext() {
    const context = useOptionalContextMenuContext();
    if (context === undefined) throw new Error("[kobalte]: `useContextMenuContext` must be used within a `ContextMenu` component");
    return context;
}
/**
 * Displays a menu located at the pointer, triggered by a right-click or a long-press.
 */ function ContextMenuRoot(props) {
    const defaultId = `contextmenu-${(0, _solidJs.createUniqueId)()}`;
    const { direction  } = useLocale();
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        placement: direction() === "rtl" ? "left-start" : "right-start",
        gutter: 2,
        shift: 2
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onOpenChange"
    ]);
    const [anchorRect, setAnchorRect] = (0, _solidJs.createSignal)({
        x: 0,
        y: 0
    });
    const disclosureState = createDisclosureState({
        defaultOpen: false,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const context = {
        setAnchorRect
    };
    return (0, _web.createComponent)(ContextMenuContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(MenuRoot, (0, _web.mergeProps)({
                get open () {
                    return disclosureState.isOpen();
                },
                get onOpenChange () {
                    return disclosureState.setIsOpen;
                },
                getAnchorRect: anchorRect
            }, others));
        }
    });
}
function ContextMenuTrigger(props) {
    const rootContext = useMenuRootContext();
    const menuContext = useMenuContext();
    const context = useContextMenuContext();
    props = (0, _utils.mergeDefaultProps)({
        id: rootContext.generateId("trigger")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "disabled",
        "onContextMenu",
        "onPointerDown",
        "onPointerMove",
        "onPointerCancel",
        "onPointerUp"
    ]);
    let longPressTimoutId = 0;
    const clearLongPressTimeout = ()=>{
        if (0, _web.isServer) return;
        window.clearTimeout(longPressTimoutId);
    };
    (0, _solidJs.onCleanup)(()=>{
        clearLongPressTimeout();
    });
    const onContextMenu = (e)=>{
        // If trigger is disabled, enable the native Context Menu.
        if (local.disabled) {
            (0, _utils.callHandler)(e, local.onContextMenu);
            return;
        }
        // Clearing the long press here because some platforms already support
        // long press to trigger a `contextmenu` event.
        clearLongPressTimeout();
        e.preventDefault();
        e.stopPropagation();
        context.setAnchorRect({
            x: e.clientX,
            y: e.clientY
        });
        if (menuContext.isOpen()) // If the menu is already open, focus the menu itself.
        menuContext.focusContent();
        else menuContext.open(true);
    };
    const isTouchOrPen = (e)=>e.pointerType === "touch" || e.pointerType === "pen";
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        if (!local.disabled && isTouchOrPen(e)) {
            // Clear the long press here in case there's multiple touch points.
            clearLongPressTimeout();
            longPressTimoutId = window.setTimeout(()=>menuContext.open(false), 700);
        }
    };
    const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (!local.disabled && isTouchOrPen(e)) clearLongPressTimeout();
    };
    const onPointerCancel = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerCancel);
        if (!local.disabled && isTouchOrPen(e)) clearLongPressTimeout();
    };
    const onPointerUp = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerUp);
        if (!local.disabled && isTouchOrPen(e)) clearLongPressTimeout();
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(menuContext.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get style () {
            return {
                // prevent iOS context menu from appearing
                "-webkit-touch-callout": "none",
                ...local.style
            };
        },
        get ["data-disabled"] () {
            return local.disabled ? "" : undefined;
        },
        onContextMenu: onContextMenu,
        onPointerDown: onPointerDown,
        onPointerMove: onPointerMove,
        onPointerCancel: onPointerCancel,
        onPointerUp: onPointerUp
    }, ()=>menuContext.dataset(), others));
}
var index$h = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    CheckboxItem: MenuCheckboxItem,
    Content: ContextMenuContent,
    Group: MenuGroup,
    GroupLabel: MenuGroupLabel,
    Icon: MenuIcon,
    Item: MenuItem,
    ItemDescription: MenuItemDescription,
    ItemIndicator: MenuItemIndicator,
    ItemLabel: MenuItemLabel,
    Portal: MenuPortal,
    RadioGroup: MenuRadioGroup,
    RadioItem: MenuRadioItem,
    Root: ContextMenuRoot,
    Separator: SeparatorRoot,
    Sub: MenuSub,
    SubContent: MenuSubContent,
    SubTrigger: MenuSubTrigger,
    Trigger: ContextMenuTrigger
});
const DatePickerContext = (0, _solidJs.createContext)();
function useDatePickerContext() {
    const context = (0, _solidJs.useContext)(DatePickerContext);
    if (context === undefined) throw new Error("[kobalte]: `useDatePickerContext` must be used within a `DatePicker` component");
    return context;
}
function DatePickerCalendar(props) {
    const formControlContext = useFormControlContext();
    const context = useDatePickerContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("calendar")
    }, props);
    return (0, _web.createComponent)(CalendarRoot, (0, _web.mergeProps)({
        autoFocus: true,
        get selectionMode () {
            return context.selectionMode();
        },
        get value () {
            return context.dateValue();
        },
        get onChange () {
            return context.setDateValue;
        },
        get locale () {
            return context.locale();
        },
        get createCalendar () {
            return context.createCalendar;
        },
        get isDateUnavailable () {
            return context.isDateUnavailable;
        },
        get visibleDuration () {
            return context.visibleDuration();
        },
        get allowsNonContiguousRanges () {
            return context.allowsNonContiguousRanges();
        },
        get defaultFocusedValue () {
            return (0, _web.memo)(()=>!!context.dateValue())() ? undefined : context.placeholderValue();
        },
        get minValue () {
            return context.minValue();
        },
        get maxValue () {
            return context.maxValue();
        },
        get disabled () {
            return formControlContext.isDisabled();
        },
        get readOnly () {
            return formControlContext.isReadOnly();
        },
        get validationState () {
            return context.validationState();
        }
    }, props));
}
/**
 * The component that pops out when the date picker is open.
 */ function DatePickerContent(props) {
    let ref;
    const formControlContext = useFormControlContext();
    const context = useDatePickerContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("content")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onCloseAutoFocus",
        "onPointerDownOutside",
        "onFocusOutside",
        "onInteractOutside",
        "aria-labelledby"
    ]);
    let isRightClickOutside = false;
    let hasInteractedOutside = false;
    let hasPointerDownOutside = false;
    const ariaLabelledBy = ()=>{
        return formControlContext.getAriaLabelledBy(context.triggerId(), others["aria-label"], local["aria-labelledby"]);
    };
    const onCloseAutoFocus = (e)=>{
        local.onCloseAutoFocus?.(e);
        if (context.isModal()) {
            e.preventDefault();
            if (!isRightClickOutside) (0, _utils.focusWithoutScrolling)(context.triggerRef());
        } else {
            if (!e.defaultPrevented) {
                if (!hasInteractedOutside) (0, _utils.focusWithoutScrolling)(context.triggerRef());
                // Always prevent autofocus because we either focus manually or want user agent focus
                e.preventDefault();
            }
            hasInteractedOutside = false;
            hasPointerDownOutside = false;
        }
    };
    const onPointerDownOutside = (e)=>{
        local.onPointerDownOutside?.(e);
        if (context.isModal()) isRightClickOutside = e.detail.isContextMenu;
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.isModal()) e.preventDefault();
    };
    const onInteractOutside = (e)=>{
        local.onInteractOutside?.(e);
        if (context.isModal()) return;
        // Non-modal behavior below
        if (!e.defaultPrevented) {
            hasInteractedOutside = true;
            if (e.detail.originalEvent.type === "pointerdown") hasPointerDownOutside = true;
        }
        // Prevent dismissing when clicking the trigger.
        // As the trigger is already setup to close, without doing so would
        // cause it to close and immediately open.
        if ((0, _utils.contains)(context.triggerRef(), e.target)) e.preventDefault();
        // On Safari if the trigger is inside a container with tabIndex={0}, when clicked
        // we will get the pointer down outside event on the trigger, but then a subsequent
        // focus outside event on the container, we ignore any focus outside event when we've
        // already had a pointer down outside event.
        if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) e.preventDefault();
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: ()=>!(context.isModal() && context.isOpen()),
        targets: ()=>{
            const excludedElements = [];
            if (ref) excludedElements.push(ref);
            const controlEl = context.controlRef();
            if (controlEl) excludedElements.push(controlEl);
            return excludedElements;
        }
    });
    createPreventScroll({
        ownerRef: ()=>ref,
        isDisabled: ()=>!(context.isModal() && context.isOpen())
    });
    createFocusScope({
        trapFocus: ()=>context.isModal() && context.isOpen(),
        onMountAutoFocus: (e)=>{
            // We prevent open autofocus because it's handled by the `Calendar`.
            e.preventDefault();
        },
        onUnmountAutoFocus: onCloseAutoFocus
    }, ()=>ref);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerContentId(others.id)));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                                ref = el;
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "dialog",
                        tabIndex: -1,
                        get disableOutsidePointerEvents () {
                            return (0, _web.memo)(()=>!!context.isModal())() && context.isOpen();
                        },
                        get excludedElements () {
                            return [
                                context.controlRef
                            ];
                        },
                        get style () {
                            return {
                                "--kb-date-picker-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        get ["aria-labelledby"] () {
                            return ariaLabelledBy();
                        },
                        onPointerDownOutside: onPointerDownOutside,
                        onFocusOutside: onFocusOutside,
                        onInteractOutside: onInteractOutside,
                        get onDismiss () {
                            return context.close;
                        }
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
/**
 * Contains the date picker input and trigger.
 */ function DatePickerControl(props) {
    let ref;
    const formControlContext = useFormControlContext();
    const context = useDatePickerContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("control")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onPointerDown",
        "onClick",
        "onKeyDown",
        "aria-labelledby"
    ]);
    const ariaLabelledBy = ()=>{
        return formControlContext.getAriaLabelledBy(others.id, others["aria-label"], local["aria-labelledby"]);
    };
    // Focus the first placeholder segment from the end on mouse down/touch up in the field.
    const focusLast = ()=>{
        if (!ref) return;
        // Try to find the segment prior to the element that was clicked on.
        let target = (0, _utils.getWindow)(ref).event?.target;
        const walker = (0, _utils.getFocusableTreeWalker)(ref, {
            tabbable: true
        });
        if (target) {
            walker.currentNode = target;
            target = walker.previousNode();
        }
        // If no target found, find the last element from the end.
        if (!target) {
            let last;
            do {
                last = walker.lastChild();
                if (last) target = last;
            }while (last);
        }
        // Now go backwards until we find an element that is not a placeholder.
        while(target?.hasAttribute("data-placeholder")){
            const prev = walker.previousNode();
            if (prev && prev.hasAttribute("data-placeholder")) target = prev;
            else break;
        }
        if (target) target.focus();
    };
    let pointerDownType = null;
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        pointerDownType = e.pointerType;
        // Focus last occurs on mouse down.
        if (e.pointerType === "mouse") focusLast();
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        // If pointerType is touch/pen, make focus last happen on click.
        if (pointerDownType !== "mouse") focusLast();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        // Open the popover on alt + arrow down/up
        if (e.altKey && (e.key === "ArrowDown" || e.key === "ArrowUp")) {
            e.preventDefault();
            e.stopPropagation();
            context.open();
        }
        switch(e.key){
            case "ArrowLeft":
                e.preventDefault();
                e.stopPropagation();
                if (context.direction() === "rtl") context.focusManager().focusNext();
                else context.focusManager().focusPrevious();
                break;
            case "ArrowRight":
                e.preventDefault();
                e.stopPropagation();
                if (context.direction() === "rtl") context.focusManager().focusPrevious();
                else context.focusManager().focusNext();
                break;
        }
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        role: "group",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                context.setControlRef(el);
                ref = el;
            }, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get ["aria-disabled"] () {
            return context.isDisabled() || undefined;
        },
        get ["aria-labelledby"] () {
            return ariaLabelledBy();
        },
        get ["aria-describedby"] () {
            return context.ariaDescribedBy();
        },
        onPointerDown: onPointerDown,
        onClick: onClick,
        onKeyDown: onKeyDown
    }, ()=>context.dataset(), ()=>formControlContext.dataset(), others));
}
const DatePickerInputContext = (0, _solidJs.createContext)();
function useDatePickerInputContext() {
    const context = (0, _solidJs.useContext)(DatePickerInputContext);
    if (context === undefined) throw new Error("[kobalte]: `useDatePickerInputContext` must be used within a `DatePicker.Input` component");
    return context;
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/950d45db36e63851f411ed0dc6a5aad0af57da68/packages/@react-stately/datepicker/src/utils.ts
 */ const DEFAULT_FIELD_OPTIONS = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit"
};
const TWO_DIGIT_FIELD_OPTIONS = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
};
function getDateFieldFormatOptions(fieldOptions, options) {
    const defaultFieldOptions = options.shouldForceLeadingZeros ? TWO_DIGIT_FIELD_OPTIONS : DEFAULT_FIELD_OPTIONS;
    const finalFieldOptions = {
        ...defaultFieldOptions,
        ...fieldOptions
    };
    const granularity = options.granularity || "minute";
    const keys = Object.keys(finalFieldOptions);
    let startIdx = keys.indexOf(options.maxGranularity ?? "year");
    if (startIdx < 0) startIdx = 0;
    let endIdx = keys.indexOf(granularity);
    if (endIdx < 0) endIdx = 2;
    if (startIdx > endIdx) throw new Error("maxGranularity must be greater than granularity");
    const opts = keys.slice(startIdx, endIdx + 1).reduce((opts, key)=>{
        // @ts-ignore
        opts[key] = finalFieldOptions[key];
        return opts;
    }, {});
    if (options.hourCycle != null) opts.hour12 = options.hourCycle === 12;
    opts.timeZone = options.timeZone || "UTC";
    const hasTime = granularity === "hour" || granularity === "minute" || granularity === "second";
    if (hasTime && options.timeZone && !options.hideTimeZone) opts.timeZoneName = "short";
    if (options.showEra && startIdx === 0) opts.era = "short";
    return opts;
}
function getPlaceholderTime(placeholderValue) {
    if (placeholderValue && "hour" in placeholderValue) return placeholderValue;
    return new (0, _date.Time)();
}
function convertValue(value, calendar) {
    if (value === null) return null;
    if (!value) return undefined;
    return (0, _date.toCalendar)(value, calendar);
}
function createPlaceholderDate(placeholderValue, granularity, calendar, timeZone) {
    if (placeholderValue) return convertValue(placeholderValue, calendar);
    const date = (0, _date.toCalendar)((0, _date.now)(timeZone).set({
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    }), calendar);
    if (granularity === "year" || granularity === "month" || granularity === "day") return (0, _date.toCalendarDate)(date);
    if (!timeZone) return (0, _date.toCalendarDateTime)(date);
    return date;
}
function createDefaultProps(props) {
    let lastValue;
    // Compute default granularity and time zone from the value.
    // If the value becomes null, keep the last value.
    const value = (0, _solidJs.createMemo)(()=>{
        const resolvedValue = props.value();
        if (resolvedValue) lastValue = resolvedValue;
        return lastValue;
    });
    const defaultTimeZone = (0, _solidJs.createMemo)(()=>{
        const resolvedValue = value();
        if (resolvedValue && "timeZone" in resolvedValue) return resolvedValue.timeZone;
        return undefined;
    });
    const granularity = (0, _solidJs.createMemo)(()=>{
        const resolvedValue = value();
        return props.granularity() || (resolvedValue && "minute" in resolvedValue ? "minute" : "day");
    });
    (0, _solidJs.createEffect)(()=>{
        const resolvedValue = value();
        const resolvedGranularity = granularity();
        // granularity must actually exist in the value if one is provided.
        if (resolvedValue && !(resolvedGranularity in resolvedValue)) throw new Error("Invalid granularity " + resolvedGranularity + " for value " + resolvedValue.toString());
    });
    return {
        granularity,
        defaultTimeZone
    };
}
const EDITABLE_SEGMENTS = {
    year: true,
    month: true,
    day: true,
    hour: true,
    minute: true,
    second: true,
    dayPeriod: true,
    era: true
};
const PAGE_STEP = {
    year: 5,
    month: 2,
    day: 7,
    hour: 2,
    minute: 15,
    second: 15
};
// Node seems to convert everything to lowercase...
const TYPE_MAPPING = {
    dayperiod: "dayPeriod"
};
function DatePickerInput(props) {
    const formControlContext = useFormControlContext();
    const datePickerContext = useDatePickerContext();
    props = (0, _utils.mergeDefaultProps)({
        id: datePickerContext.generateId("input")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "children",
        "onFocusOut",
        "aria-labelledby",
        "aria-describedby"
    ]);
    const timeZone = (0, _solidJs.createMemo)(()=>datePickerContext.defaultTimeZone() || "UTC");
    const defaultFormatter = (0, _solidJs.createMemo)(()=>new (0, _date.DateFormatter)(datePickerContext.locale()));
    const calendar = (0, _solidJs.createMemo)(()=>{
        return datePickerContext.createCalendar(defaultFormatter().resolvedOptions().calendar);
    });
    const calendarValue = (0, _solidJs.createMemo)(()=>{
        if (datePickerContext.selectionMode() === "single") return convertValue(asSingleValue(datePickerContext.dateValue()), calendar());
        else if (datePickerContext.selectionMode() === "multiple") ;
        else datePickerContext.selectionMode();
    });
    // We keep track of the placeholder date separately in state so that onChange is not called
    // until all segments are set. If the value === null (not undefined), then assume the component
    // is controlled, so use the placeholder as the value until all segments are entered, so it doesn't
    // change from uncontrolled to controlled.
    const [placeholderDate, setPlaceholderDate] = (0, _solidJs.createSignal)(createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone()));
    const val = (0, _solidJs.createMemo)(()=>calendarValue() || placeholderDate());
    const showEra = (0, _solidJs.createMemo)(()=>calendar().identifier === "gregory" && val()?.era === "BC");
    const formatOpts = (0, _solidJs.createMemo)(()=>({
            granularity: datePickerContext.granularity(),
            maxGranularity: datePickerContext.maxGranularity() ?? "year",
            timeZone: datePickerContext.defaultTimeZone(),
            hideTimeZone: datePickerContext.hideTimeZone(),
            hourCycle: datePickerContext.hourCycle(),
            showEra: showEra(),
            shouldForceLeadingZeros: datePickerContext.shouldForceLeadingZeros()
        }));
    const opts = (0, _solidJs.createMemo)(()=>getDateFieldFormatOptions({}, formatOpts()));
    const dateFormatter = (0, _solidJs.createMemo)(()=>new (0, _date.DateFormatter)(datePickerContext.locale(), opts()));
    const resolvedOptions = (0, _solidJs.createMemo)(()=>dateFormatter().resolvedOptions());
    const ariaLabelledBy = (0, _solidJs.createMemo)(()=>{
        return formControlContext.getAriaLabelledBy(others.id, others["aria-label"], local["aria-labelledby"]);
    });
    const ariaDescribedBy = (0, _solidJs.createMemo)(()=>{
        return [
            local["aria-describedby"],
            datePickerContext.ariaDescribedBy()
        ].filter(Boolean).join(" ");
    });
    // Determine how many editable segments there are for validation purposes.
    // The result is cached for performance.
    const allSegments = (0, _solidJs.createMemo)(()=>{
        return dateFormatter().formatToParts(new Date()).filter((segment)=>EDITABLE_SEGMENTS[segment.type]).reduce((acc, segment)=>{
            acc[segment.type] = true;
            return acc;
        }, {});
    });
    const [validSegments, setValidSegments] = (0, _solidJs.createSignal)(datePickerContext.value() ? {
        ...allSegments()
    } : {});
    // If all segments are valid, use the date from state, otherwise use the placeholder date.
    const displayValue = (0, _solidJs.createMemo)(()=>{
        return calendarValue() && Object.keys(validSegments()).length >= Object.keys(allSegments()).length ? calendarValue() : placeholderDate();
    });
    const setValue = (newValue)=>{
        if (formControlContext.isDisabled() || formControlContext.isReadOnly()) return;
        if (datePickerContext.selectionMode() === "single") {
            if (Object.keys(validSegments()).length >= Object.keys(allSegments()).length) {
                const v = asSingleValue(datePickerContext.value() || datePickerContext.placeholderValue());
                // The display calendar should not have any effect on the emitted value.
                // Emit dates in the same calendar as the original value, if any, otherwise gregorian.
                datePickerContext.setDateValue((0, _date.toCalendar)(newValue, v?.calendar || new (0, _date.GregorianCalendar)()));
            } else setPlaceholderDate(newValue);
        } else if (datePickerContext.selectionMode() === "multiple") ;
        else datePickerContext.selectionMode();
    };
    const dateValue = (0, _solidJs.createMemo)(()=>displayValue()?.toDate(timeZone()));
    const segments = (0, _solidJs.createMemo)(()=>{
        const resolvedDateValue = dateValue();
        const resolvedDisplayValue = displayValue();
        if (!resolvedDateValue || !resolvedDisplayValue) return [];
        return dateFormatter().formatToParts(resolvedDateValue).map((segment)=>{
            const isOriginallyEditable = EDITABLE_SEGMENTS[segment.type];
            let isEditable = isOriginallyEditable;
            if (segment.type === "era" && calendar().getEras().length === 1) isEditable = false;
            const isPlaceholder = isOriginallyEditable && !validSegments()[segment.type];
            const placeholder = isOriginallyEditable ? getPlaceholder(datePickerContext.translations(), segment.type, segment.value) : null;
            return {
                type: TYPE_MAPPING[segment.type] || segment.type,
                text: isPlaceholder ? placeholder : segment.value,
                ...getSegmentLimits(resolvedDisplayValue, segment.type, resolvedOptions()),
                isPlaceholder,
                placeholder,
                isEditable
            };
        });
    });
    const markValid = (part)=>{
        setValidSegments((prev)=>{
            const newValue = {
                ...prev,
                [part]: true
            };
            if (part === "year" && allSegments().era) newValue.era = true;
            return newValue;
        });
    };
    const adjustSegment = (type, amount)=>{
        const resolvedDisplayValue = displayValue();
        if (!validSegments()[type]) {
            markValid(type);
            if (resolvedDisplayValue && Object.keys(validSegments()).length >= Object.keys(allSegments()).length) setValue(resolvedDisplayValue);
        } else if (resolvedDisplayValue) {
            const newValue = addSegment(resolvedDisplayValue, type, amount, resolvedOptions());
            if (newValue) setValue(newValue);
        }
    };
    /**
   * Increments the given segment.
   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.
   */ const increment = (part)=>{
        adjustSegment(part, 1);
    };
    /**
   * Decrements the given segment.
   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.
   */ const decrement = (part)=>{
        adjustSegment(part, -1);
    };
    /**
   * Increments the given segment by a larger amount, rounding it to the nearest increment.
   * The amount to increment by depends on the field, for example 15 minutes, 7 days, and 5 years.
   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.
   */ const incrementPage = (part)=>{
        adjustSegment(part, PAGE_STEP[part] || 1);
    };
    /**
   * Decrements the given segment by a larger amount, rounding it to the nearest increment.
   * The amount to decrement by depends on the field, for example 15 minutes, 7 days, and 5 years.
   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.
   */ const decrementPage = (part)=>{
        adjustSegment(part, -(PAGE_STEP[part] || 1));
    };
    /** Sets the value of the given segment. */ const setSegment = (part, value)=>{
        markValid(part);
        const resolvedDisplayValue = displayValue();
        if (resolvedDisplayValue) {
            const newValue = setSegmentBase(resolvedDisplayValue, part, value, resolvedOptions());
            if (newValue) setValue(newValue);
        }
    };
    /** Clears the value of the given segment, reverting it to the placeholder. */ const clearSegment = (part)=>{
        setValidSegments((prev)=>{
            const newValue = {
                ...prev
            };
            delete newValue[part];
            return newValue;
        });
        const placeholder = createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone());
        const resolvedDisplayValue = displayValue();
        let value = resolvedDisplayValue;
        // Reset day period to default without changing the hour.
        if (resolvedDisplayValue && placeholder) {
            if (part === "dayPeriod" && "hour" in resolvedDisplayValue && "hour" in placeholder) {
                const isPM = resolvedDisplayValue.hour >= 12;
                const shouldBePM = placeholder.hour >= 12;
                if (isPM && !shouldBePM) value = resolvedDisplayValue.set({
                    hour: resolvedDisplayValue.hour - 12
                });
                else if (!isPM && shouldBePM) value = resolvedDisplayValue.set({
                    hour: resolvedDisplayValue.hour + 12
                });
            } else if (part in resolvedDisplayValue) value = resolvedDisplayValue.set({
                [part]: placeholder[part]
            });
        }
        datePickerContext.setDateValue(undefined);
        if (value) setValue(value);
    };
    /** Formats the current date value using the given options. */ const formatValue = (fieldOptions)=>{
        const resolvedDateValue = dateValue();
        if (!calendarValue() || !resolvedDateValue) return "";
        const formatOptions = getDateFieldFormatOptions(fieldOptions, formatOpts());
        const formatter = new (0, _date.DateFormatter)(datePickerContext.locale(), formatOptions);
        return formatter.format(resolvedDateValue);
    };
    const onFocusOut = (e)=>{
        (0, _utils.callHandler)(e, local.onFocusOut);
        if (formControlContext.isDisabled() || formControlContext.isReadOnly()) return;
        // Confirm the placeholder if only the day period is not filled in.
        const validKeys = Object.keys(validSegments());
        const allKeys = Object.keys(allSegments());
        if (validKeys.length === allKeys.length - 1 && allSegments().dayPeriod && !validSegments().dayPeriod) {
            setValidSegments({
                ...allSegments()
            });
            const resolvedDisplayValue = displayValue();
            if (resolvedDisplayValue) setValue(resolvedDisplayValue.copy());
        }
    };
    // Reset placeholder when calendar changes
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        calendar,
        timeZone,
        validSegments,
        ()=>datePickerContext.placeholderValue(),
        ()=>datePickerContext.granularity()
    ], ([calendar, timeZone, validSegments, placeholderValue, granularity])=>{
        setPlaceholderDate((placeholder)=>{
            return Object.keys(validSegments).length > 0 ? convertValue(placeholder, calendar) : createPlaceholderDate(placeholderValue, granularity, calendar, timeZone);
        });
    }));
    // If there is a value prop, and some segments were previously placeholders, mark them all as valid.
    (0, _solidJs.createEffect)(()=>{
        if (datePickerContext.value() && Object.keys(validSegments()).length < Object.keys(allSegments()).length) setValidSegments({
            ...allSegments()
        });
    });
    // If the value is set to null and all segments are valid, reset the placeholder.
    (0, _solidJs.createEffect)(()=>{
        if (datePickerContext.value() == null) {
            setValidSegments({});
            setPlaceholderDate(createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone()));
        }
    });
    // When the era field appears, mark it valid if the year field is already valid.
    // If the era field disappears, remove it from the valid segments.
    (0, _solidJs.createEffect)(()=>{
        if (allSegments().era && validSegments().year && !validSegments().era) setValidSegments((prev)=>({
                ...prev,
                era: true
            }));
        else if (!allSegments().era && validSegments().era) setValidSegments((prev)=>{
            const newValue = {
                ...prev
            };
            delete newValue.era;
            return newValue;
        });
    });
    const context = {
        calendar,
        dateValue,
        dateFormatterResolvedOptions: resolvedOptions,
        ariaLabel: ()=>others["aria-label"],
        ariaLabelledBy,
        ariaDescribedBy,
        segments,
        increment,
        decrement,
        incrementPage,
        decrementPage,
        setSegment,
        clearSegment,
        formatValue
    };
    return (0, _web.createComponent)(DatePickerInputContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                role: "presentation",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                onFocusOut: onFocusOut,
                get ["aria-labelledby"] () {
                    return ariaLabelledBy();
                },
                get ["aria-describedby"] () {
                    return ariaDescribedBy();
                }
            }, ()=>datePickerContext.dataset(), ()=>formControlContext.dataset(), others, {
                get children () {
                    return (0, _web.createComponent)((0, _solidJs.Index), {
                        get each () {
                            return segments();
                        },
                        children: (segment)=>local.children?.(segment)
                    });
                }
            }));
        }
    });
}
function getSegmentLimits(date, type, options) {
    switch(type){
        case "era":
            {
                const eras = date.calendar.getEras();
                return {
                    value: eras.indexOf(date.era),
                    minValue: 0,
                    maxValue: eras.length - 1
                };
            }
        case "year":
            return {
                value: date.year,
                minValue: 1,
                maxValue: date.calendar.getYearsInEra(date)
            };
        case "month":
            return {
                value: date.month,
                minValue: (0, _date.getMinimumMonthInYear)(date),
                maxValue: date.calendar.getMonthsInYear(date)
            };
        case "day":
            return {
                value: date.day,
                minValue: (0, _date.getMinimumDayInMonth)(date),
                maxValue: date.calendar.getDaysInMonth(date)
            };
    }
    if ("hour" in date) switch(type){
        case "dayPeriod":
            return {
                value: date.hour >= 12 ? 12 : 0,
                minValue: 0,
                maxValue: 12
            };
        case "hour":
            if (options.hour12) {
                const isPM = date.hour >= 12;
                return {
                    value: date.hour,
                    minValue: isPM ? 12 : 0,
                    maxValue: isPM ? 23 : 11
                };
            }
            return {
                value: date.hour,
                minValue: 0,
                maxValue: 23
            };
        case "minute":
            return {
                value: date.minute,
                minValue: 0,
                maxValue: 59
            };
        case "second":
            return {
                value: date.second,
                minValue: 0,
                maxValue: 59
            };
    }
    return {};
}
function addSegment(value, part, amount, options) {
    switch(part){
        case "era":
        case "year":
        case "month":
        case "day":
            return value.cycle(part, amount, {
                round: part === "year"
            });
    }
    if ("hour" in value) switch(part){
        case "dayPeriod":
            {
                const hours = value.hour;
                const isPM = hours >= 12;
                return value.set({
                    hour: isPM ? hours - 12 : hours + 12
                });
            }
        case "hour":
        case "minute":
        case "second":
            return value.cycle(part, amount, {
                round: part !== "hour",
                hourCycle: options.hour12 ? 12 : 24
            });
    }
}
function setSegmentBase(value, part, segmentValue, options) {
    switch(part){
        case "day":
        case "month":
        case "year":
        case "era":
            return value.set({
                [part]: segmentValue
            });
    }
    if ("hour" in value) switch(part){
        case "dayPeriod":
            {
                const hours = value.hour;
                const wasPM = hours >= 12;
                const isPM = segmentValue >= 12;
                if (isPM === wasPM) return value;
                return value.set({
                    hour: wasPM ? hours - 12 : hours + 12
                });
            }
        case "hour":
            // In 12 hour time, ensure that AM/PM does not change
            if (options.hour12) {
                const hours1 = value.hour;
                const wasPM1 = hours1 >= 12;
                if (!wasPM1 && segmentValue === 12) segmentValue = 0;
                if (wasPM1 && segmentValue < 12) segmentValue += 12;
            }
        // fallthrough
        case "minute":
        case "second":
            return value.set({
                [part]: segmentValue
            });
    }
}
function getPlaceholder(translations, field, value) {
    // Use the actual placeholder value for the era and day period fields.
    if (field === "era" || field === "dayPeriod") return value;
    if (field === "year" || field === "month" || field === "day") return translations.placeholder[field];
    // For time fields (e.g. hour, minute, etc.), use two dashes as the placeholder.
    return "––";
}
/**
 * Portals its children into the `body` when the date picker is open.
 */ function DatePickerPortal(props) {
    const context = useDatePickerContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
const DATE_PICKER_INTL_MESSAGES = {
    era: "era",
    year: "year",
    month: "month",
    day: "day",
    hour: "hour",
    minute: "minute",
    second: "second",
    dayPeriod: "AM/PM",
    calendar: "Calendar",
    startDate: "Start Date",
    endDate: "End Date",
    weekday: "day of the week",
    timeZoneName: "time zone",
    selectedDateDescription: (date)=>`Selected Date: ${date}`,
    selectedRangeDescription: (startDate, endDate)=>`Selected Range: ${startDate} to ${endDate}`,
    selectedTimeDescription: (time)=>`Selected Time: ${time}`,
    placeholder: {
        year: "yyyy",
        month: "mm",
        day: "dd"
    }
};
/**
 * A date picker combines a `DateField` and a `Calendar` popover to allow users to enter or select a date and time value.
 */ function DatePickerRoot(props) {
    const defaultId = `date-picker-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        visibleDuration: {
            months: 1
        },
        selectionMode: "single",
        maxGranularity: "year",
        hideTimeZone: false,
        shouldForceLeadingZeros: false,
        modal: false,
        gutter: 8,
        sameWidth: false,
        placement: "bottom-start",
        translations: DATE_PICKER_INTL_MESSAGES
    }, props);
    const [local, popperProps, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "translations",
        "locale",
        "createCalendar",
        "visibleDuration",
        "selectionMode",
        "isDateUnavailable",
        "allowsNonContiguousRanges",
        "closeOnSelect",
        "minValue",
        "maxValue",
        "placeholderValue",
        "hourCycle",
        "granularity",
        "maxGranularity",
        "hideTimeZone",
        "shouldForceLeadingZeros",
        "validationState",
        "open",
        "defaultOpen",
        "onOpenChange",
        "value",
        "defaultValue",
        "onChange",
        "modal",
        "forceMount"
    ], [
        "getAnchorRect",
        "placement",
        "gutter",
        "shift",
        "flip",
        "slide",
        "overlap",
        "sameWidth",
        "fitViewport",
        "hideWhenDetached",
        "detachedPadding",
        "arrowPadding",
        "overflowPadding"
    ], FORM_CONTROL_PROP_NAMES);
    const [triggerId, setTriggerId] = (0, _solidJs.createSignal)();
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const [controlRef, setControlRef] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const locale = (0, _solidJs.createMemo)(()=>{
        return local.locale ?? useLocale().locale();
    });
    const direction = (0, _solidJs.createMemo)(()=>{
        return getReadingDirection(locale());
    });
    const focusManager = (0, _utils.createFocusManager)(controlRef);
    const closeOnSelect = (0, _solidJs.createMemo)(()=>{
        return local.closeOnSelect ?? local.selectionMode !== "multiple";
    });
    const [value, setValue] = createControllableSignal({
        value: ()=>local.value,
        defaultValue: ()=>local.defaultValue,
        onChange: (value)=>local.onChange?.(value)
    });
    // The date portion of the selected date, dates or range.
    const [selectedDate, setSelectedDate] = (0, _solidJs.createSignal)();
    // The time portion of the selected date or range.
    const [selectedTime, setSelectedTime] = (0, _solidJs.createSignal)();
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const { granularity , defaultTimeZone  } = createDefaultProps({
        value: ()=>getFirstValueOfSelection(local.selectionMode, value()) ?? local.placeholderValue,
        granularity: ()=>local.granularity
    });
    const contentPresence = createPresence(()=>local.forceMount || disclosureState.isOpen());
    const validationState = (0, _solidJs.createMemo)(()=>{
        if (local.validationState) return local.validationState;
        const values = getArrayValueOfSelection(local.selectionMode, value());
        if (values.length <= 0) return undefined;
        const isSomeDateInvalid = values.some((date)=>{
            return local.isDateUnavailable?.(date) || isDateInvalid(date, local.minValue, local.maxValue);
        });
        return isSomeDateInvalid ? "invalid" : undefined;
    });
    const { formControlContext  } = createFormControl((0, _solidJs.mergeProps)(formControlProps, {
        // override the `validationState` provided by prop to include additional logic.
        get validationState () {
            return validationState();
        }
    }));
    createFormResetListener(contentRef, ()=>{
        setValue(local.defaultValue);
    });
    const hasTime = (0, _solidJs.createMemo)(()=>{
        return granularity() === "hour" || granularity() === "minute" || granularity() === "second";
    });
    const formattedValue = (0, _solidJs.createMemo)(()=>{
        const firstValue = getFirstValueOfSelection(local.selectionMode, value());
        if (!firstValue) return "";
        const formatOptions = getDateFieldFormatOptions({
            month: "long"
        }, {
            granularity: granularity(),
            timeZone: defaultTimeZone(),
            hideTimeZone: local.hideTimeZone,
            hourCycle: local.hourCycle,
            showEra: firstValue.calendar.identifier === "gregory" && firstValue.era === "BC"
        });
        const dateFormatter = (0, _solidJs.createMemo)(()=>new (0, _date.DateFormatter)(locale(), formatOptions));
        const formatDate = (date)=>{
            return date ? dateFormatter().format(date.toDate(defaultTimeZone() ?? "UTC")) : "";
        };
        let formattedValue;
        if (local.selectionMode === "single") formattedValue = formatDate(asSingleValue(value()));
        else if (local.selectionMode === "multiple") formattedValue = asArrayValue(value())?.map(formatDate).join(", ");
        else local.selectionMode;
        return formattedValue ?? "";
    });
    const ariaDescribedBy = ()=>{
        let description = "";
        if (local.selectionMode === "single" || local.selectionMode === "multiple") description = local.translations.selectedDateDescription(formattedValue());
        else local.selectionMode;
        return formControlContext.getAriaDescribedBy(description);
    };
    const commitSingleValue = (date, time)=>{
        setValue("timeZone" in time ? time.set((0, _date.toCalendarDate)(date)) : (0, _date.toCalendarDateTime)(date, time));
    };
    // Intercept `setValue` to make sure the Time section is not changed by date selection in Calendar.
    const selectDate = (newValue)=>{
        if (local.selectionMode === "single") {
            if (hasTime()) {
                const resolvedSelectedTime = selectedTime();
                if (resolvedSelectedTime || closeOnSelect()) commitSingleValue(newValue, resolvedSelectedTime || getPlaceholderTime(local.placeholderValue));
                else setSelectedDate(newValue);
            } else setValue(newValue);
            if (closeOnSelect()) disclosureState.close();
        } else if (local.selectionMode === "multiple") setValue(newValue);
        else local.selectionMode;
    };
    const selectTime = (newValue)=>{
        if (local.selectionMode === "single") {
            const resolvedSelectedDate = selectedDate();
            if (resolvedSelectedDate && newValue) commitSingleValue(resolvedSelectedDate, newValue);
            else setSelectedTime(newValue);
        } else local.selectionMode;
    };
    const close = ()=>{
        if (local.selectionMode === "single") {
            const resolvedSelectedDate = selectedDate();
            const resolvedSelectedTime = selectedTime();
            // Commit the selected date when the calendar is closed. Use a placeholder time if one wasn't set.
            // If only the time was set and not the date, don't commit.
            // The state will be preserved until the user opens the popover again.
            if (!value() && resolvedSelectedDate && hasTime()) commitSingleValue(resolvedSelectedDate, resolvedSelectedTime || getPlaceholderTime(local.placeholderValue));
        } else local.selectionMode;
        disclosureState.close();
    };
    const toggle = ()=>{
        if (disclosureState.isOpen()) close();
        else disclosureState.open();
    };
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    (0, _solidJs.createEffect)((0, _solidJs.on)(value, (value)=>{
        if (!value) {
            setSelectedDate(undefined);
            setSelectedTime(undefined);
            return;
        }
        if (local.selectionMode === "single") {
            setSelectedDate(value);
            if ("hour" in value) setSelectedTime(value);
        } else if (local.selectionMode === "multiple") setSelectedDate(value);
        else local.selectionMode;
    }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        isDisabled: ()=>formControlContext.isDisabled() ?? false,
        isModal: ()=>local.modal ?? false,
        contentPresence,
        translations: ()=>local.translations,
        granularity,
        maxGranularity: ()=>local.maxGranularity,
        hourCycle: ()=>local.hourCycle,
        hideTimeZone: ()=>local.hideTimeZone ?? false,
        defaultTimeZone,
        shouldForceLeadingZeros: ()=>local.shouldForceLeadingZeros ?? false,
        visibleDuration: ()=>local.visibleDuration,
        selectionMode: ()=>local.selectionMode,
        allowsNonContiguousRanges: ()=>local.allowsNonContiguousRanges ?? false,
        placeholderValue: ()=>local.placeholderValue,
        minValue: ()=>local.minValue,
        maxValue: ()=>local.maxValue,
        focusManager: ()=>focusManager,
        locale,
        direction,
        ariaDescribedBy,
        validationState,
        value,
        dateValue: selectedDate,
        timeValue: selectedTime,
        triggerId,
        contentId,
        controlRef,
        triggerRef,
        contentRef,
        setControlRef,
        setTriggerRef,
        setContentRef,
        createCalendar: (name)=>local.createCalendar(name),
        isDateUnavailable: (date)=>local.isDateUnavailable?.(date) ?? false,
        setDateValue: selectDate,
        setTimeValue: selectTime,
        open: disclosureState.open,
        close,
        toggle,
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        registerTriggerId: createRegisterId(setTriggerId),
        registerContentId: createRegisterId(setContentId)
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(DatePickerContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                        anchorRef: controlRef,
                        contentRef: contentRef
                    }, popperProps, {
                        get children () {
                            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                                as: "div",
                                role: "group",
                                get id () {
                                    return (0, _utils.access)(formControlProps.id);
                                }
                            }, ()=>formControlContext.dataset(), dataset, others));
                        }
                    }));
                }
            });
        }
    });
}
const SPIN_BUTTON_INTL_TRANSLATIONS = {
    empty: "Empty"
};
function SpinButtonRoot(props) {
    props = (0, _utils.mergeDefaultProps)({
        translations: SPIN_BUTTON_INTL_TRANSLATIONS
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "translations",
        "ref",
        "value",
        "textValue",
        "minValue",
        "maxValue",
        "validationState",
        "required",
        "disabled",
        "readOnly",
        "onIncrement",
        "onIncrementPage",
        "onDecrement",
        "onDecrementPage",
        "onDecrementToMin",
        "onIncrementToMax",
        "onKeyDown",
        "onFocus",
        "onBlur"
    ]);
    let isFocused = false;
    // Replace Unicode hyphen-minus (U+002D) with minus sign (U+2212).
    // This ensures that macOS VoiceOver announces it as "minus" even with other characters between the minus sign
    // and the number (e.g. currency symbol). Otherwise, it announces nothing because it assumes the character is a hyphen.
    // In addition, replace the empty string with the word "Empty" so that iOS VoiceOver does not read "50%" for an empty field.
    const textValue = (0, _solidJs.createMemo)(()=>{
        if (local.textValue === "") return local.translations?.empty;
        return (local.textValue || `${local.value}`).replace("-", "−");
    });
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey || local.readOnly) return;
        switch(e.key){
            case "PageUp":
                if (local.onIncrementPage) {
                    e.preventDefault();
                    local.onIncrementPage();
                    break;
                }
            // fallthrough!
            case "ArrowUp":
            case "Up":
                if (local.onIncrement) {
                    e.preventDefault();
                    local.onIncrement();
                }
                break;
            case "PageDown":
                if (local.onDecrementPage) {
                    e.preventDefault();
                    local.onDecrementPage();
                    break;
                }
            // fallthrough
            case "ArrowDown":
            case "Down":
                if (local.onDecrement) {
                    e.preventDefault();
                    local.onDecrement();
                }
                break;
            case "Home":
                if (local.onDecrementToMin) {
                    e.preventDefault();
                    local.onDecrementToMin();
                }
                break;
            case "End":
                if (local.onIncrementToMax) {
                    e.preventDefault();
                    local.onIncrementToMax();
                }
                break;
        }
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        isFocused = true;
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        isFocused = false;
    };
    (0, _solidJs.createEffect)((0, _solidJs.on)(textValue, (textValue)=>{
        if (isFocused) {
            clearAnnouncer("assertive");
            announce(textValue ?? "", "assertive");
        }
    }));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        as: "div",
        role: "spinbutton",
        get ["aria-valuenow"] () {
            return local.value != null && !isNaN(local.value) ? local.value : null;
        },
        get ["aria-valuetext"] () {
            return textValue();
        },
        get ["aria-valuemin"] () {
            return local.minValue;
        },
        get ["aria-valuemax"] () {
            return local.maxValue;
        },
        get ["aria-required"] () {
            return local.required || undefined;
        },
        get ["aria-disabled"] () {
            return local.disabled || undefined;
        },
        get ["aria-readonly"] () {
            return local.readOnly || undefined;
        },
        get ["aria-invalid"] () {
            return local.validationState === "invalid" || undefined;
        },
        onKeyDown: onKeyDown,
        onFocus: onFocus,
        onBlur: onBlur
    }, others));
}
function DatePickerSegment(props) {
    let ref;
    const formControlContext = useFormControlContext();
    const datePickerContext = useDatePickerContext();
    const inputContext = useDatePickerInputContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "segment",
        "children",
        "onKeyDown",
        "onBeforeInput",
        "onInput",
        "onFocus"
    ]);
    const [textValue, setTextValue] = (0, _solidJs.createSignal)(local.segment.isPlaceholder ? "" : local.segment.text);
    const resolvedChildren = (0, _solidJs.children)(()=>local.children);
    let enteredKeys = "";
    let composition = "";
    // spin buttons cannot be focused with VoiceOver on iOS.
    const touchPropOverrides = (0, _solidJs.createMemo)(()=>{
        return (0, _utils.isIOS)() || local.segment.type === "timeZoneName" ? {
            role: "textbox",
            "aria-valuemax": undefined,
            "aria-valuemin": undefined,
            "aria-valuetext": undefined,
            "aria-valuenow": undefined
        } : {};
    });
    const firstSegment = (0, _solidJs.createMemo)(()=>inputContext.segments().find((s)=>s.isEditable));
    // Prepend the label passed from the field to each segment name.
    // This is needed because VoiceOver on iOS does not announce groups.
    const name = (0, _solidJs.createMemo)(()=>{
        return local.segment.type === "literal" ? "" : datePickerContext.translations()[local.segment.type];
    });
    const ariaLabel = (0, _solidJs.createMemo)(()=>{
        return `${name()}${inputContext.ariaLabel() ? `, ${inputContext.ariaLabel()}` : ""}${inputContext.ariaLabelledBy() ? ", " : ""}`;
    });
    const ariaDescribedBy = (0, _solidJs.createMemo)(()=>{
        // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being
        // read every time the user navigates to a new segment.
        if (local.segment !== firstSegment() && formControlContext.validationState() !== "invalid") return undefined;
        return inputContext.ariaDescribedBy();
    });
    const isEditable = (0, _solidJs.createMemo)(()=>{
        return !formControlContext.isDisabled() && !formControlContext.isReadOnly() && local.segment.isEditable;
    });
    const inputMode = (0, _solidJs.createMemo)(()=>{
        return formControlContext.isDisabled() || local.segment.type === "dayPeriod" || local.segment.type === "era" || !isEditable() ? undefined : "numeric";
    });
    // Safari dayPeriod option doesn't work...
    const filter = createFilter({
        sensitivity: "base"
    });
    const options = (0, _solidJs.createMemo)(()=>inputContext.dateFormatterResolvedOptions());
    // Get a list of formatted era names so users can type the first character to choose one.
    const eraFormatter = createDateFormatter({
        year: "numeric",
        era: "narrow",
        timeZone: "UTC"
    });
    const monthDateFormatter = createDateFormatter(()=>({
            month: "long",
            timeZone: options().timeZone
        }));
    const hourDateFormatter = createDateFormatter(()=>({
            hour: "numeric",
            hour12: options().hour12,
            timeZone: options().timeZone
        }));
    const amPmFormatter = createDateFormatter({
        hour: "numeric",
        hour12: true
    });
    const eras = (0, _solidJs.createMemo)(()=>{
        if (local.segment.type !== "era") return [];
        const date = (0, _date.toCalendar)(new (0, _date.CalendarDate)(1, 1, 1), inputContext.calendar());
        const eras = inputContext.calendar().getEras().map((era)=>{
            const eraDate = date.set({
                year: 1,
                month: 1,
                day: 1,
                era
            }).toDate("UTC");
            const parts = eraFormatter().formatToParts(eraDate);
            const formatted = parts.find((p)=>p.type === "era")?.value ?? "";
            return {
                era,
                formatted
            };
        });
        // Remove the common prefix from formatted values. This is so that in calendars with eras like
        // ERA0 and ERA1 (e.g. Ethiopic), users can press "0" and "1" to select an era. In other cases,
        // the first letter is used.
        const prefixLength = commonPrefixLength(eras.map((era)=>era.formatted));
        if (prefixLength) for (const era of eras)era.formatted = era.formatted.slice(prefixLength);
        return eras;
    });
    const am = (0, _solidJs.createMemo)(()=>{
        const date = new Date();
        date.setHours(0);
        return amPmFormatter().formatToParts(date).find((part)=>part.type === "dayPeriod")?.value ?? "";
    });
    const pm = (0, _solidJs.createMemo)(()=>{
        const date = new Date();
        date.setHours(12);
        return amPmFormatter().formatToParts(date).find((part)=>part.type === "dayPeriod")?.value ?? "";
    });
    const numberParser = (0, _solidJs.createMemo)(()=>{
        return new (0, _number.NumberParser)(datePickerContext.locale(), {
            maximumFractionDigits: 0
        });
    });
    const onBackspaceKeyDown = ()=>{
        if (numberParser().isValidPartialNumber(local.segment.text) && !formControlContext.isReadOnly() && !local.segment.isPlaceholder) {
            const newValue = local.segment.text.slice(0, -1);
            const parsed = numberParser().parse(newValue);
            if (newValue.length === 0 || parsed === 0) inputContext.clearSegment(local.segment.type);
            else inputContext.setSegment(local.segment.type, parsed);
            enteredKeys = newValue;
        } else if (local.segment.type === "dayPeriod") inputContext.clearSegment(local.segment.type);
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        // Firefox does not fire selectstart for Ctrl/Cmd + A
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153
        if (e.key === "a" && ((0, _utils.isMac)() ? e.metaKey : e.ctrlKey)) e.preventDefault();
        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;
        switch(e.key){
            case "Backspace":
            case "Delete":
                // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.
                e.preventDefault();
                e.stopPropagation();
                onBackspaceKeyDown();
                break;
        }
    };
    const onInputBase = (key)=>{
        if (formControlContext.isDisabled() || formControlContext.isReadOnly()) return;
        const newValue = enteredKeys + key;
        switch(local.segment.type){
            case "dayPeriod":
                if (filter.startsWith(am(), key)) inputContext.setSegment("dayPeriod", 0);
                else if (filter.startsWith(pm(), key)) inputContext.setSegment("dayPeriod", 12);
                else break;
                datePickerContext.focusManager().focusNext();
                break;
            case "era":
                {
                    const matched = eras().find((e)=>filter.startsWith(e.formatted, key));
                    if (matched) {
                        inputContext.setSegment("era", +matched.era);
                        datePickerContext.focusManager().focusNext();
                    }
                    break;
                }
            case "day":
            case "hour":
            case "minute":
            case "second":
            case "month":
            case "year":
                {
                    if (!numberParser().isValidPartialNumber(newValue)) return;
                    let numberValue = numberParser().parse(newValue);
                    let segmentValue = numberValue;
                    let allowsZero = local.segment.minValue === 0;
                    if (local.segment.type === "hour" && inputContext.dateFormatterResolvedOptions().hour12) {
                        switch(inputContext.dateFormatterResolvedOptions().hourCycle){
                            case "h11":
                                if (numberValue > 11) segmentValue = numberParser().parse(key);
                                break;
                            case "h12":
                                allowsZero = false;
                                if (numberValue > 12) segmentValue = numberParser().parse(key);
                                break;
                        }
                        if (local.segment.value != null && local.segment.value >= 12 && numberValue > 1) numberValue += 12;
                    } else if (local.segment.maxValue != null && numberValue > local.segment.maxValue) segmentValue = numberParser().parse(key);
                    if (isNaN(numberValue)) return;
                    const shouldSetValue = segmentValue !== 0 || allowsZero;
                    if (shouldSetValue) inputContext.setSegment(local.segment.type, segmentValue);
                    if (local.segment.maxValue != null && Number(numberValue + "0") > local.segment.maxValue || newValue.length >= String(local.segment.maxValue).length) {
                        enteredKeys = "";
                        if (shouldSetValue) datePickerContext.focusManager().focusNext();
                    } else enteredKeys = newValue;
                    break;
                }
        }
    };
    const onBeforeInput = (e)=>{
        (0, _utils.callHandler)(e, local.onBeforeInput);
        e.preventDefault();
        switch(e.inputType){
            case "deleteContentBackward":
            case "deleteContentForward":
                if (numberParser().isValidPartialNumber(local.segment.text) && !formControlContext.isReadOnly()) onBackspaceKeyDown();
                break;
            case "insertCompositionText":
                if (ref) {
                    // insertCompositionText cannot be canceled.
                    // Record the current state of the element, so we can restore it in the `input` event below.
                    composition = ref.textContent;
                    // Safari gets stuck in a composition state unless we also assign to the value here.
                    // eslint-disable-next-line no-self-assign
                    ref.textContent = ref.textContent;
                }
                break;
            default:
                if (e.data != null) onInputBase(e.data);
                break;
        }
    };
    const onInput = (e)=>{
        (0, _utils.callHandler)(e, local.onInput);
        const { inputType , data  } = e;
        if (ref && data != null) switch(inputType){
            case "insertCompositionText":
                // Reset the DOM to how it was in the beforeinput event.
                ref.textContent = composition;
                // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.
                // Can also happen e.g. with Pinyin keyboard on iOS.
                if (filter.startsWith(am(), data) || filter.startsWith(pm(), data)) onInputBase(data);
                break;
        }
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        if (ref) {
            enteredKeys = "";
            (0, _utils.scrollIntoViewport)(ref, {
                containingElement: (0, _utils.getScrollParent)(ref)
            });
            // Collapse selection to start or Chrome won't fire input events.
            const selection = (0, _utils.getWindow)(ref).getSelection();
            selection?.collapse(ref);
        }
    };
    const onIncrement = ()=>{
        enteredKeys = "";
        inputContext.increment(local.segment.type);
    };
    const onDecrement = ()=>{
        enteredKeys = "";
        inputContext.decrement(local.segment.type);
    };
    const onIncrementPage = ()=>{
        enteredKeys = "";
        inputContext.incrementPage(local.segment.type);
    };
    const onDecrementPage = ()=>{
        enteredKeys = "";
        inputContext.decrementPage(local.segment.type);
    };
    const onDecrementToMin = ()=>{
        if (local.segment.minValue == null) return;
        enteredKeys = "";
        inputContext.setSegment(local.segment.type, local.segment.minValue);
    };
    const onIncrementToMax = ()=>{
        if (local.segment.maxValue == null) return;
        enteredKeys = "";
        inputContext.setSegment(local.segment.type, local.segment.maxValue);
    };
    (0, _solidJs.createEffect)(()=>{
        const resolvedDateValue = inputContext.dateValue();
        if (resolvedDateValue) {
            if (local.segment.type === "month" && !local.segment.isPlaceholder) {
                const monthTextValue = monthDateFormatter().format(resolvedDateValue);
                setTextValue((prev)=>monthTextValue !== prev ? `${prev} – ${monthTextValue}` : monthTextValue);
            } else if (local.segment.type === "hour" && !local.segment.isPlaceholder) setTextValue(hourDateFormatter().format(resolvedDateValue));
        } else setTextValue(local.segment.isPlaceholder ? "" : local.segment.text);
    });
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>ref,
        ()=>datePickerContext.focusManager()
    ], ([ref, focusManager])=>{
        const element = ref;
        (0, _solidJs.onCleanup)(()=>{
            // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.
            if ((0, _utils.getActiveElement)(element) === element) {
                const prev = focusManager.focusPrevious();
                if (!prev) focusManager.focusNext();
            }
        });
    }));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return local.segment.type !== "literal";
        },
        get fallback () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                "aria-hidden": true,
                "data-separator": ""
            }, others, {
                get children () {
                    return local.segment.text;
                }
            }));
        },
        get children () {
            return (0, _web.createComponent)(SpinButtonRoot, (0, _web.mergeProps)({
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                get tabIndex () {
                    return formControlContext.isDisabled() ? undefined : 0;
                },
                get value () {
                    return local.segment.value;
                },
                get textValue () {
                    return textValue();
                },
                get minValue () {
                    return local.segment.minValue;
                },
                get maxValue () {
                    return local.segment.maxValue;
                },
                get validationState () {
                    return formControlContext.validationState();
                },
                get required () {
                    return formControlContext.isRequired();
                },
                get disabled () {
                    return formControlContext.isDisabled();
                },
                get readOnly () {
                    return formControlContext.isReadOnly() || !local.segment.isEditable;
                },
                get contentEditable () {
                    return isEditable();
                },
                get inputMode () {
                    return inputMode();
                },
                get autocorrect () {
                    return isEditable() ? "off" : undefined;
                },
                get autoCapitalize () {
                    return isEditable() ? "off" : undefined;
                },
                get spellcheck () {
                    return isEditable() ? false : undefined;
                },
                get enterkeyhint () {
                    return isEditable() ? "next" : undefined;
                },
                style: {
                    "caret-color": "transparent"
                },
                get ["aria-label"] () {
                    return ariaLabel();
                },
                get ["aria-labelledby"] () {
                    return inputContext.ariaLabelledBy();
                },
                get ["aria-describedby"] () {
                    return ariaDescribedBy();
                },
                get ["data-placeholder"] () {
                    return local.segment.isPlaceholder ? "" : undefined;
                },
                onKeyDown: onKeyDown,
                onBeforeInput: onBeforeInput,
                onInput: onInput,
                onFocus: onFocus,
                onIncrement: onIncrement,
                onDecrement: onDecrement,
                onIncrementPage: onIncrementPage,
                onDecrementPage: onDecrementPage,
                onDecrementToMin: onDecrementToMin,
                onIncrementToMax: onIncrementToMax
            }, ()=>datePickerContext.dataset(), ()=>formControlContext.dataset(), others, touchPropOverrides, {
                get children () {
                    return (0, _web.createComponent)((0, _solidJs.Show), {
                        get when () {
                            return resolvedChildren();
                        },
                        get fallback () {
                            return local.segment.text;
                        },
                        get children () {
                            return resolvedChildren();
                        }
                    });
                }
            }));
        }
    });
}
function commonPrefixLength(strings) {
    // Sort the strings, and compare the characters in the first and last to find the common prefix.
    strings.sort();
    const first = strings[0];
    const last = strings[strings.length - 1];
    for(let i = 0; i < first.length; i++){
        if (first[i] !== last[i]) return i;
    }
    return 0;
}
function DatePickerTrigger(props) {
    const formControlContext = useFormControlContext();
    const context = useDatePickerContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("trigger")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "disabled",
        "onPointerDown",
        "onClick",
        "aria-labelledby"
    ]);
    const isDisabled = ()=>{
        return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        // Prevent pointer events from reaching `DatePicker.Control`.
        e.stopPropagation();
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        // Prevent click events from reaching `DatePicker.Control`.
        e.stopPropagation();
        if (!isDisabled()) context.toggle();
    };
    const ariaLabel = (0, _solidJs.createMemo)(()=>{
        return context.translations().calendar;
    });
    const ariaLabelledBy = ()=>{
        return formControlContext.getAriaLabelledBy(others.id, ariaLabel(), local["aria-labelledby"]);
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTriggerId(others.id)));
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get disabled () {
            return isDisabled();
        },
        "aria-haspopup": "dialog",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        get ["aria-label"] () {
            return ariaLabel();
        },
        get ["aria-labelledby"] () {
            return ariaLabelledBy();
        },
        get ["aria-describedby"] () {
            return context.ariaDescribedBy();
        },
        onPointerDown: onPointerDown,
        onClick: onClick
    }, ()=>context.dataset(), others));
}
/*

<DatePicker.Root>
  <DatePicker.Label/>
  <DatePicker.Control>
    <DatePicker.Input> // DateField
      {segment => <DatePicker.Segment segment={segment} />}
    </DatePicker.Input>
    <DatePicker.Trigger/>
  </DatePicker.Control>
  <DatePicker.Description/>
  <DatePicker.ErrorMessage/>
  <DatePicker.Portal>
    <DatePicker.Content>
      <DatePicker.Arrow/>
      <DatePicker.Calendar>
        <DatePicker.CalendarHeader>
          <DatePicker.CalendarPrevTrigger/>
          <DatePicker.CalendarViewTrigger/>
          <DatePicker.CalendarNextTrigger/>
        </DatePicker.CalendarHeader>
        <DatePicker.CalendarBody>
          <DatePicker.CalendarGrid>
            <DatePicker.CalendarGridHeader>
              <DatePicker.CalendarGridHeaderRow>
                {weekDay => (
                  <DatePicker.CalendarGridHeaderCell>
                    {weekDay()}
                  </DatePicker.CalendarGridHeaderCell>
                )}
              </DatePicker.CalendarGridHeaderRow>
            </DatePicker.CalendarGridHeader>
            <DatePicker.CalendarGridBody>
              {weekIndex => (
                <DatePicker.CalendarGridBodyRow weekIndex={weekIndex()}>
                  {date => (
                    <DatePicker.CalendarGridBodyCell date={date()}>
                      <DatePicker.CalendarGridBodyCellTrigger/>
                    </DatePicker.CalendarGridBodyCell>
                  )}
                </DatePicker.CalendarGridBodyRow>
              )}
            </DatePicker.CalendarGridBody>
          </DatePicker.CalendarGrid>
        </DatePicker.CalendarBody>
      </DatePicker.Calendar>
    </DatePicker.Content>
  </DatePicker.Portal>
</DatePicker.Root>

*/ var index$g = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    Calendar: DatePickerCalendar,
    CalendarBody: CalendarBody,
    CalendarGrid: CalendarGrid,
    CalendarGridBody: CalendarGridBody,
    CalendarGridBodyCell: CalendarGridBodyCell,
    CalendarGridBodyCellTrigger: CalendarGridBodyCellTrigger,
    CalendarGridBodyRow: CalendarGridBodyRow,
    CalendarGridHeader: CalendarGridHeader,
    CalendarGridHeaderCell: CalendarGridHeaderCell,
    CalendarGridHeaderRow: CalendarGridHeaderRow,
    CalendarHeader: CalendarHeader,
    CalendarHeading: CalendarHeading,
    CalendarNextTrigger: CalendarNextTrigger,
    CalendarPrevTrigger: CalendarPrevTrigger,
    Content: DatePickerContent,
    Control: DatePickerControl,
    Description: FormControlDescription,
    ErrorMessage: FormControlErrorMessage,
    Input: DatePickerInput,
    Portal: DatePickerPortal,
    Root: DatePickerRoot,
    Segment: DatePickerSegment,
    Trigger: DatePickerTrigger
});
/**
 * Contains the content to be rendered when the dropdown menu is open.
 */ function DropdownMenuContent(props) {
    const rootContext = useMenuRootContext();
    const context = useMenuContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onCloseAutoFocus",
        "onInteractOutside"
    ]);
    let hasInteractedOutside = false;
    const onCloseAutoFocus = (e)=>{
        local.onCloseAutoFocus?.(e);
        if (!hasInteractedOutside) (0, _utils.focusWithoutScrolling)(context.triggerRef());
        hasInteractedOutside = false;
        // Always prevent autofocus because we either focus manually or want user agent focus
        e.preventDefault();
    };
    const onInteractOutside = (e)=>{
        local.onInteractOutside?.(e);
        if (!rootContext.isModal() || e.detail.isContextMenu) hasInteractedOutside = true;
    };
    return (0, _web.createComponent)(MenuContent, (0, _web.mergeProps)({
        onCloseAutoFocus: onCloseAutoFocus,
        onInteractOutside: onInteractOutside
    }, others));
}
/**
 * Displays a menu to the user —such as a set of actions or functions— triggered by a button.
 */ function DropdownMenuRoot(props) {
    const defaultId = `dropdownmenu-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    return (0, _web.createComponent)(MenuRoot, props);
}
var index$f = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    CheckboxItem: MenuCheckboxItem,
    Content: DropdownMenuContent,
    Group: MenuGroup,
    GroupLabel: MenuGroupLabel,
    Icon: MenuIcon,
    Item: MenuItem,
    ItemDescription: MenuItemDescription,
    ItemIndicator: MenuItemIndicator,
    ItemLabel: MenuItemLabel,
    Portal: MenuPortal,
    RadioGroup: MenuRadioGroup,
    RadioItem: MenuRadioItem,
    Root: DropdownMenuRoot,
    Separator: SeparatorRoot,
    Sub: MenuSub,
    SubContent: MenuSubContent,
    SubTrigger: MenuSubTrigger,
    Trigger: MenuTrigger
});
const HoverCardContext = (0, _solidJs.createContext)();
function useHoverCardContext() {
    const context = (0, _solidJs.useContext)(HoverCardContext);
    if (context === undefined) throw new Error("[kobalte]: `useHoverCardContext` must be used within a `HoverCard` component");
    return context;
}
/**
 * Contains the content to be rendered when the hovercard is open.
 */ function HoverCardContent(props) {
    const context = useHoverCardContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style"
    ]);
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        disableOutsidePointerEvents: false,
                        get style () {
                            return {
                                "--kb-hovercard-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        onFocusOutside: (e)=>e.preventDefault(),
                        get onDismiss () {
                            return context.close;
                        }
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
/**
 * Portals its children into the `body` when the hovercard is open.
 */ function HoverCardPortal(props) {
    const context = useHoverCardContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts
 * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts
 */ /**
 * Construct a polygon based on the floating element placement relative to the anchor.
 */ function getHoverCardSafeArea(placement, anchorEl, floatingEl) {
    const basePlacement = placement.split("-")[0];
    const anchorRect = anchorEl.getBoundingClientRect();
    const floatingRect = floatingEl.getBoundingClientRect();
    const polygon = [];
    const anchorCenterX = anchorRect.left + anchorRect.width / 2;
    const anchorCenterY = anchorRect.top + anchorRect.height / 2;
    switch(basePlacement){
        case "top":
            polygon.push([
                anchorRect.left,
                anchorCenterY
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                anchorRect.right,
                anchorCenterY
            ]);
            break;
        case "right":
            polygon.push([
                anchorCenterX,
                anchorRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                anchorCenterX,
                anchorRect.bottom
            ]);
            break;
        case "bottom":
            polygon.push([
                anchorRect.left,
                anchorCenterY
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                anchorRect.right,
                anchorCenterY
            ]);
            break;
        case "left":
            polygon.push([
                anchorCenterX,
                anchorRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                anchorCenterX,
                anchorRect.bottom
            ]);
            break;
    }
    return polygon;
}
/**
 * A popover that allows sighted users to preview content available behind a link.
 */ function HoverCardRoot(props) {
    const defaultId = `hovercard-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        openDelay: 700,
        closeDelay: 300
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id",
        "open",
        "defaultOpen",
        "onOpenChange",
        "openDelay",
        "closeDelay",
        "ignoreSafeArea",
        "forceMount"
    ]);
    let openTimeoutId;
    let closeTimeoutId;
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const [currentPlacement, setCurrentPlacement] = (0, _solidJs.createSignal)(others.placement);
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const contentPresence = createPresence(()=>local.forceMount || disclosureState.isOpen());
    const { addGlobalListener , removeGlobalListener  } = (0, _utils.createGlobalListeners)();
    const openWithDelay = ()=>{
        if (0, _web.isServer) return;
        openTimeoutId = window.setTimeout(()=>{
            openTimeoutId = undefined;
            disclosureState.open();
        }, local.openDelay);
    };
    const closeWithDelay = ()=>{
        if (0, _web.isServer) return;
        closeTimeoutId = window.setTimeout(()=>{
            closeTimeoutId = undefined;
            disclosureState.close();
        }, local.closeDelay);
    };
    const cancelOpening = ()=>{
        if (0, _web.isServer) return;
        window.clearTimeout(openTimeoutId);
        openTimeoutId = undefined;
    };
    const cancelClosing = ()=>{
        if (0, _web.isServer) return;
        window.clearTimeout(closeTimeoutId);
        closeTimeoutId = undefined;
    };
    const isTargetOnHoverCard = (target)=>{
        return (0, _utils.contains)(triggerRef(), target) || (0, _utils.contains)(contentRef(), target);
    };
    const getPolygonSafeArea = (placement)=>{
        const triggerEl = triggerRef();
        const contentEl = contentRef();
        if (!triggerEl || !contentEl) return;
        return getHoverCardSafeArea(placement, triggerEl, contentEl);
    };
    const onHoverOutside = (event)=>{
        const target = event.target;
        // Don't close if the mouse is moving through valid hovercard element.
        if (isTargetOnHoverCard(target)) {
            cancelClosing();
            return;
        }
        if (!local.ignoreSafeArea) {
            const polygon = getPolygonSafeArea(currentPlacement());
            //Don't close if the current's event mouse position is inside the polygon safe area.
            if (polygon && (0, _utils.isPointInPolygon)((0, _utils.getEventPoint)(event), polygon)) {
                cancelClosing();
                return;
            }
        }
        // If there's already a scheduled timeout to hide the hovercard, we do nothing.
        if (closeTimeoutId) return;
        // Otherwise, hide the hovercard after the close delay.
        closeWithDelay();
    };
    (0, _solidJs.createEffect)(()=>{
        if (!disclosureState.isOpen()) return;
        // Checks whether the mouse is moving outside the hovercard.
        // If yes, hide the card after the close delay.
        addGlobalListener(document, "pointermove", onHoverOutside, true);
        (0, _solidJs.onCleanup)(()=>{
            removeGlobalListener(document, "pointermove", onHoverOutside, true);
        });
    });
    // cleanup all timeout on unmount.
    (0, _solidJs.onCleanup)(()=>{
        cancelOpening();
        cancelClosing();
    });
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        contentPresence,
        openWithDelay,
        closeWithDelay,
        cancelOpening,
        cancelClosing,
        close: disclosureState.close,
        isTargetOnHoverCard,
        setTriggerRef,
        setContentRef
    };
    return (0, _web.createComponent)(HoverCardContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                anchorRef: triggerRef,
                contentRef: contentRef,
                onCurrentPlacementChange: setCurrentPlacement
            }, others));
        }
    });
}
/**
 * The link that opens the hovercard when hovered.
 */ function HoverCardTrigger(props) {
    const context = useHoverCardContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onPointerEnter",
        "onPointerLeave",
        "onFocus",
        "onBlur",
        "onTouchStart"
    ]);
    const onPointerEnter = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerEnter);
        if (e.pointerType === "touch" || others.disabled || e.defaultPrevented) return;
        context.cancelClosing();
        if (!context.isOpen()) context.openWithDelay();
    };
    const onPointerLeave = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerLeave);
        if (e.pointerType === "touch") return;
        context.cancelOpening();
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        if (others.disabled || e.defaultPrevented) return;
        context.cancelClosing();
        if (!context.isOpen()) context.openWithDelay();
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        context.cancelOpening();
        const relatedTarget = e.relatedTarget;
        if (context.isTargetOnHoverCard(relatedTarget)) return;
        context.closeWithDelay();
    };
    (0, _solidJs.onCleanup)(context.cancelOpening);
    return (0, _web.createComponent)(LinkRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        onPointerEnter: onPointerEnter,
        onPointerLeave: onPointerLeave,
        onFocus: onFocus,
        onBlur: onBlur
    }, ()=>context.dataset(), others));
}
var index$e = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    Content: HoverCardContent,
    Portal: HoverCardPortal,
    Root: HoverCardRoot,
    Trigger: HoverCardTrigger
});
const ImageContext = (0, _solidJs.createContext)();
function useImageContext() {
    const context = (0, _solidJs.useContext)(ImageContext);
    if (context === undefined) throw new Error("[kobalte]: `useImageContext` must be used within an `Image.Root` component");
    return context;
}
/**
 * An element that renders when the image hasn't loaded.
 * This means whilst it's loading, or if there was an error.
 */ function ImageFallback(props) {
    const context = useImageContext();
    const [canRender, setCanRender] = (0, _solidJs.createSignal)(context.fallbackDelay() === undefined);
    (0, _solidJs.createEffect)(()=>{
        const delayMs = context.fallbackDelay();
        if (delayMs !== undefined) {
            const timerId = window.setTimeout(()=>setCanRender(true), delayMs);
            (0, _solidJs.onCleanup)(()=>window.clearTimeout(timerId));
        }
    });
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return (0, _web.memo)(()=>!!canRender())() && context.imageLoadingStatus() !== "loaded";
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "span"
            }, props));
        }
    });
}
const _tmpl$$d = /*#__PURE__*/ (0, _web.template)(`<img>`);
/**
 * The image to render. By default, it will only render when it has loaded.
 */ function ImageImg(props) {
    const context = useImageContext();
    const [loadingStatus, setLoadingStatus] = (0, _solidJs.createSignal)("idle");
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>props.src, (src)=>{
        if (!src) {
            setLoadingStatus("error");
            return;
        }
        let isMounted = true;
        const image = new window.Image();
        const updateStatus = (status)=>()=>{
                if (!isMounted) return;
                setLoadingStatus(status);
            };
        setLoadingStatus("loading");
        image.onload = updateStatus("loaded");
        image.onerror = updateStatus("error");
        image.src = src;
        (0, _solidJs.onCleanup)(()=>{
            isMounted = false;
        });
    }));
    (0, _solidJs.createEffect)(()=>{
        const imageLoadingStatus = loadingStatus();
        if (imageLoadingStatus !== "idle") context.onImageLoadingStatusChange(imageLoadingStatus);
    });
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return loadingStatus() === "loaded";
        },
        get children () {
            const _el$ = _tmpl$$d();
            (0, _web.spread)(_el$, props, false, false);
            return _el$;
        }
    });
}
/**
 * An image element with an optional fallback for loading and error status.
 */ function ImageRoot(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "fallbackDelay",
        "onLoadingStatusChange"
    ]);
    const [imageLoadingStatus, setImageLoadingStatus] = (0, _solidJs.createSignal)("idle");
    const context = {
        fallbackDelay: ()=>local.fallbackDelay,
        imageLoadingStatus,
        onImageLoadingStatusChange: (status)=>{
            setImageLoadingStatus(status);
            local.onLoadingStatusChange?.(status);
        }
    };
    return (0, _web.createComponent)(ImageContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "span"
            }, others));
        }
    });
}
var index$d = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Fallback: ImageFallback,
    Img: ImageImg,
    Root: ImageRoot
});
const _tmpl$$c = /*#__PURE__*/ (0, _web.template)(`<li>`);
function PaginationEllipsis(props) {
    return (()=>{
        const _el$ = _tmpl$$c();
        (0, _web.insert)(_el$, (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
            as: "div"
        }, props)));
        return _el$;
    })();
}
const PaginationContext = (0, _solidJs.createContext)();
function usePaginationContext() {
    const context = (0, _solidJs.useContext)(PaginationContext);
    if (context === undefined) throw new Error("[kobalte]: `usePaginationContext` must be used within a `Pagination` component");
    return context;
}
const _tmpl$$b = /*#__PURE__*/ (0, _web.template)(`<li>`);
function PaginationItem(props) {
    const context = usePaginationContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "page",
        "onClick"
    ]);
    const isCurrent = ()=>{
        return context.page() === local.page;
    };
    const onClick = ()=>{
        context.setPage(local.page);
    };
    return (()=>{
        const _el$ = _tmpl$$b();
        (0, _web.insert)(_el$, (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
            as: "button",
            get ["aria-current"] () {
                return isCurrent() ? "page" : undefined;
            },
            get ["data-current"] () {
                return isCurrent() ? "" : undefined;
            },
            get onClick () {
                return (0, _utils.composeEventHandlers)([
                    local.onClick,
                    onClick
                ]);
            }
        }, others)));
        return _el$;
    })();
}
function PaginationItems(props) {
    const context = usePaginationContext();
    const [showFirst, setShowFirst] = (0, _solidJs.createSignal)(false);
    const [showLast, setShowLast] = (0, _solidJs.createSignal)(false);
    const [showFirstEllipsis, setShowFirstEllipsis] = (0, _solidJs.createSignal)(false);
    const [showLastEllipsis, setShowLastEllipsis] = (0, _solidJs.createSignal)(false);
    const [previousSiblingCount, setPreviousSiblingCount] = (0, _solidJs.createSignal)(0);
    const [nextSiblingCount, setNextSiblingCount] = (0, _solidJs.createSignal)(0);
    (0, _solidJs.createEffect)(()=>{
        (0, _solidJs.batch)(()=>{
            setShowFirst(context.showFirst() && context.page() - 1 > context.siblingCount());
            setShowLast(context.showLast() && context.count() - context.page() > context.siblingCount());
            setShowFirstEllipsis(context.page() - (context.showFirst() ? 2 : 1) > context.siblingCount());
            setShowLastEllipsis(context.count() - context.page() - (context.showLast() ? 1 : 0) > context.siblingCount());
            setPreviousSiblingCount(Math.min(context.page() - 1, context.siblingCount()));
            setNextSiblingCount(Math.min(context.count() - context.page(), context.siblingCount()));
            if (context.fixedItems() !== false) {
                // Untrack to avoid recursion
                (0, _solidJs.untrack)(()=>{
                    // Add back the difference between the opposite side and the sibling count
                    setPreviousSiblingCount((prev)=>prev + Math.max(context.siblingCount() - nextSiblingCount(), 0));
                    setNextSiblingCount((prev)=>prev + Math.max(context.siblingCount() - previousSiblingCount(), 0));
                });
                if (!showFirst()) setNextSiblingCount((prev)=>prev + 1);
                if (!showLast()) setPreviousSiblingCount((prev)=>prev + 1);
                // Check specifically if true and not "no-ellipsis"
                if (context.fixedItems() === true) {
                    if (!showFirstEllipsis()) setNextSiblingCount((prev)=>prev + 1);
                    if (!showLastEllipsis()) setPreviousSiblingCount((prev)=>prev + 1);
                }
            }
        });
    });
    return [
        (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return showFirst();
            },
            get children () {
                return context.renderItem(1);
            }
        }),
        (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return showFirstEllipsis();
            },
            get children () {
                return context.renderEllipsis();
            }
        }),
        (0, _web.createComponent)((0, _solidJs.For), {
            get each () {
                return [
                    ...Array(previousSiblingCount()).keys()
                ].reverse();
            },
            children: (offset)=>(0, _web.memo)(()=>context.renderItem(context.page() - (offset + 1)))
        }),
        (0, _web.memo)(()=>context.renderItem(context.page())),
        (0, _web.createComponent)((0, _solidJs.For), {
            get each () {
                return [
                    ...Array(nextSiblingCount()).keys()
                ];
            },
            children: (offset)=>(0, _web.memo)(()=>context.renderItem(context.page() + (offset + 1)))
        }),
        (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return showLastEllipsis();
            },
            get children () {
                return context.renderEllipsis();
            }
        }),
        (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return showLast();
            },
            get children () {
                return context.renderItem(context.count());
            }
        })
    ];
}
const _tmpl$$a = /*#__PURE__*/ (0, _web.template)(`<li>`);
function PaginationNext(props) {
    const context = usePaginationContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick"
    ]);
    const onClick = ()=>{
        context.setPage(context.page() + 1);
    };
    const isDisabled = ()=>context.page() === context.count();
    return (()=>{
        const _el$ = _tmpl$$a();
        (0, _web.insert)(_el$, (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
            as: "button",
            get tabIndex () {
                return isDisabled() || context.page() === context.count() ? "-1" : undefined;
            },
            get disabled () {
                return isDisabled();
            },
            get ["aria-disabled"] () {
                return isDisabled() || undefined;
            },
            get ["data-disabled"] () {
                return isDisabled() ? "" : undefined;
            },
            get onClick () {
                return (0, _utils.composeEventHandlers)([
                    local.onClick,
                    onClick
                ]);
            }
        }, others)));
        return _el$;
    })();
}
const _tmpl$$9 = /*#__PURE__*/ (0, _web.template)(`<li>`);
function PaginationPrevious(props) {
    const context = usePaginationContext();
    props = (0, _utils.mergeDefaultProps)({
        type: "button"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick"
    ]);
    const onClick = ()=>{
        context.setPage(context.page() - 1);
    };
    const isDisabled = ()=>context.page() === 1;
    return (()=>{
        const _el$ = _tmpl$$9();
        (0, _web.insert)(_el$, (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
            as: "button",
            get tabIndex () {
                return isDisabled() || context.page() === 1 ? "-1" : undefined;
            },
            get disabled () {
                return isDisabled();
            },
            get ["aria-disabled"] () {
                return isDisabled() || undefined;
            },
            get ["data-disabled"] () {
                return isDisabled() ? "" : undefined;
            },
            get onClick () {
                return (0, _utils.composeEventHandlers)([
                    local.onClick,
                    onClick
                ]);
            }
        }, others)));
        return _el$;
    })();
}
const _tmpl$$8 = /*#__PURE__*/ (0, _web.template)(`<ul>`);
/**
 * A list of page number that allows users to change the current page.
 */ function PaginationRoot(props) {
    const defaultId = `pagination-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "page",
        "defaultPage",
        "onPageChange",
        "count",
        "siblingCount",
        "showFirst",
        "showLast",
        "fixedItems",
        "itemComponent",
        "ellipsisComponent",
        "disabled",
        "children"
    ]);
    const state = createControllableSignal({
        defaultValue: ()=>local.defaultPage ?? 1,
        onChange: local.onPageChange,
        value: ()=>local.page
    });
    const context = {
        count: ()=>local.count,
        siblingCount: ()=>local.siblingCount ?? 1,
        showFirst: ()=>local.showFirst ?? true,
        showLast: ()=>local.showLast ?? true,
        fixedItems: ()=>local.fixedItems ?? false,
        isDisabled: ()=>local.disabled ?? false,
        renderItem: (page)=>local.itemComponent({
                page
            }),
        renderEllipsis: local.ellipsisComponent,
        page: state[0],
        setPage: state[1]
    };
    return (0, _web.createComponent)(PaginationContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "nav",
                get ["data-disabled"] () {
                    return local.disabled ? "" : undefined;
                }
            }, others, {
                get children () {
                    const _el$ = _tmpl$$8();
                    (0, _web.insert)(_el$, ()=>local.children);
                    return _el$;
                }
            }));
        }
    });
}
var index$c = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Ellipsis: PaginationEllipsis,
    Item: PaginationItem,
    Items: PaginationItems,
    Next: PaginationNext,
    Previous: PaginationPrevious,
    Root: PaginationRoot
});
const PopoverContext = (0, _solidJs.createContext)();
function usePopoverContext() {
    const context = (0, _solidJs.useContext)(PopoverContext);
    if (context === undefined) throw new Error("[kobalte]: `usePopoverContext` must be used within a `Popover` component");
    return context;
}
/**
 * An optional element to position the `Popover.Content` against.
 * If this part is not used, the content will position alongside the `Popover.Trigger`.
 */ function PopoverAnchor(props) {
    const context = usePopoverContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref"
    ]);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setDefaultAnchorRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        }
    }, ()=>context.dataset(), others));
}
/**
 * The button that closes the popover.
 */ function PopoverCloseButton(props) {
    const context = usePopoverContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "aria-label",
        "onClick"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.close();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get ["aria-label"] () {
            return local["aria-label"] || context.translations().dismiss;
        },
        onClick: onClick
    }, ()=>context.dataset(), others));
}
/**
 * Contains the content to be rendered when the popover is open.
 */ function PopoverContent(props) {
    let ref;
    const context = usePopoverContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("content")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onOpenAutoFocus",
        "onCloseAutoFocus",
        "onPointerDownOutside",
        "onFocusOutside",
        "onInteractOutside"
    ]);
    let isRightClickOutside = false;
    let hasInteractedOutside = false;
    let hasPointerDownOutside = false;
    const onCloseAutoFocus = (e)=>{
        local.onCloseAutoFocus?.(e);
        if (context.isModal()) {
            e.preventDefault();
            if (!isRightClickOutside) (0, _utils.focusWithoutScrolling)(context.triggerRef());
        } else {
            if (!e.defaultPrevented) {
                if (!hasInteractedOutside) (0, _utils.focusWithoutScrolling)(context.triggerRef());
                // Always prevent autofocus because we either focus manually or want user agent focus
                e.preventDefault();
            }
            hasInteractedOutside = false;
            hasPointerDownOutside = false;
        }
    };
    const onPointerDownOutside = (e)=>{
        local.onPointerDownOutside?.(e);
        if (context.isModal()) isRightClickOutside = e.detail.isContextMenu;
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.isOpen() && context.isModal()) e.preventDefault();
    };
    const onInteractOutside = (e)=>{
        local.onInteractOutside?.(e);
        if (context.isModal()) return;
        // Non-modal behavior below
        if (!e.defaultPrevented) {
            hasInteractedOutside = true;
            if (e.detail.originalEvent.type === "pointerdown") hasPointerDownOutside = true;
        }
        // Prevent dismissing when clicking the trigger.
        // As the trigger is already setup to close, without doing so would
        // cause it to close and immediately open.
        if ((0, _utils.contains)(context.triggerRef(), e.target)) e.preventDefault();
        // On Safari if the trigger is inside a container with tabIndex={0}, when clicked
        // we will get the pointer down outside event on the trigger, but then a subsequent
        // focus outside event on the container, we ignore any focus outside event when we've
        // already had a pointer down outside event.
        if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) e.preventDefault();
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: ()=>!(context.isOpen() && context.isModal()),
        targets: ()=>ref ? [
                ref
            ] : []
    });
    createPreventScroll({
        ownerRef: ()=>ref,
        isDisabled: ()=>!(context.isOpen() && context.preventScroll())
    });
    createFocusScope({
        trapFocus: ()=>context.isOpen() && context.isModal(),
        onMountAutoFocus: local.onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus
    }, ()=>ref);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerContentId(others.id)));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                                ref = el;
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "dialog",
                        tabIndex: -1,
                        get disableOutsidePointerEvents () {
                            return (0, _web.memo)(()=>!!context.isOpen())() && context.isModal();
                        },
                        get excludedElements () {
                            return [
                                context.triggerRef
                            ];
                        },
                        get style () {
                            return {
                                "--kb-popover-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        get ["aria-labelledby"] () {
                            return context.titleId();
                        },
                        get ["aria-describedby"] () {
                            return context.descriptionId();
                        },
                        onPointerDownOutside: onPointerDownOutside,
                        onFocusOutside: onFocusOutside,
                        onInteractOutside: onInteractOutside,
                        get onDismiss () {
                            return context.close;
                        }
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
/**
 * An optional accessible description to be announced when the popover is open.
 */ function PopoverDescription(props) {
    const context = usePopoverContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescriptionId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "p",
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * Portals its children into the `body` when the popover is open.
 */ function PopoverPortal(props) {
    const context = usePopoverContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
const POPOVER_INTL_TRANSLATIONS = {
    // `aria-label` of Popover.CloseButton.
    dismiss: "Dismiss"
};
/**
 * A popover is a dialog positioned relative to an anchor element.
 */ function PopoverRoot(props) {
    const defaultId = `popover-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        modal: false,
        translations: POPOVER_INTL_TRANSLATIONS
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "translations",
        "id",
        "open",
        "defaultOpen",
        "onOpenChange",
        "modal",
        "preventScroll",
        "forceMount",
        "anchorRef"
    ]);
    const [defaultAnchorRef, setDefaultAnchorRef] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const [titleId, setTitleId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const anchorRef = ()=>{
        return local.anchorRef?.() ?? defaultAnchorRef() ?? triggerRef();
    };
    const contentPresence = createPresence(()=>local.forceMount || disclosureState.isOpen());
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    const context = {
        translations: ()=>local.translations ?? POPOVER_INTL_TRANSLATIONS,
        dataset,
        isOpen: disclosureState.isOpen,
        isModal: ()=>local.modal ?? false,
        preventScroll: ()=>local.preventScroll ?? context.isModal(),
        contentPresence,
        triggerRef,
        contentId,
        titleId,
        descriptionId,
        setDefaultAnchorRef,
        setTriggerRef,
        setContentRef,
        close: disclosureState.close,
        toggle: disclosureState.toggle,
        generateId: (0, _utils.createGenerateId)(()=>local.id),
        registerContentId: createRegisterId(setContentId),
        registerTitleId: createRegisterId(setTitleId),
        registerDescriptionId: createRegisterId(setDescriptionId)
    };
    return (0, _web.createComponent)(PopoverContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                anchorRef: anchorRef,
                contentRef: contentRef
            }, others));
        }
    });
}
/**
 * An accessible title to be announced when the popover is open.
 */ function PopoverTitle(props) {
    const context = usePopoverContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("title")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTitleId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "h2",
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * The button that opens the popover.
 */ function PopoverTrigger(props) {
    const context = usePopoverContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onClick",
        "onPointerDown"
    ]);
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        // Prevent popover from opening then closing immediately when inside an overlay in safari.
        e.preventDefault();
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.toggle();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        "aria-haspopup": "dialog",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        onPointerDown: onPointerDown,
        onClick: onClick
    }, ()=>context.dataset(), others));
}
var index$b = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Anchor: PopoverAnchor,
    Arrow: PopperArrow,
    CloseButton: PopoverCloseButton,
    Content: PopoverContent,
    Description: PopoverDescription,
    Portal: PopoverPortal,
    Root: PopoverRoot,
    Title: PopoverTitle,
    Trigger: PopoverTrigger
});
const ProgressContext = (0, _solidJs.createContext)();
function useProgressContext() {
    const context = (0, _solidJs.useContext)(ProgressContext);
    if (context === undefined) throw new Error("[kobalte]: `useProgressContext` must be used within a `Progress.Root` component");
    return context;
}
/**
 * The component that visually represents the progress value.
 * Used to visually show the fill of `Progress.Track`.
 */ function ProgressFill(props) {
    const context = useProgressContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "style"
    ]);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get style () {
            return {
                "--kb-progress-fill-width": context.progressFillWidth(),
                ...local.style
            };
        }
    }, ()=>context.dataset(), others));
}
/**
 * An accessible label that gives the user information on the progress.
 */ function ProgressLabel(props) {
    const context = useProgressContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("label")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerLabelId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "span",
        get id () {
            return local.id;
        }
    }, ()=>context.dataset(), others));
}
/**
 * Progress show either determinate or indeterminate progress of an operation over time.
 */ function ProgressRoot(props) {
    const defaultId = `progress-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        value: 0,
        minValue: 0,
        maxValue: 100
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "minValue",
        "maxValue",
        "indeterminate",
        "getValueLabel"
    ]);
    const [labelId, setLabelId] = (0, _solidJs.createSignal)();
    const defaultFormatter = createNumberFormatter(()=>({
            style: "percent"
        }));
    const value = ()=>{
        return (0, _utils.clamp)(local.value, local.minValue, local.maxValue);
    };
    const valuePercent = ()=>{
        return (value() - local.minValue) / (local.maxValue - local.minValue);
    };
    const valueLabel = ()=>{
        if (local.indeterminate) return undefined;
        if (local.getValueLabel) return local.getValueLabel({
            value: value(),
            min: local.minValue,
            max: local.maxValue
        });
        return defaultFormatter().format(valuePercent());
    };
    const progressFillWidth = ()=>{
        return local.indeterminate ? undefined : `${Math.round(valuePercent() * 100)}%`;
    };
    const dataset = (0, _solidJs.createMemo)(()=>{
        let dataProgress = undefined;
        if (!local.indeterminate) dataProgress = valuePercent() === 1 ? "complete" : "loading";
        return {
            "data-progress": dataProgress,
            "data-indeterminate": local.indeterminate ? "" : undefined
        };
    });
    const context = {
        dataset,
        value,
        valuePercent,
        valueLabel,
        labelId,
        progressFillWidth,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerLabelId: createRegisterId(setLabelId)
    };
    return (0, _web.createComponent)(ProgressContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                role: "progressbar",
                get ["aria-valuenow"] () {
                    return (0, _web.memo)(()=>!!local.indeterminate)() ? undefined : value();
                },
                get ["aria-valuemin"] () {
                    return local.minValue;
                },
                get ["aria-valuemax"] () {
                    return local.maxValue;
                },
                get ["aria-valuetext"] () {
                    return valueLabel();
                },
                get ["aria-labelledby"] () {
                    return labelId();
                }
            }, dataset, others));
        }
    });
}
/**
 * The component that visually represents the progress track.
 * Act as a container for `Progress.Fill`.
 */ function ProgressTrack(props) {
    const context = useProgressContext();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div"
    }, ()=>context.dataset(), props));
}
/**
 * The accessible label text representing the current value in a human-readable format.
 */ function ProgressValueLabel(props) {
    const context = useProgressContext();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get children () {
            return context.valueLabel();
        }
    }, ()=>context.dataset(), props));
}
var index$a = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Fill: ProgressFill,
    Label: ProgressLabel,
    Root: ProgressRoot,
    Track: ProgressTrack,
    ValueLabel: ProgressValueLabel
});
const RadioGroupContext = (0, _solidJs.createContext)();
function useRadioGroupContext() {
    const context = (0, _solidJs.useContext)(RadioGroupContext);
    if (context === undefined) throw new Error("[kobalte]: `useRadioGroupContext` must be used within a `RadioGroup` component");
    return context;
}
const RadioGroupItemContext = (0, _solidJs.createContext)();
function useRadioGroupItemContext() {
    const context = (0, _solidJs.useContext)(RadioGroupItemContext);
    if (context === undefined) throw new Error("[kobalte]: `useRadioGroupItemContext` must be used within a `RadioGroup.Item` component");
    return context;
}
/**
 * The root container for a radio button.
 */ function RadioGroupItem(props) {
    const formControlContext = useFormControlContext();
    const radioGroupContext = useRadioGroupContext();
    const defaultId = `${formControlContext.generateId("item")}-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "disabled",
        "onPointerDown"
    ]);
    const [inputId, setInputId] = (0, _solidJs.createSignal)();
    const [labelId, setLabelId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const [inputRef, setInputRef] = (0, _solidJs.createSignal)();
    const [isFocused, setIsFocused] = (0, _solidJs.createSignal)(false);
    const isSelected = (0, _solidJs.createMemo)(()=>{
        return radioGroupContext.isSelectedValue(local.value);
    });
    const isDisabled = (0, _solidJs.createMemo)(()=>{
        return local.disabled || formControlContext.isDisabled() || false;
    });
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        // For consistency with native, prevent the input blurs on pointer down.
        if (isFocused()) e.preventDefault();
    };
    const dataset = (0, _solidJs.createMemo)(()=>({
            ...formControlContext.dataset(),
            "data-disabled": isDisabled() ? "" : undefined,
            "data-checked": isSelected() ? "" : undefined
        }));
    const context = {
        value: ()=>local.value,
        dataset,
        isSelected,
        isDisabled,
        inputId,
        labelId,
        descriptionId,
        inputRef,
        select: ()=>radioGroupContext.setSelectedValue(local.value),
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerInput: createRegisterId(setInputId),
        registerLabel: createRegisterId(setLabelId),
        registerDescription: createRegisterId(setDescriptionId),
        setIsFocused,
        setInputRef
    };
    return (0, _web.createComponent)(RadioGroupItemContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                role: "group",
                onPointerDown: onPointerDown
            }, dataset, others));
        }
    });
}
/**
 * The element that visually represents a radio button.
 */ function RadioGroupItemControl(props) {
    const context = useRadioGroupItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("control")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick",
        "onKeyDown"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.select();
        context.inputRef()?.focus();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (e.key === (0, _utils.EventKey).Space) {
            context.select();
            context.inputRef()?.focus();
        }
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        onClick: onClick,
        onKeyDown: onKeyDown
    }, ()=>context.dataset(), others));
}
/**
 * The description that gives the user more information on the radio button.
 */ function RadioGroupItemDescription(props) {
    const context = useRadioGroupItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescription(props.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div"
    }, ()=>context.dataset(), props));
}
/**
 * The visual indicator rendered when the radio item is in a checked state.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */ function RadioGroupItemIndicator(props) {
    const context = useRadioGroupItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("indicator")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "forceMount"
    ]);
    const presence = createPresence(()=>local.forceMount || context.isSelected());
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return presence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)(presence.setRef, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                }
            }, ()=>context.dataset(), others));
        }
    });
}
const _tmpl$$7 = /*#__PURE__*/ (0, _web.template)(`<input type="radio">`);
/**
 * The native html input that is visually hidden in the radio button.
 */ function RadioGroupItemInput(props) {
    const formControlContext = useFormControlContext();
    const radioGroupContext = useRadioGroupContext();
    const radioContext = useRadioGroupItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: radioContext.generateId("input")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "aria-labelledby",
        "aria-describedby",
        "onChange",
        "onFocus",
        "onBlur"
    ]);
    const ariaLabelledBy = ()=>{
        return [
            local["aria-labelledby"],
            radioContext.labelId(),
            // If there is both an aria-label and aria-labelledby, add the input itself has an aria-labelledby
            local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined
        ].filter(Boolean).join(" ") || undefined;
    };
    const ariaDescribedBy = ()=>{
        return [
            local["aria-describedby"],
            radioContext.descriptionId(),
            radioGroupContext.ariaDescribedBy()
        ].filter(Boolean).join(" ") || undefined;
    };
    const [isInternalChangeEvent, setIsInternalChangeEvent] = (0, _solidJs.createSignal)(false);
    const onChange = (e)=>{
        (0, _utils.callHandler)(e, local.onChange);
        e.stopPropagation();
        if (!isInternalChangeEvent()) {
            radioGroupContext.setSelectedValue(radioContext.value());
            const target = e.target;
            // Unlike in React, inputs `checked` state can be out of sync with our state.
            // for example a readonly `<input type="radio" />` is always "checkable".
            //
            // Also, even if an input is controlled (ex: `<input type="radio" checked={isChecked} />`,
            // clicking on the input will change its internal `checked` state.
            //
            // To prevent this, we need to force the input `checked` state to be in sync with our state.
            target.checked = radioContext.isSelected();
        }
        setIsInternalChangeEvent(false);
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        radioContext.setIsFocused(true);
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        radioContext.setIsFocused(false);
    };
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>radioContext.isSelected(),
        ()=>radioContext.value()
    ], (c)=>{
        if (!c[0] && c[1] === radioContext.value()) return;
        setIsInternalChangeEvent(true);
        const ref = radioContext.inputRef();
        ref?.dispatchEvent(new Event("input", {
            bubbles: true,
            cancelable: true
        }));
        ref?.dispatchEvent(new Event("change", {
            bubbles: true,
            cancelable: true
        }));
    }, {
        defer: true
    }));
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(radioContext.registerInput(others.id)));
    return (()=>{
        const _el$ = _tmpl$$7();
        _el$.addEventListener("blur", onBlur);
        _el$.addEventListener("focus", onFocus);
        _el$.addEventListener("change", onChange);
        const _ref$ = (0, _utils.mergeRefs)(radioContext.setInputRef, local.ref);
        typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$);
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get name () {
                return formControlContext.name();
            },
            get value () {
                return radioContext.value();
            },
            get checked () {
                return radioContext.isSelected();
            },
            get required () {
                return formControlContext.isRequired();
            },
            get disabled () {
                return radioContext.isDisabled();
            },
            get readonly () {
                return formControlContext.isReadOnly();
            },
            get style () {
                return {
                    ...(0, _utils.visuallyHiddenStyles),
                    ...local.style
                };
            },
            get ["aria-labelledby"] () {
                return ariaLabelledBy();
            },
            get ["aria-describedby"] () {
                return ariaDescribedBy();
            }
        }, ()=>radioContext.dataset(), others), false, false);
        return _el$;
    })();
}
const _tmpl$$6 = /*#__PURE__*/ (0, _web.template)(`<label>`);
/**
 * The label that gives the user information on the radio button.
 */ function RadioGroupItemLabel(props) {
    const context = useRadioGroupItemContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("label")
    }, props);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerLabel(props.id)));
    return (()=>{
        const _el$ = _tmpl$$6();
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get ["for"] () {
                return context.inputId();
            }
        }, ()=>context.dataset(), props), false, false);
        return _el$;
    })();
}
/**
 * The label that gives the user information on the radio group.
 */ function RadioGroupLabel(props) {
    return (0, _web.createComponent)(FormControlLabel, (0, _web.mergeProps)({
        as: "span"
    }, props));
}
/**
 * A set of checkable buttons, known as radio buttons, where no more than one of the buttons can be checked at a time.
 * This component is based on the [WAI-ARIA Radio Group Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/)
 */ function RadioGroupRoot(props) {
    let ref;
    const defaultId = `radiogroup-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        orientation: "vertical"
    }, props);
    const [local, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "value",
        "defaultValue",
        "onChange",
        "orientation",
        "aria-labelledby",
        "aria-describedby"
    ], FORM_CONTROL_PROP_NAMES);
    const [selected, setSelected] = createControllableSignal({
        value: ()=>local.value,
        defaultValue: ()=>local.defaultValue,
        onChange: (value)=>local.onChange?.(value)
    });
    const { formControlContext  } = createFormControl(formControlProps);
    createFormResetListener(()=>ref, ()=>setSelected(local.defaultValue ?? ""));
    const ariaLabelledBy = ()=>{
        return formControlContext.getAriaLabelledBy((0, _utils.access)(formControlProps.id), others["aria-label"], local["aria-labelledby"]);
    };
    const ariaDescribedBy = ()=>{
        return formControlContext.getAriaDescribedBy(local["aria-describedby"]);
    };
    const isSelectedValue = (value)=>{
        return value === selected();
    };
    const context = {
        ariaDescribedBy,
        isSelectedValue,
        setSelectedValue: (value)=>{
            if (formControlContext.isReadOnly() || formControlContext.isDisabled()) return;
            setSelected(value);
            // Sync all radio input checked state in the group with the selected value.
            // This is necessary because checked state might be out of sync
            // (ex: when using controlled radio-group).
            ref?.querySelectorAll("[type='radio']").forEach((el)=>{
                const radio = el;
                radio.checked = isSelectedValue(radio.value);
            });
        }
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(RadioGroupContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                        as: "div",
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "radiogroup",
                        get id () {
                            return (0, _utils.access)(formControlProps.id);
                        },
                        get ["aria-invalid"] () {
                            return formControlContext.validationState() === "invalid" || undefined;
                        },
                        get ["aria-required"] () {
                            return formControlContext.isRequired() || undefined;
                        },
                        get ["aria-disabled"] () {
                            return formControlContext.isDisabled() || undefined;
                        },
                        get ["aria-readonly"] () {
                            return formControlContext.isReadOnly() || undefined;
                        },
                        get ["aria-orientation"] () {
                            return local.orientation;
                        },
                        get ["aria-labelledby"] () {
                            return ariaLabelledBy();
                        },
                        get ["aria-describedby"] () {
                            return ariaDescribedBy();
                        }
                    }, ()=>formControlContext.dataset(), others));
                }
            });
        }
    });
}
var index$9 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Description: FormControlDescription,
    ErrorMessage: FormControlErrorMessage,
    Item: RadioGroupItem,
    ItemControl: RadioGroupItemControl,
    ItemDescription: RadioGroupItemDescription,
    ItemIndicator: RadioGroupItemIndicator,
    ItemInput: RadioGroupItemInput,
    ItemLabel: RadioGroupItemLabel,
    Label: RadioGroupLabel,
    Root: RadioGroupRoot
});
const SelectContext = (0, _solidJs.createContext)();
function useSelectContext() {
    const context = (0, _solidJs.useContext)(SelectContext);
    if (context === undefined) throw new Error("[kobalte]: `useSelectContext` must be used within a `Select` component");
    return context;
}
/**
 * The component that pops out when the select is open.
 */ function SelectContent(props) {
    let ref;
    const context = useSelectContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "style",
        "onCloseAutoFocus",
        "onFocusOutside"
    ]);
    const onEscapeKeyDown = (e)=>{
        // `createSelectableList` prevent escape key down,
        // which prevent our `onDismiss` in `DismissableLayer` to run,
        // so we force "close on escape" here.
        context.close();
    };
    const onFocusOutside = (e)=>{
        local.onFocusOutside?.(e);
        // When focus is trapped (in modal mode), a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.isOpen() && context.isModal()) e.preventDefault();
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: ()=>!(context.isOpen() && context.isModal()),
        targets: ()=>ref ? [
                ref
            ] : []
    });
    createPreventScroll({
        ownerRef: ()=>ref,
        isDisabled: ()=>!(context.isOpen() && context.preventScroll())
    });
    createFocusScope({
        trapFocus: ()=>context.isOpen() && context.isModal(),
        onMountAutoFocus: (e)=>{
            // We prevent open autofocus because it's handled by the `Listbox`.
            e.preventDefault();
        },
        onUnmountAutoFocus: (e)=>{
            local.onCloseAutoFocus?.(e);
            if (!e.defaultPrevented) {
                (0, _utils.focusWithoutScrolling)(context.triggerRef());
                e.preventDefault();
            }
        }
    }, ()=>ref);
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                                ref = el;
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        get disableOutsidePointerEvents () {
                            return (0, _web.memo)(()=>!!context.isModal())() && context.isOpen();
                        },
                        get excludedElements () {
                            return [
                                context.triggerRef
                            ];
                        },
                        get style () {
                            return {
                                "--kb-select-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        onEscapeKeyDown: onEscapeKeyDown,
                        onFocusOutside: onFocusOutside,
                        get onDismiss () {
                            return context.close;
                        }
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
function SelectHiddenSelect(props) {
    const context = useSelectContext();
    return (0, _web.createComponent)(HiddenSelectBase, (0, _web.mergeProps)({
        get collection () {
            return context.listState().collection();
        },
        get selectionManager () {
            return context.listState().selectionManager();
        },
        get isOpen () {
            return context.isOpen();
        },
        get isMultiple () {
            return context.isMultiple();
        },
        get isVirtualized () {
            return context.isVirtualized();
        },
        focusTrigger: ()=>context.triggerRef()?.focus()
    }, props));
}
/**
 * A small icon often displayed next to the value as a visual affordance for the fact it can be open.
 * It renders a `▼` by default, but you can use your own icon `children`.
 */ function SelectIcon(props) {
    const context = useSelectContext();
    props = (0, _utils.mergeDefaultProps)({
        children: "▼"
    }, props);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "span",
        "aria-hidden": "true"
    }, ()=>context.dataset(), props));
}
/**
 * The label that gives the user information on the select.
 */ function SelectLabel(props) {
    const context = useSelectContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        if (!context.isDisabled()) context.triggerRef()?.focus();
    };
    return (0, _web.createComponent)(FormControlLabel, (0, _web.mergeProps)({
        as: "span",
        onClick: onClick
    }, others));
}
/**
 * Contains all the items of a `Select`.
 */ function SelectListbox(props) {
    const context = useSelectContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("listbox")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "onKeyDown"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerListboxId(local.id)));
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        // Prevent from clearing the selection by `createSelectableCollection` on escape.
        if (e.key === "Escape") e.preventDefault();
    };
    return (0, _web.createComponent)(ListboxRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setListboxRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return local.id;
        },
        get state () {
            return context.listState();
        },
        get virtualized () {
            return context.isVirtualized();
        },
        get autoFocus () {
            return context.autoFocus();
        },
        shouldSelectOnPressUp: true,
        shouldFocusOnHover: true,
        get shouldFocusWrap () {
            return context.shouldFocusWrap();
        },
        get disallowTypeAhead () {
            return context.disallowTypeAhead();
        },
        get ["aria-labelledby"] () {
            return context.listboxAriaLabelledBy();
        },
        get renderItem () {
            return context.renderItem;
        },
        get renderSection () {
            return context.renderSection;
        },
        onKeyDown: onKeyDown
    }, others));
}
/**
 * Portals its children into the `body` when the select is open.
 */ function SelectPortal(props) {
    const context = useSelectContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
/**
 * Base component for a select, provide context for its children.
 * Used to build single and multi-select.
 */ function SelectBase(props) {
    const defaultId = `select-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        selectionMode: "single",
        disallowEmptySelection: false,
        allowDuplicateSelectionEvents: true,
        gutter: 8,
        sameWidth: true,
        modal: false
    }, props);
    const [local, popperProps, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "itemComponent",
        "sectionComponent",
        "open",
        "defaultOpen",
        "onOpenChange",
        "value",
        "defaultValue",
        "onChange",
        "placeholder",
        "options",
        "optionValue",
        "optionTextValue",
        "optionDisabled",
        "optionGroupChildren",
        "keyboardDelegate",
        "allowDuplicateSelectionEvents",
        "disallowEmptySelection",
        "disallowTypeAhead",
        "shouldFocusWrap",
        "selectionBehavior",
        "selectionMode",
        "virtualized",
        "modal",
        "preventScroll",
        "forceMount"
    ], [
        "getAnchorRect",
        "placement",
        "gutter",
        "shift",
        "flip",
        "slide",
        "overlap",
        "sameWidth",
        "fitViewport",
        "hideWhenDetached",
        "detachedPadding",
        "arrowPadding",
        "overflowPadding"
    ], FORM_CONTROL_PROP_NAMES);
    const [triggerId, setTriggerId] = (0, _solidJs.createSignal)();
    const [valueId, setValueId] = (0, _solidJs.createSignal)();
    const [listboxId, setListboxId] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const [listboxRef, setListboxRef] = (0, _solidJs.createSignal)();
    const [listboxAriaLabelledBy, setListboxAriaLabelledBy] = (0, _solidJs.createSignal)();
    const [focusStrategy, setFocusStrategy] = (0, _solidJs.createSignal)(true);
    const getOptionValue = (option)=>{
        const optionValue = local.optionValue;
        if (optionValue == null) // If no `optionValue`, the option itself is the value (ex: string[] of options)
        return String(option);
        // Get the value from the option object as a string.
        return String((0, _utils.isFunction)(optionValue) ? optionValue(option) : option[optionValue]);
    };
    // Only options without option groups.
    const flattenOptions = (0, _solidJs.createMemo)(()=>{
        const optionGroupChildren = local.optionGroupChildren;
        // The combobox doesn't contains option groups.
        if (optionGroupChildren == null) return local.options;
        return local.options.flatMap((item)=>item[optionGroupChildren] ?? item);
    });
    // Only option keys without option groups.
    const flattenOptionKeys = (0, _solidJs.createMemo)(()=>{
        return flattenOptions().map((option)=>getOptionValue(option));
    });
    const getOptionsFromValues = (values)=>{
        return [
            ...values
        ].map((value)=>flattenOptions().find((option)=>getOptionValue(option) === value)).filter((option)=>option != null);
    };
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const listState = createListState({
        selectedKeys: ()=>{
            if (local.value != null) return local.value.map(getOptionValue);
            return local.value;
        },
        defaultSelectedKeys: ()=>{
            if (local.defaultValue != null) return local.defaultValue.map(getOptionValue);
            return local.defaultValue;
        },
        onSelectionChange: (selectedKeys)=>{
            local.onChange?.(getOptionsFromValues(selectedKeys));
            if (local.selectionMode === "single") close();
        },
        allowDuplicateSelectionEvents: ()=>(0, _utils.access)(local.allowDuplicateSelectionEvents),
        disallowEmptySelection: ()=>(0, _utils.access)(local.disallowEmptySelection),
        selectionBehavior: ()=>(0, _utils.access)(local.selectionBehavior),
        selectionMode: ()=>local.selectionMode,
        dataSource: ()=>local.options ?? [],
        getKey: ()=>local.optionValue,
        getTextValue: ()=>local.optionTextValue,
        getDisabled: ()=>local.optionDisabled,
        getSectionChildren: ()=>local.optionGroupChildren
    });
    const selectedOptions = (0, _solidJs.createMemo)(()=>{
        return getOptionsFromValues(listState.selectionManager().selectedKeys());
    });
    const removeOptionFromSelection = (option)=>{
        listState.selectionManager().toggleSelection(getOptionValue(option));
    };
    const contentPresence = createPresence(()=>local.forceMount || disclosureState.isOpen());
    const focusListbox = ()=>{
        const listboxEl = listboxRef();
        if (listboxEl) (0, _utils.focusWithoutScrolling)(listboxEl);
    };
    const open = (focusStrategy)=>{
        // Don't open if there is no option.
        if (local.options.length <= 0) return;
        setFocusStrategy(focusStrategy);
        disclosureState.open();
        let focusedKey = listState.selectionManager().firstSelectedKey();
        if (focusedKey == null) {
            if (focusStrategy === "first") focusedKey = listState.collection().getFirstKey();
            else if (focusStrategy === "last") focusedKey = listState.collection().getLastKey();
        }
        focusListbox();
        listState.selectionManager().setFocused(true);
        listState.selectionManager().setFocusedKey(focusedKey);
    };
    const close = ()=>{
        disclosureState.close();
        listState.selectionManager().setFocused(false);
        listState.selectionManager().setFocusedKey(undefined);
    };
    const toggle = (focusStrategy)=>{
        if (disclosureState.isOpen()) close();
        else open(focusStrategy);
    };
    const { formControlContext  } = createFormControl(formControlProps);
    createFormResetListener(triggerRef, ()=>{
        const defaultSelectedKeys = local.defaultValue ? [
            ...local.defaultValue
        ].map(getOptionValue) : new Selection();
        listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
    });
    const collator = createCollator({
        usage: "search",
        sensitivity: "base"
    });
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    const delegate = (0, _solidJs.createMemo)(()=>{
        const keyboardDelegate = (0, _utils.access)(local.keyboardDelegate);
        if (keyboardDelegate) return keyboardDelegate;
        return new ListKeyboardDelegate(listState.collection, undefined, collator);
    });
    const renderItem = (item)=>{
        return local.itemComponent?.({
            item
        });
    };
    const renderSection = (section)=>{
        return local.sectionComponent?.({
            section
        });
    };
    // Delete selected keys that do not match any option in the listbox.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        flattenOptionKeys
    ], ([flattenOptionKeys])=>{
        const currentSelectedKeys = [
            ...listState.selectionManager().selectedKeys()
        ];
        const keysToKeep = currentSelectedKeys.filter((key)=>flattenOptionKeys.includes(key));
        listState.selectionManager().setSelectedKeys(keysToKeep);
    }, {
        defer: true
    }));
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        isDisabled: ()=>formControlContext.isDisabled() ?? false,
        isMultiple: ()=>(0, _utils.access)(local.selectionMode) === "multiple",
        isVirtualized: ()=>local.virtualized ?? false,
        isModal: ()=>local.modal ?? false,
        preventScroll: ()=>local.preventScroll ?? context.isModal(),
        disallowTypeAhead: ()=>local.disallowTypeAhead ?? false,
        shouldFocusWrap: ()=>local.shouldFocusWrap ?? false,
        selectedOptions,
        contentPresence,
        autoFocus: focusStrategy,
        triggerRef,
        listState: ()=>listState,
        keyboardDelegate: delegate,
        triggerId,
        valueId,
        listboxId,
        listboxAriaLabelledBy,
        setListboxAriaLabelledBy,
        setTriggerRef,
        setContentRef,
        setListboxRef,
        open,
        close,
        toggle,
        placeholder: ()=>local.placeholder,
        renderItem,
        renderSection,
        removeOptionFromSelection,
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        registerTriggerId: createRegisterId(setTriggerId),
        registerValueId: createRegisterId(setValueId),
        registerListboxId: createRegisterId(setListboxId)
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(SelectContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                        anchorRef: triggerRef,
                        contentRef: contentRef
                    }, popperProps, {
                        get children () {
                            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                                as: "div",
                                role: "group",
                                get id () {
                                    return (0, _utils.access)(formControlProps.id);
                                }
                            }, ()=>formControlContext.dataset(), dataset, others));
                        }
                    }));
                }
            });
        }
    });
}
/**
 * Displays a list of options for the user to pick from — triggered by a button.
 */ function SelectRoot(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "defaultValue",
        "onChange",
        "multiple"
    ]);
    const value = (0, _solidJs.createMemo)(()=>{
        if (local.value != null) return local.multiple ? local.value : [
            local.value
        ];
        return local.value;
    });
    const defaultValue = (0, _solidJs.createMemo)(()=>{
        if (local.defaultValue != null) return local.multiple ? local.defaultValue : [
            local.defaultValue
        ];
        return local.defaultValue;
    });
    const onChange = (value)=>{
        if (local.multiple) local.onChange?.(value);
        else // use `null` as "no value" because `undefined` mean the component is "uncontrolled".
        local.onChange?.(value[0] ?? null);
    };
    return (0, _web.createComponent)(SelectBase, (0, _web.mergeProps)({
        get value () {
            return value();
        },
        get defaultValue () {
            return defaultValue();
        },
        onChange: onChange,
        get selectionMode () {
            return local.multiple ? "multiple" : "single";
        }
    }, others));
}
function SelectTrigger(props) {
    const formControlContext = useFormControlContext();
    const context = useSelectContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("trigger")
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "disabled",
        "onPointerDown",
        "onClick",
        "onKeyDown",
        "onFocus",
        "onBlur"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const selectionManager = ()=>context.listState().selectionManager();
    const keyboardDelegate = ()=>context.keyboardDelegate();
    const isDisabled = ()=>local.disabled || context.isDisabled();
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    const { typeSelectHandlers  } = createTypeSelect({
        keyboardDelegate: keyboardDelegate,
        selectionManager: selectionManager,
        onTypeSelect: (key)=>selectionManager().select(key)
    });
    const ariaLabelledBy = ()=>{
        return [
            context.listboxAriaLabelledBy(),
            context.valueId()
        ].filter(Boolean).join(" ") || undefined;
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        e.currentTarget.dataset.pointerType = e.pointerType;
        // For consistency with native, open the select on mouse down (main button), but touch up.
        if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
            // prevent trigger from stealing focus from the active item after opening.
            e.preventDefault();
            context.toggle(true);
        }
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        if (!isDisabled() && e.currentTarget.dataset.pointerType === "touch") context.toggle(true);
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (isDisabled()) return;
        (0, _utils.callHandler)(e, typeSelectHandlers.onKeyDown);
        switch(e.key){
            case "Enter":
            case " ":
            case "ArrowDown":
                e.stopPropagation();
                e.preventDefault();
                context.toggle("first");
                break;
            case "ArrowUp":
                e.stopPropagation();
                e.preventDefault();
                context.toggle("last");
                break;
            case "ArrowLeft":
                {
                    // prevent scrolling containers
                    e.preventDefault();
                    if (context.isMultiple()) return;
                    const firstSelectedKey = selectionManager().firstSelectedKey();
                    const key = firstSelectedKey != null ? keyboardDelegate().getKeyAbove?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
                    if (key != null) selectionManager().select(key);
                    break;
                }
            case "ArrowRight":
                {
                    // prevent scrolling containers
                    e.preventDefault();
                    if (context.isMultiple()) return;
                    const firstSelectedKey1 = selectionManager().firstSelectedKey();
                    const key1 = firstSelectedKey1 != null ? keyboardDelegate().getKeyBelow?.(firstSelectedKey1) : keyboardDelegate().getFirstKey?.();
                    if (key1 != null) selectionManager().select(key1);
                    break;
                }
        }
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        if (selectionManager().isFocused()) return;
        selectionManager().setFocused(true);
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        if (context.isOpen()) return;
        selectionManager().setFocused(false);
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTriggerId(fieldProps.id())));
    (0, _solidJs.createEffect)(()=>{
        context.setListboxAriaLabelledBy([
            fieldProps.ariaLabelledBy(),
            fieldProps.ariaLabel() && !fieldProps.ariaLabelledBy() ? fieldProps.id() : null
        ].filter(Boolean).join(" ") || undefined);
    });
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.setTriggerRef, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return fieldProps.id();
        },
        get disabled () {
            return isDisabled();
        },
        "aria-haspopup": "listbox",
        get ["aria-expanded"] () {
            return context.isOpen();
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.listboxId() : undefined;
        },
        get ["aria-label"] () {
            return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"] () {
            return ariaLabelledBy();
        },
        get ["aria-describedby"] () {
            return fieldProps.ariaDescribedBy();
        },
        onPointerDown: onPointerDown,
        onClick: onClick,
        onKeyDown: onKeyDown,
        onFocus: onFocus,
        onBlur: onBlur
    }, ()=>context.dataset(), ()=>formControlContext.dataset(), others));
}
const _tmpl$$5 = /*#__PURE__*/ (0, _web.template)(`<span>`);
/**
 * The part that reflects the selected value(s).
 */ function SelectValue(props) {
    const formControlContext = useFormControlContext();
    const context = useSelectContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("value")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id",
        "children"
    ]);
    const selectionManager = ()=>context.listState().selectionManager();
    const isSelectionEmpty = ()=>{
        const selectedKeys = selectionManager().selectedKeys();
        // Some form libraries uses an empty string as default value, often taken from an empty `<option />`.
        // Ignore since it is not a valid key.
        if (selectedKeys.size === 1 && selectedKeys.has("")) return true;
        return selectionManager().isEmpty();
    };
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerValueId(local.id)));
    return (()=>{
        const _el$ = _tmpl$$5();
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get id () {
                return local.id;
            },
            get ["data-placeholder-shown"] () {
                return isSelectionEmpty() ? "" : undefined;
            }
        }, ()=>formControlContext.dataset(), others), false, true);
        (0, _web.insert)(_el$, (0, _web.createComponent)((0, _solidJs.Show), {
            get when () {
                return !isSelectionEmpty();
            },
            get fallback () {
                return context.placeholder();
            },
            get children () {
                return (0, _web.createComponent)(SelectValueChild, {
                    state: {
                        selectedOption: ()=>context.selectedOptions()[0],
                        selectedOptions: ()=>context.selectedOptions(),
                        remove: (option)=>context.removeOptionFromSelection(option),
                        clear: ()=>selectionManager().clearSelection()
                    },
                    get children () {
                        return local.children;
                    }
                });
            }
        }));
        return _el$;
    })();
}
function SelectValueChild(props) {
    const resolvedChildren = (0, _solidJs.children)(()=>{
        const body = props.children;
        return (0, _utils.isFunction)(body) ? body(props.state) : body;
    });
    return (0, _web.memo)(resolvedChildren);
}
var index$8 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    Content: SelectContent,
    Description: FormControlDescription,
    ErrorMessage: FormControlErrorMessage,
    HiddenSelect: SelectHiddenSelect,
    Icon: SelectIcon,
    Item: ListboxItem,
    ItemDescription: ListboxItemDescription,
    ItemIndicator: ListboxItemIndicator,
    ItemLabel: ListboxItemLabel,
    Label: SelectLabel,
    Listbox: SelectListbox,
    Portal: SelectPortal,
    Root: SelectRoot,
    Section: ListboxSection,
    Trigger: SelectTrigger,
    Value: SelectValue
});
function Skeleton(props) {
    const defaultId = `skeleton-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        visible: true,
        animate: true,
        id: defaultId
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "style",
        "ref",
        "radius",
        "animate",
        "height",
        "width",
        "visible",
        "circle"
    ]);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        role: "group",
        get ["data-animate"] () {
            return local.animate;
        },
        get ["data-visible"] () {
            return local.visible;
        },
        get style () {
            return {
                "border-radius": local.circle ? "9999px" : local.radius ? `${local.radius}px` : undefined,
                width: local.circle ? `${local.height}px` : local.width ? `${local.width}px` : "100%",
                height: local.height ? `${local.height}px` : "auto",
                ...local.style
            };
        }
    }, others));
}
var index$7 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Root: Skeleton
});
const SliderContext = (0, _solidJs.createContext)();
function useSliderContext() {
    const context = (0, _solidJs.useContext)(SliderContext);
    if (context === undefined) throw new Error("[kobalte]: `useSliderContext` must be used within a `Slider.Root` component");
    return context;
}
/**
 * The component that visually represents the slider value.
 * Used to visually show the fill of `Slider.Track`.
 */ function SliderFill(props) {
    const context = useSliderContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "style"
    ]);
    const percentages = ()=>{
        return context.state.values().map((value)=>context.state.getValuePercent(value) * 100);
    };
    const offsetStart = ()=>{
        return context.state.values().length > 1 ? Math.min(...percentages()) : 0;
    };
    const offsetEnd = ()=>{
        return 100 - Math.max(...percentages());
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get style () {
            return {
                [context.startEdge()]: `${offsetStart()}%`,
                [context.endEdge()]: `${offsetEnd()}%`,
                ...local.style
            };
        }
    }, ()=>context.dataset(), others));
}
function SliderThumb(props) {
    let ref;
    const context = useSliderContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId(`thumb-${(0, _solidJs.createUniqueId)()}`)
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onKeyDown",
        "onPointerDown",
        "onPointerMove",
        "onPointerUp",
        "onFocus",
        "onBlur"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    createDomCollectionItem({
        getItem: ()=>({
                ref: ()=>ref,
                disabled: context.state.isDisabled(),
                key: fieldProps.id(),
                textValue: "",
                type: "item"
            })
    });
    const index = ()=>ref ? context.thumbs().findIndex((v)=>v.ref() === ref) : -1;
    const value = ()=>context.state.getThumbValue(index());
    const position = ()=>{
        return context.state.getThumbPercent(index());
    };
    const transform = ()=>{
        /*
    let value = 50;
    const isVertical = context.state.orientation() === "vertical";
     if (isVertical) {
      value *= context.isSlidingFromBottom() ? 1 : -1;
    } else {
      value *= context.isSlidingFromLeft() ? -1 : 1;
    }
     return isVertical ? `translate(-50%, ${value}%)` : `translate(${value}%, -50%)`;
     */ return context.state.orientation() === "vertical" ? "translateY(50%)" : "translateX(-50%)";
    };
    let startPosition = 0;
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        context.onStepKeyDown(e, index());
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        const target = e.currentTarget;
        e.preventDefault();
        e.stopPropagation();
        target.setPointerCapture(e.pointerId);
        target.focus();
        startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
        if (value() !== undefined) context.onSlideStart?.(index(), value());
    };
    const onPointerMove = (e)=>{
        e.stopPropagation();
        (0, _utils.callHandler)(e, local.onPointerMove);
        const target = e.currentTarget;
        if (target.hasPointerCapture(e.pointerId)) {
            const delta = {
                deltaX: e.clientX - startPosition,
                deltaY: e.clientY - startPosition
            };
            context.onSlideMove?.(delta);
            startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
        }
    };
    const onPointerUp = (e)=>{
        e.stopPropagation();
        (0, _utils.callHandler)(e, local.onPointerUp);
        const target = e.currentTarget;
        if (target.hasPointerCapture(e.pointerId)) {
            target.releasePointerCapture(e.pointerId);
            context.onSlideEnd?.();
        }
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        context.state.setFocusedThumb(index());
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        context.state.setFocusedThumb(undefined);
    };
    (0, _solidJs.onMount)(()=>{
        context.state.setThumbEditable(index(), !context.state.isDisabled());
    });
    return (0, _web.createComponent)(ThumbContext.Provider, {
        value: {
            index
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "span",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                role: "slider",
                get id () {
                    return fieldProps.id();
                },
                get tabIndex () {
                    return context.state.isDisabled() ? undefined : 0;
                },
                get style () {
                    return {
                        display: value() === undefined ? "none" : undefined,
                        position: "absolute",
                        [context.startEdge()]: `calc(${position() * 100}%)`,
                        transform: transform(),
                        "touch-action": "none",
                        ...local.style
                    };
                },
                get ["aria-valuetext"] () {
                    return context.state.getThumbValueLabel(index());
                },
                get ["aria-valuemin"] () {
                    return context.minValue();
                },
                get ["aria-valuenow"] () {
                    return value();
                },
                get ["aria-valuemax"] () {
                    return context.maxValue();
                },
                get ["aria-orientation"] () {
                    return context.state.orientation();
                },
                get ["aria-label"] () {
                    return fieldProps.ariaLabel();
                },
                get ["aria-labelledby"] () {
                    return fieldProps.ariaLabelledBy();
                },
                get ["aria-describedby"] () {
                    return fieldProps.ariaDescribedBy();
                },
                onKeyDown: onKeyDown,
                onPointerDown: onPointerDown,
                onPointerMove: onPointerMove,
                onPointerUp: onPointerUp,
                onFocus: onFocus,
                onBlur: onBlur
            }, ()=>context.dataset(), others));
        }
    });
}
const ThumbContext = (0, _solidJs.createContext)();
function useThumbContext() {
    const context = (0, _solidJs.useContext)(ThumbContext);
    if (context === undefined) throw new Error("[kobalte]: `useThumbContext` must be used within a `Slider.Thumb` component");
    return context;
}
const _tmpl$$4 = /*#__PURE__*/ (0, _web.template)(`<input type="range">`);
/**
 * The native html input that is visually hidden in the slider thumb.
 */ function SliderInput(props) {
    const formControlContext = useFormControlContext();
    const context = useSliderContext();
    const thumb = useThumbContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("input")
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onChange"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    const [valueText, setValueText] = (0, _solidJs.createSignal)("");
    const onChange = (e)=>{
        (0, _utils.callHandler)(e, local.onChange);
        const target = e.target;
        context.state.setThumbValue(thumb.index(), parseFloat(target.value));
        // Unlike in React, inputs `value` can be out of sync with our value state.
        // even if an input is controlled (ex: `<input value="foo" />`,
        // typing on the input will change its internal `value`.
        //
        // To prevent this, we need to force the input `value` to be in sync with the slider value state.
        target.value = String(context.state.values()[thumb.index()]) ?? "";
    };
    (0, _solidJs.createEffect)(()=>{
        setValueText(thumb.index() === -1 ? "" : context.state.getThumbValueLabel(thumb.index()));
    });
    return (()=>{
        const _el$ = _tmpl$$4();
        _el$.addEventListener("change", onChange);
        const _ref$ = (0, _utils.mergeRefs)((el)=>el, local.ref);
        typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$);
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get id () {
                return fieldProps.id();
            },
            get name () {
                return formControlContext.name();
            },
            get tabIndex () {
                return !context.state.isDisabled() ? 0 : undefined;
            },
            get min () {
                return context.state.getThumbMinValue(thumb.index());
            },
            get max () {
                return context.state.getThumbMaxValue(thumb.index());
            },
            get step () {
                return context.state.step();
            },
            get value () {
                return context.state.values()[thumb.index()];
            },
            get required () {
                return formControlContext.isRequired();
            },
            get disabled () {
                return formControlContext.isDisabled();
            },
            get readonly () {
                return formControlContext.isReadOnly();
            },
            get style () {
                return {
                    ...(0, _utils.visuallyHiddenStyles),
                    ...local.style
                };
            },
            get ["aria-orientation"] () {
                return context.state.orientation();
            },
            get ["aria-valuetext"] () {
                return valueText();
            },
            get ["aria-label"] () {
                return fieldProps.ariaLabel();
            },
            get ["aria-labelledby"] () {
                return fieldProps.ariaLabelledBy();
            },
            get ["aria-describedby"] () {
                return fieldProps.ariaDescribedBy();
            },
            get ["aria-invalid"] () {
                return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"] () {
                return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"] () {
                return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"] () {
                return formControlContext.isReadOnly() || undefined;
            }
        }, ()=>context.dataset(), others), false, false);
        return _el$;
    })();
}
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
    const nextValues = [
        ...prevValues
    ];
    nextValues[atIndex] = nextValue;
    return nextValues.sort((a, b)=>a - b);
}
/**
 * Given a `values` array and a `nextValue`, determine which value in
 * the array is closest to `nextValue` and return its index.
 *
 * @example
 * // returns 1
 * getClosestValueIndex([10, 30], 25);
 */ function getClosestValueIndex(values, nextValue) {
    if (values.length === 1) return 0;
    const distances = values.map((value)=>Math.abs(value - nextValue));
    const closestDistance = Math.min(...distances);
    return distances.indexOf(closestDistance);
}
/**
 * Gets an array of steps between each value.
 *
 * @example
 * // returns [1, 9]
 * getStepsBetweenValues([10, 11, 20]);
 */ function getStepsBetweenValues(values) {
    return values.slice(0, -1).map((value, index)=>values[index + 1] - value);
}
/**
 * Verifies the minimum steps between all values is greater than or equal
 * to the expected minimum steps.
 *
 * @example
 * // returns false
 * hasMinStepsBetweenValues([1,2,3], 2);
 *
 * @example
 * // returns true
 * hasMinStepsBetweenValues([1,2,3], 1);
 */ function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
    if (minStepsBetweenValues > 0) {
        const stepsBetweenValues = getStepsBetweenValues(values);
        const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
        return actualMinStepsBetweenValues >= minStepsBetweenValues;
    }
    return true;
}
// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js
function linearScale(input, output) {
    return (value)=>{
        if (input[0] === input[1] || output[0] === output[1]) return output[0];
        const ratio = (output[1] - output[0]) / (input[1] - input[0]);
        return output[0] + ratio * (value - input[0]);
    };
}
/* eslint-disable @typescript-eslint/no-non-null-assertion */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/1ddcde7b4fef9af7f08e11bb78d71fe60bbcc64b/packages/@react-stately/slider/src/useSliderState.ts
 */ function createSliderState(props) {
    props = (0, _utils.mergeDefaultProps)({
        minValue: ()=>0,
        maxValue: ()=>100,
        step: ()=>1,
        minStepsBetweenThumbs: ()=>0,
        orientation: ()=>"horizontal",
        isDisabled: ()=>false
    }, props);
    const pageSize = (0, _solidJs.createMemo)(()=>{
        let calcPageSize = (props.maxValue() - props.minValue()) / 10;
        calcPageSize = (0, _utils.snapValueToStep)(calcPageSize, 0, calcPageSize + props.step(), props.step());
        return Math.max(calcPageSize, props.step());
    });
    const defaultValue = (0, _solidJs.createMemo)(()=>{
        return props.defaultValue() ?? [
            props.minValue()
        ];
    });
    const [values, setValues] = createControllableArraySignal({
        value: ()=>props.value(),
        defaultValue,
        onChange: (values)=>props.onChange?.(values)
    });
    const [isDragging, setIsDragging] = (0, _solidJs.createSignal)(new Array(values().length).fill(false));
    const [isEditables, setEditables] = (0, _solidJs.createSignal)(new Array(values().length).fill(false));
    const [focusedIndex, setFocusedIndex] = (0, _solidJs.createSignal)(undefined);
    const resetValues = ()=>{
        setValues(defaultValue());
    };
    const getValuePercent = (value)=>{
        return (value - props.minValue()) / (props.maxValue() - props.minValue());
    };
    const getThumbMinValue = (index)=>{
        return index === 0 ? props.minValue() : values()[index - 1];
    };
    const getThumbMaxValue = (index)=>{
        return index === values().length - 1 ? props.maxValue() : values()[index + 1];
    };
    const isThumbEditable = (index)=>{
        return isEditables()[index];
    };
    const setThumbEditable = (index)=>{
        setEditables((p)=>{
            p[index] = true;
            return p;
        });
    };
    const updateValue = (index, value)=>{
        if (props.isDisabled() || !isThumbEditable(index)) return;
        value = (0, _utils.snapValueToStep)(value, getThumbMinValue(index), getThumbMaxValue(index), props.step());
        const nextValues = getNextSortedValues(values(), value, index);
        if (!hasMinStepsBetweenValues(nextValues, props.minStepsBetweenThumbs() * props.step())) return;
        setValues((prev)=>[
                ...replaceIndex(prev, index, value)
            ]);
    };
    const updateDragging = (index, dragging)=>{
        if (props.isDisabled() || !isThumbEditable(index)) return;
        const wasDragging = isDragging()[index];
        setIsDragging((p)=>[
                ...replaceIndex(p, index, dragging)
            ]);
        if (wasDragging && !isDragging().some(Boolean)) props.onChangeEnd?.(values());
    };
    const getFormattedValue = (value)=>{
        return props.numberFormatter.format(value);
    };
    const setThumbPercent = (index, percent)=>{
        updateValue(index, getPercentValue(percent));
    };
    const getRoundedValue = (value)=>{
        return Math.round((value - props.minValue()) / props.step()) * props.step() + props.minValue();
    };
    const getPercentValue = (percent)=>{
        const val = percent * (props.maxValue() - props.minValue()) + props.minValue();
        return (0, _utils.clamp)(getRoundedValue(val), props.minValue(), props.maxValue());
    };
    const incrementThumb = (index, stepSize = 1)=>{
        const s = Math.max(stepSize, props.step());
        const nextValue = values()[index] + s;
        const nextValues = getNextSortedValues(values(), nextValue, index);
        if (hasMinStepsBetweenValues(nextValues, props.minStepsBetweenThumbs() * props.step())) updateValue(index, (0, _utils.snapValueToStep)(nextValue, props.minValue(), props.maxValue(), props.step()));
    };
    const decrementThumb = (index, stepSize = 1)=>{
        const s = Math.max(stepSize, props.step());
        const nextValue = values()[index] - s;
        const nextValues = getNextSortedValues(values(), nextValue, index);
        if (hasMinStepsBetweenValues(nextValues, props.minStepsBetweenThumbs() * props.step())) updateValue(index, (0, _utils.snapValueToStep)(nextValue, props.minValue(), props.maxValue(), props.step()));
    };
    return {
        values,
        getThumbValue: (index)=>values()[index],
        setThumbValue: updateValue,
        setThumbPercent,
        isThumbDragging: (index)=>isDragging()[index],
        setThumbDragging: updateDragging,
        focusedThumb: focusedIndex,
        setFocusedThumb: setFocusedIndex,
        getThumbPercent: (index)=>getValuePercent(values()[index]),
        getValuePercent,
        getThumbValueLabel: (index)=>getFormattedValue(values()[index]),
        getFormattedValue,
        getThumbMinValue,
        getThumbMaxValue,
        getPercentValue,
        isThumbEditable,
        setThumbEditable,
        incrementThumb,
        decrementThumb,
        step: props.step,
        pageSize,
        orientation: props.orientation,
        isDisabled: props.isDisabled,
        setValues,
        resetValues
    };
}
function replaceIndex(array, index, value) {
    if (array[index] === value) return array;
    return [
        ...array.slice(0, index),
        value,
        ...array.slice(index + 1)
    ];
}
function SliderRoot(props) {
    let ref;
    const defaultId = `slider-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        minValue: 0,
        maxValue: 100,
        step: 1,
        minStepsBetweenThumbs: 0,
        orientation: "horizontal",
        disabled: false,
        inverted: false,
        getValueLabel: (params)=>params.values.join(", ")
    }, props);
    const [local, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "value",
        "defaultValue",
        "onChange",
        "onChangeEnd",
        "inverted",
        "minValue",
        "maxValue",
        "step",
        "minStepsBetweenThumbs",
        "getValueLabel",
        "orientation"
    ], FORM_CONTROL_PROP_NAMES);
    const { formControlContext  } = createFormControl(formControlProps);
    const defaultFormatter = createNumberFormatter(()=>({
            style: "decimal"
        }));
    const { direction  } = useLocale();
    const state = createSliderState({
        value: ()=>local.value,
        defaultValue: ()=>local.defaultValue ?? [
                local.minValue
            ],
        maxValue: ()=>local.maxValue,
        minValue: ()=>local.minValue,
        minStepsBetweenThumbs: ()=>local.minStepsBetweenThumbs,
        isDisabled: ()=>formControlContext.isDisabled() ?? false,
        orientation: ()=>local.orientation,
        step: ()=>local.step,
        numberFormatter: defaultFormatter(),
        onChange: local.onChange,
        onChangeEnd: local.onChangeEnd
    });
    const [thumbs, setThumbs] = (0, _solidJs.createSignal)([]);
    const { DomCollectionProvider  } = createDomCollection({
        items: thumbs,
        onItemsChange: setThumbs
    });
    createFormResetListener(()=>ref, ()=>state.resetValues());
    const isLTR = ()=>direction() === "ltr";
    const isSlidingFromLeft = ()=>{
        return isLTR() && !local.inverted || !isLTR() && local.inverted;
    };
    const isSlidingFromBottom = ()=>!local.inverted;
    const isVertical = ()=>state.orientation() === "vertical";
    const dataset = (0, _solidJs.createMemo)(()=>{
        return {
            ...formControlContext.dataset(),
            "data-orientation": local.orientation
        };
    });
    const [trackRef, setTrackRef] = (0, _solidJs.createSignal)();
    let currentPosition = null;
    const onSlideStart = (index, value)=>{
        state.setFocusedThumb(index);
        state.setThumbDragging(index, true);
        state.setThumbValue(index, value);
        currentPosition = null;
    };
    const onSlideMove = ({ deltaX , deltaY  })=>{
        const active = state.focusedThumb();
        if (active === undefined) return;
        const { width , height  } = trackRef().getBoundingClientRect();
        const size = isVertical() ? height : width;
        if (currentPosition === null) currentPosition = state.getThumbPercent(state.focusedThumb()) * size;
        let delta = isVertical() ? deltaY : deltaX;
        if (!isVertical() && local.inverted || isVertical() && isSlidingFromBottom()) delta = -delta;
        currentPosition += delta;
        const percent = (0, _utils.clamp)(currentPosition / size, 0, 1);
        const nextValues = getNextSortedValues(state.values(), currentPosition, active);
        if (hasMinStepsBetweenValues(nextValues, local.minStepsBetweenThumbs * state.step())) {
            state.setThumbPercent(state.focusedThumb(), percent);
            local.onChange?.(state.values());
        }
    };
    const onSlideEnd = ()=>{
        const activeThumb = state.focusedThumb();
        if (activeThumb !== undefined) {
            state.setThumbDragging(activeThumb, false);
            local.onChangeEnd?.(state.values());
        }
    };
    const onHomeKeyDown = ()=>{
        !formControlContext.isDisabled() && state.focusedThumb() !== undefined && state.setThumbValue(0, state.getThumbMinValue(0));
    };
    const onEndKeyDown = ()=>{
        !formControlContext.isDisabled() && state.focusedThumb() !== undefined && state.setThumbValue(state.values().length - 1, state.getThumbMaxValue(state.values().length - 1));
    };
    const onStepKeyDown = (event, index)=>{
        if (!formControlContext.isDisabled()) switch(event.key){
            case "Left":
            case "ArrowLeft":
                event.preventDefault();
                event.stopPropagation();
                if (!isLTR()) state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                else state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                break;
            case "Right":
            case "ArrowRight":
                event.preventDefault();
                event.stopPropagation();
                if (!isLTR()) state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                else state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                break;
            case "Up":
            case "ArrowUp":
                event.preventDefault();
                event.stopPropagation();
                if (!isLTR()) state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                else state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                break;
            case "Down":
            case "ArrowDown":
                event.preventDefault();
                event.stopPropagation();
                if (!isLTR()) state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                else state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
                break;
            case "Home":
                onHomeKeyDown();
                break;
            case "End":
                onEndKeyDown();
                break;
            case "PageUp":
                state.incrementThumb(index, state.pageSize());
                break;
            case "PageDown":
                state.decrementThumb(index, state.pageSize());
                break;
        }
    };
    const startEdge = (0, _solidJs.createMemo)(()=>{
        if (isVertical()) return isSlidingFromBottom() ? "bottom" : "top";
        return isSlidingFromLeft() ? "left" : "right";
    });
    const endEdge = (0, _solidJs.createMemo)(()=>{
        if (isVertical()) return isSlidingFromBottom() ? "top" : "bottom";
        return isSlidingFromLeft() ? "right" : "left";
    });
    const context = {
        dataset,
        state,
        thumbs,
        setThumbs,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onStepKeyDown,
        isSlidingFromLeft,
        isSlidingFromBottom,
        trackRef,
        minValue: ()=>local.minValue,
        maxValue: ()=>local.maxValue,
        inverted: ()=>local.inverted,
        startEdge,
        endEdge,
        registerTrack: (ref)=>setTrackRef(ref),
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        getValueLabel: local.getValueLabel
    };
    return (0, _web.createComponent)(DomCollectionProvider, {
        get children () {
            return (0, _web.createComponent)(FormControlContext.Provider, {
                value: formControlContext,
                get children () {
                    return (0, _web.createComponent)(SliderContext.Provider, {
                        value: context,
                        get children () {
                            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                                as: "div",
                                ref (r$) {
                                    const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                                    typeof _ref$ === "function" && _ref$(r$);
                                },
                                role: "group",
                                get id () {
                                    return (0, _utils.access)(formControlProps.id);
                                }
                            }, dataset, others));
                        }
                    });
                }
            });
        }
    });
}
/**
 * The component that visually represents the slider track.
 * Act as a container for `Slider.Fill`.
 */ function SliderTrack(props) {
    const context = useSliderContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onPointerDown",
        "onPointerMove",
        "onPointerUp"
    ]);
    const [sRect, setRect] = (0, _solidJs.createSignal)();
    function getValueFromPointer(pointerPosition) {
        const rect = sRect() || context.trackRef().getBoundingClientRect();
        const input = [
            0,
            context.state.orientation() === "vertical" ? rect.height : rect.width
        ];
        let output = context.isSlidingFromLeft() ? [
            context.minValue(),
            context.maxValue()
        ] : [
            context.maxValue(),
            context.minValue()
        ];
        if (context.state.orientation() === "vertical") output = context.isSlidingFromBottom() ? [
            context.maxValue(),
            context.minValue()
        ] : [
            context.minValue(),
            context.maxValue()
        ];
        const value = linearScale(input, output);
        setRect(rect);
        return value(pointerPosition - (context.state.orientation() === "vertical" ? rect.top : rect.left));
    }
    let startPosition = 0;
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        const target = e.target;
        target.setPointerCapture(e.pointerId);
        e.preventDefault();
        const value = getValueFromPointer(context.state.orientation() === "horizontal" ? e.clientX : e.clientY);
        startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
        const closestIndex = getClosestValueIndex(context.state.values(), value);
        context.onSlideStart?.(closestIndex, value);
    };
    const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        const target = e.target;
        if (target.hasPointerCapture(e.pointerId)) {
            context.onSlideMove?.({
                deltaX: e.clientX - startPosition,
                deltaY: e.clientY - startPosition
            });
            startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
        }
    };
    const onPointerUp = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerUp);
        const target = e.target;
        if (target.hasPointerCapture(e.pointerId)) {
            target.releasePointerCapture(e.pointerId);
            setRect(undefined);
            context.onSlideEnd?.();
        }
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)(context.registerTrack, props.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        onPointerDown: onPointerDown,
        onPointerMove: onPointerMove,
        onPointerUp: onPointerUp
    }, ()=>context.dataset(), others));
}
/**
 * The accessible label text representing the current value in a human-readable format.
 */ function SliderValueLabel(props) {
    const context = useSliderContext();
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div"
    }, ()=>context.dataset(), props, {
        get children () {
            return context.getValueLabel?.({
                values: context.state.values(),
                max: context.maxValue(),
                min: context.minValue()
            });
        }
    }));
}
var index$6 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Description: FormControlDescription,
    ErrorMessage: FormControlErrorMessage,
    Fill: SliderFill,
    Input: SliderInput,
    Label: FormControlLabel,
    Root: SliderRoot,
    Thumb: SliderThumb,
    Track: SliderTrack,
    ValueLabel: SliderValueLabel
});
const SwitchContext = (0, _solidJs.createContext)();
function useSwitchContext() {
    const context = (0, _solidJs.useContext)(SwitchContext);
    if (context === undefined) throw new Error("[kobalte]: `useSwitchContext` must be used within a `Switch` component");
    return context;
}
/**
 * The element that visually represents a switch.
 */ function SwitchControl(props) {
    const formControlContext = useFormControlContext();
    const context = useSwitchContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("control")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "onClick",
        "onKeyDown"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.toggle();
        context.inputRef()?.focus();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (e.key === (0, _utils.EventKey).Space) {
            context.toggle();
            context.inputRef()?.focus();
        }
    };
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        onClick: onClick,
        onKeyDown: onKeyDown
    }, ()=>formControlContext.dataset(), ()=>context.dataset(), others));
}
/**
 * The description that gives the user more information on the switch.
 */ function SwitchDescription(props) {
    const context = useSwitchContext();
    return (0, _web.createComponent)(FormControlDescription, (0, _web.mergeProps)(()=>context.dataset(), props));
}
/**
 * The error message that gives the user information about how to fix a validation error on the switch.
 */ function SwitchErrorMessage(props) {
    const context = useSwitchContext();
    return (0, _web.createComponent)(FormControlErrorMessage, (0, _web.mergeProps)(()=>context.dataset(), props));
}
const _tmpl$$3 = /*#__PURE__*/ (0, _web.template)(`<input type="checkbox" role="switch">`);
/**
 * The native html input that is visually hidden in the switch.
 */ function SwitchInput(props) {
    const formControlContext = useFormControlContext();
    const context = useSwitchContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("input")
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style",
        "onChange",
        "onFocus",
        "onBlur"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    const onChange = (e)=>{
        (0, _utils.callHandler)(e, local.onChange);
        e.stopPropagation();
        const target = e.target;
        context.setIsChecked(target.checked);
        // Unlike in React, inputs `checked` state can be out of sync with our toggle state.
        // for example a readonly `<input type="checkbox" />` is always "checkable".
        //
        // Also, even if an input is controlled (ex: `<input type="checkbox" checked={isChecked} />`,
        // clicking on the input will change its internal `checked` state.
        //
        // To prevent this, we need to force the input `checked` state to be in sync with the toggle state.
        target.checked = context.checked();
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        context.setIsFocused(true);
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        context.setIsFocused(false);
    };
    return (()=>{
        const _el$ = _tmpl$$3();
        _el$.addEventListener("blur", onBlur);
        _el$.addEventListener("focus", onFocus);
        _el$.addEventListener("change", onChange);
        const _ref$ = (0, _utils.mergeRefs)(context.setInputRef, local.ref);
        typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$);
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get id () {
                return fieldProps.id();
            },
            get name () {
                return formControlContext.name();
            },
            get value () {
                return context.value();
            },
            get checked () {
                return context.checked();
            },
            get required () {
                return formControlContext.isRequired();
            },
            get disabled () {
                return formControlContext.isDisabled();
            },
            get readonly () {
                return formControlContext.isReadOnly();
            },
            get style () {
                return {
                    ...(0, _utils.visuallyHiddenStyles),
                    ...local.style
                };
            },
            get ["aria-label"] () {
                return fieldProps.ariaLabel();
            },
            get ["aria-labelledby"] () {
                return fieldProps.ariaLabelledBy();
            },
            get ["aria-describedby"] () {
                return fieldProps.ariaDescribedBy();
            },
            get ["aria-invalid"] () {
                return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"] () {
                return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"] () {
                return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"] () {
                return formControlContext.isReadOnly() || undefined;
            }
        }, ()=>formControlContext.dataset(), ()=>context.dataset(), others), false, false);
        return _el$;
    })();
}
/**
 * The label that gives the user information on the switch.
 */ function SwitchLabel(props) {
    const context = useSwitchContext();
    return (0, _web.createComponent)(FormControlLabel, (0, _web.mergeProps)(()=>context.dataset(), props));
}
/**
 * A control that allows users to choose one of two values: on or off.
 */ function SwitchRoot(props) {
    let ref;
    const defaultId = `switch-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        value: "on",
        id: defaultId
    }, props);
    const [local, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "children",
        "value",
        "checked",
        "defaultChecked",
        "onChange",
        "onPointerDown"
    ], FORM_CONTROL_PROP_NAMES);
    const [inputRef, setInputRef] = (0, _solidJs.createSignal)();
    const [isFocused, setIsFocused] = (0, _solidJs.createSignal)(false);
    const { formControlContext  } = createFormControl(formControlProps);
    const state = createToggleState({
        isSelected: ()=>local.checked,
        defaultIsSelected: ()=>local.defaultChecked,
        onSelectedChange: (selected)=>local.onChange?.(selected),
        isDisabled: ()=>formControlContext.isDisabled(),
        isReadOnly: ()=>formControlContext.isReadOnly()
    });
    createFormResetListener(()=>ref, ()=>state.setIsSelected(local.defaultChecked ?? false));
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        // For consistency with native, prevent the input blurs on pointer down.
        if (isFocused()) e.preventDefault();
    };
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-checked": state.isSelected() ? "" : undefined
        }));
    const context = {
        value: ()=>local.value,
        dataset,
        checked: ()=>state.isSelected(),
        inputRef,
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        toggle: ()=>state.toggle(),
        setIsChecked: (isChecked)=>state.setIsSelected(isChecked),
        setIsFocused,
        setInputRef
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(SwitchContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                        as: "div",
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "group",
                        get id () {
                            return (0, _utils.access)(formControlProps.id);
                        },
                        onPointerDown: onPointerDown
                    }, ()=>formControlContext.dataset(), dataset, others, {
                        get children () {
                            return (0, _web.createComponent)(SwitchRootChild, {
                                state: context,
                                get children () {
                                    return local.children;
                                }
                            });
                        }
                    }));
                }
            });
        }
    });
}
function SwitchRootChild(props) {
    const resolvedChildren = (0, _solidJs.children)(()=>{
        const body = props.children;
        return (0, _utils.isFunction)(body) ? body(props.state) : body;
    });
    return (0, _web.memo)(resolvedChildren);
}
/**
 * The thumb that is used to visually indicate whether the switch is on or off.
 */ function SwitchThumb(props) {
    const formControlContext = useFormControlContext();
    const context = useSwitchContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("thumb")
    }, props);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div"
    }, ()=>formControlContext.dataset(), ()=>context.dataset(), props));
}
var index$5 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Control: SwitchControl,
    Description: SwitchDescription,
    ErrorMessage: SwitchErrorMessage,
    Input: SwitchInput,
    Label: SwitchLabel,
    Root: SwitchRoot,
    Thumb: SwitchThumb
});
const TabsContext = (0, _solidJs.createContext)();
function useTabsContext() {
    const context = (0, _solidJs.useContext)(TabsContext);
    if (context === undefined) throw new Error("[kobalte]: `useTabsContext` must be used within a `Tabs` component");
    return context;
}
/**
 * Contains the content associated with a tab trigger.
 */ function TabsContent(props) {
    let ref;
    const context = useTabsContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "value",
        "forceMount"
    ]);
    const [tabIndex, setTabIndex] = (0, _solidJs.createSignal)(0);
    const id = ()=>local.id ?? context.generateContentId(local.value);
    const isSelected = ()=>context.listState().selectedKey() === local.value;
    const presence = createPresence(()=>local.forceMount || isSelected());
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>ref,
        ()=>presence.isPresent()
    ], ([ref, isPresent])=>{
        if (ref == null || !isPresent) return;
        const updateTabIndex = ()=>{
            // Detect if there are any tabbable elements and update the tabIndex accordingly.
            const walker = (0, _utils.getFocusableTreeWalker)(ref, {
                tabbable: true
            });
            setTabIndex(walker.nextNode() ? undefined : 0);
        };
        updateTabIndex();
        const observer = new MutationObserver(updateTabIndex);
        // Update when new elements are inserted, or the tabindex/disabled attribute updates.
        observer.observe(ref, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: [
                "tabindex",
                "disabled"
            ]
        });
        (0, _solidJs.onCleanup)(()=>{
            observer.disconnect();
        });
    }));
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>local.value,
        id
    ], ([value, id])=>{
        context.contentIdsMap().set(value, id);
    }));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return presence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                as: "div",
                ref (r$) {
                    const _ref$ = (0, _utils.mergeRefs)((el)=>{
                        presence.setRef(el);
                        ref = el;
                    }, local.ref);
                    typeof _ref$ === "function" && _ref$(r$);
                },
                get id () {
                    return id();
                },
                role: "tabpanel",
                get tabIndex () {
                    return tabIndex();
                },
                get ["aria-labelledby"] () {
                    return context.triggerIdsMap().get(local.value);
                },
                get ["data-orientation"] () {
                    return context.orientation();
                },
                get ["data-selected"] () {
                    return isSelected() ? "" : undefined;
                }
            }, others));
        }
    });
}
/**
 * The visual indicator displayed at the bottom of the tab list to indicate the selected tab.
 * It provides the base style needed to display a smooth transition to the new selected tab.
 */ function TabsIndicator(props) {
    const context = useTabsContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "style"
    ]);
    const [style, setStyle] = (0, _solidJs.createSignal)({
        width: undefined,
        height: undefined
    });
    const { direction  } = useLocale();
    const computeStyle = ()=>{
        const selectedTab = context.selectedTab();
        if (selectedTab == null) return;
        const styleObj = {
            transform: undefined,
            width: undefined,
            height: undefined
        };
        // In RTL, calculate the transform from the right edge of the tab list
        // so that resizing the window doesn't break the TabIndicator position due to offsetLeft changes
        const offset = direction() === "rtl" ? -1 * (selectedTab.offsetParent?.offsetWidth - selectedTab.offsetWidth - selectedTab.offsetLeft) : selectedTab.offsetLeft;
        styleObj.transform = context.orientation() === "vertical" ? `translateY(${selectedTab.offsetTop}px)` : `translateX(${offset}px)`;
        if (context.orientation() === "horizontal") styleObj.width = `${selectedTab.offsetWidth}px`;
        else styleObj.height = `${selectedTab.offsetHeight}px`;
        setStyle(styleObj);
    };
    // For the first run, wait for all tabs to be mounted and registered in tabs DOM collection
    // before computing the style.
    (0, _solidJs.onMount)(()=>{
        queueMicrotask(()=>{
            computeStyle();
        });
    });
    // Compute style normally for subsequent runs.
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        context.selectedTab,
        context.orientation,
        direction
    ], ()=>{
        computeStyle();
    }, {
        defer: true
    }));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        role: "presentation",
        get style () {
            return {
                ...style(),
                ...local.style
            };
        },
        get ["data-orientation"] () {
            return context.orientation();
        }
    }, others));
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/6b51339cca0b8344507d3c8e81e7ad05d6e75f9b/packages/@react-aria/tabs/src/TabsKeyboardDelegate.ts
 */ class TabsKeyboardDelegate {
    constructor(collection, direction, orientation){
        this.collection = collection;
        this.direction = direction;
        this.orientation = orientation;
    }
    flipDirection() {
        return this.direction() === "rtl" && this.orientation() === "horizontal";
    }
    getKeyLeftOf(key) {
        if (this.flipDirection()) return this.getNextKey(key);
        else {
            if (this.orientation() === "horizontal") return this.getPreviousKey(key);
            return undefined;
        }
    }
    getKeyRightOf(key) {
        if (this.flipDirection()) return this.getPreviousKey(key);
        else {
            if (this.orientation() === "horizontal") return this.getNextKey(key);
            return undefined;
        }
    }
    getKeyAbove(key) {
        if (this.orientation() === "vertical") return this.getPreviousKey(key);
        return undefined;
    }
    getKeyBelow(key) {
        if (this.orientation() === "vertical") return this.getNextKey(key);
        return undefined;
    }
    getFirstKey() {
        let key = this.collection().getFirstKey();
        if (key == null) return;
        const item = this.collection().getItem(key);
        if (item?.disabled) key = this.getNextKey(key);
        return key;
    }
    getLastKey() {
        let key = this.collection().getLastKey();
        if (key == null) return;
        const item = this.collection().getItem(key);
        if (item?.disabled) key = this.getPreviousKey(key);
        return key;
    }
    getNextKey(key) {
        let nextKey = key;
        let nextItem;
        do {
            nextKey = this.collection().getKeyAfter(nextKey) ?? this.collection().getFirstKey();
            if (nextKey == null) return;
            nextItem = this.collection().getItem(nextKey);
            if (nextItem == null) return;
        }while (nextItem.disabled);
        return nextKey;
    }
    getPreviousKey(key) {
        let previousKey = key;
        let previousItem;
        do {
            previousKey = this.collection().getKeyBefore(previousKey) ?? this.collection().getLastKey();
            if (previousKey == null) return;
            previousItem = this.collection().getItem(previousKey);
            if (previousItem == null) return;
        }while (previousItem.disabled);
        return previousKey;
    }
}
/**
 * Contains the tabs that are aligned along the edge of the active tab panel.
 */ function TabsList(props) {
    let ref;
    const context = useTabsContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onKeyDown",
        "onMouseDown",
        "onFocusIn",
        "onFocusOut"
    ]);
    const { direction  } = useLocale();
    const delegate = new TabsKeyboardDelegate(()=>context.listState().collection(), direction, context.orientation);
    const selectableCollection = createSelectableCollection({
        selectionManager: ()=>context.listState().selectionManager(),
        keyboardDelegate: ()=>delegate,
        selectOnFocus: ()=>context.activationMode() === "automatic",
        shouldFocusWrap: false,
        // handled by the keyboard delegate
        disallowEmptySelection: true
    }, ()=>ref);
    (0, _solidJs.createEffect)(()=>{
        if (ref == null) return;
        const selectedTab = ref.querySelector(`[data-key="${context.listState().selectedKey()}"]`);
        if (selectedTab != null) context.setSelectedTab(selectedTab);
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        role: "tablist",
        get ["aria-orientation"] () {
            return context.orientation();
        },
        get ["data-orientation"] () {
            return context.orientation();
        },
        get onKeyDown () {
            return (0, _utils.composeEventHandlers)([
                local.onKeyDown,
                selectableCollection.onKeyDown
            ]);
        },
        get onMouseDown () {
            return (0, _utils.composeEventHandlers)([
                local.onMouseDown,
                selectableCollection.onMouseDown
            ]);
        },
        get onFocusIn () {
            return (0, _utils.composeEventHandlers)([
                local.onFocusIn,
                selectableCollection.onFocusIn
            ]);
        },
        get onFocusOut () {
            return (0, _utils.composeEventHandlers)([
                local.onFocusOut,
                selectableCollection.onFocusOut
            ]);
        }
    }, others));
}
/**
 * A set of layered sections of content, known as tab panels, that display one panel of content at a time.
 * `Tabs` contains all the parts of a tabs component and provide context for its children.
 */ function TabsRoot(props) {
    const defaultId = `tabs-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        orientation: "horizontal",
        activationMode: "automatic"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "value",
        "defaultValue",
        "onChange",
        "orientation",
        "activationMode",
        "disabled"
    ]);
    const [items, setItems] = (0, _solidJs.createSignal)([]);
    const [selectedTab, setSelectedTab] = (0, _solidJs.createSignal)();
    const { DomCollectionProvider  } = createDomCollection({
        items,
        onItemsChange: setItems
    });
    const listState = createSingleSelectListState({
        selectedKey: ()=>local.value,
        defaultSelectedKey: ()=>local.defaultValue,
        onSelectionChange: (key)=>local.onChange?.(String(key)),
        dataSource: items
    });
    let lastSelectedKey = listState.selectedKey();
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>listState.selectionManager(),
        ()=>listState.collection(),
        ()=>listState.selectedKey()
    ], ([selectionManager, collection, currentSelectedKey])=>{
        let selectedKey = currentSelectedKey;
        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)
        if (selectionManager.isEmpty() || selectedKey == null || !collection.getItem(selectedKey)) {
            selectedKey = collection.getFirstKey();
            let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
            // loop over tabs until we find one that isn't disabled and select that
            while(selectedItem?.disabled && selectedItem.key !== collection.getLastKey()){
                selectedKey = collection.getKeyAfter(selectedItem.key);
                selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
            }
            // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last
            if (selectedItem?.disabled && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();
            // directly set selection because replace/toggle selection won't consider disabled keys
            if (selectedKey != null) selectionManager.setSelectedKeys([
                selectedKey
            ]);
        }
        // If there isn't a focused key yet or the tabs doesn't have focus and the selected key changes,
        // change focused key to the selected key if it exists.
        if (selectionManager.focusedKey() == null || !selectionManager.isFocused() && selectedKey !== lastSelectedKey) selectionManager.setFocusedKey(selectedKey);
        lastSelectedKey = selectedKey;
    }));
    // associated value/trigger ids
    const triggerIdsMap = new Map();
    // associated value/content ids
    const contentIdsMap = new Map();
    const context = {
        isDisabled: ()=>local.disabled ?? false,
        orientation: ()=>local.orientation,
        activationMode: ()=>local.activationMode,
        triggerIdsMap: ()=>triggerIdsMap,
        contentIdsMap: ()=>contentIdsMap,
        listState: ()=>listState,
        selectedTab,
        setSelectedTab,
        generateTriggerId: (value)=>`${others.id}-trigger-${value}`,
        generateContentId: (value)=>`${others.id}-content-${value}`
    };
    return (0, _web.createComponent)(DomCollectionProvider, {
        get children () {
            return (0, _web.createComponent)(TabsContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                        as: "div",
                        get ["data-orientation"] () {
                            return context.orientation();
                        }
                    }, others));
                }
            });
        }
    });
}
/**
 * The button that activates its associated tab panel.
 */ function TabsTrigger(props) {
    let ref;
    const context = useTabsContext();
    props = (0, _utils.mergeDefaultProps)({
        type: "button"
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "id",
        "value",
        "disabled",
        "onPointerDown",
        "onPointerUp",
        "onClick",
        "onKeyDown",
        "onMouseDown",
        "onFocus"
    ]);
    const id = ()=>local.id ?? context.generateTriggerId(local.value);
    const isHighlighted = ()=>context.listState().selectionManager().focusedKey() === local.value;
    const isDisabled = ()=>local.disabled || context.isDisabled();
    const contentId = ()=>context.contentIdsMap().get(local.value);
    createDomCollectionItem({
        getItem: ()=>({
                ref: ()=>ref,
                type: "item",
                key: local.value,
                textValue: "",
                // not applicable here
                disabled: isDisabled()
            })
    });
    const selectableItem = createSelectableItem({
        key: ()=>local.value,
        selectionManager: ()=>context.listState().selectionManager(),
        disabled: isDisabled
    }, ()=>ref);
    const onClick = (e)=>{
        // Force focusing the trigger on click on safari.
        if ((0, _utils.isWebKit)()) (0, _utils.focusWithoutScrolling)(e.currentTarget);
    };
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>local.value,
        id
    ], ([value, id])=>{
        context.triggerIdsMap().set(value, id);
    }));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "button",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get id () {
            return id();
        },
        role: "tab",
        get tabIndex () {
            return (0, _web.memo)(()=>!!!isDisabled())() ? selectableItem.tabIndex() : undefined;
        },
        get disabled () {
            return isDisabled();
        },
        get ["aria-selected"] () {
            return selectableItem.isSelected();
        },
        get ["aria-disabled"] () {
            return isDisabled() || undefined;
        },
        get ["aria-controls"] () {
            return (0, _web.memo)(()=>!!selectableItem.isSelected())() ? contentId() : undefined;
        },
        get ["data-key"] () {
            return selectableItem.dataKey();
        },
        get ["data-orientation"] () {
            return context.orientation();
        },
        get ["data-selected"] () {
            return selectableItem.isSelected() ? "" : undefined;
        },
        get ["data-highlighted"] () {
            return isHighlighted() ? "" : undefined;
        },
        get ["data-disabled"] () {
            return isDisabled() ? "" : undefined;
        },
        get onPointerDown () {
            return (0, _utils.composeEventHandlers)([
                local.onPointerDown,
                selectableItem.onPointerDown
            ]);
        },
        get onPointerUp () {
            return (0, _utils.composeEventHandlers)([
                local.onPointerUp,
                selectableItem.onPointerUp
            ]);
        },
        get onClick () {
            return (0, _utils.composeEventHandlers)([
                local.onClick,
                selectableItem.onClick,
                onClick
            ]);
        },
        get onKeyDown () {
            return (0, _utils.composeEventHandlers)([
                local.onKeyDown,
                selectableItem.onKeyDown
            ]);
        },
        get onMouseDown () {
            return (0, _utils.composeEventHandlers)([
                local.onMouseDown,
                selectableItem.onMouseDown
            ]);
        },
        get onFocus () {
            return (0, _utils.composeEventHandlers)([
                local.onFocus,
                selectableItem.onFocus
            ]);
        }
    }, others));
}
var index$4 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Content: TabsContent,
    Indicator: TabsIndicator,
    List: TabsList,
    Root: TabsRoot,
    Trigger: TabsTrigger
});
const TextFieldContext = (0, _solidJs.createContext)();
function useTextFieldContext() {
    const context = (0, _solidJs.useContext)(TextFieldContext);
    if (context === undefined) throw new Error("[kobalte]: `useTextFieldContext` must be used within a `TextField` component");
    return context;
}
/**
 * The native html input of the textfield.
 */ function TextFieldInput(props) {
    return (0, _web.createComponent)(TextFieldInputBase, (0, _web.mergeProps)({
        type: "text"
    }, props));
}
function TextFieldInputBase(props) {
    const formControlContext = useFormControlContext();
    const context = useTextFieldContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("input")
    }, props);
    const [local, formControlFieldProps, others] = (0, _solidJs.splitProps)(props, [
        "onInput"
    ], FORM_CONTROL_FIELD_PROP_NAMES);
    const { fieldProps  } = createFormControlField(formControlFieldProps);
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "input",
        get id () {
            return fieldProps.id();
        },
        get name () {
            return formControlContext.name();
        },
        get value () {
            return context.value();
        },
        get required () {
            return formControlContext.isRequired();
        },
        get disabled () {
            return formControlContext.isDisabled();
        },
        get readonly () {
            return formControlContext.isReadOnly();
        },
        get ["aria-label"] () {
            return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"] () {
            return fieldProps.ariaLabelledBy();
        },
        get ["aria-describedby"] () {
            return fieldProps.ariaDescribedBy();
        },
        get ["aria-invalid"] () {
            return formControlContext.validationState() === "invalid" || undefined;
        },
        get ["aria-required"] () {
            return formControlContext.isRequired() || undefined;
        },
        get ["aria-disabled"] () {
            return formControlContext.isDisabled() || undefined;
        },
        get ["aria-readonly"] () {
            return formControlContext.isReadOnly() || undefined;
        },
        get onInput () {
            return (0, _utils.composeEventHandlers)([
                local.onInput,
                context.onInput
            ]);
        }
    }, ()=>formControlContext.dataset(), others));
}
/**
 * A text input that allow users to input custom text entries with a keyboard.
 */ function TextFieldRoot(props) {
    let ref;
    const defaultId = `textfield-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId
    }, props);
    const [local, formControlProps, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "value",
        "defaultValue",
        "onChange"
    ], FORM_CONTROL_PROP_NAMES);
    const [value, setValue] = createControllableSignal({
        value: ()=>local.value,
        defaultValue: ()=>local.defaultValue,
        onChange: (value)=>local.onChange?.(value)
    });
    const { formControlContext  } = createFormControl(formControlProps);
    createFormResetListener(()=>ref, ()=>setValue(local.defaultValue ?? ""));
    const onInput = (e)=>{
        if (formControlContext.isReadOnly() || formControlContext.isDisabled()) return;
        const target = e.target;
        setValue(target.value);
        // Unlike in React, inputs `value` can be out of sync with our value state.
        // even if an input is controlled (ex: `<input value="foo" />`,
        // typing on the input will change its internal `value`.
        //
        // To prevent this, we need to force the input `value` to be in sync with the text field value state.
        target.value = value() ?? "";
    };
    const context = {
        value,
        generateId: (0, _utils.createGenerateId)(()=>(0, _utils.access)(formControlProps.id)),
        onInput
    };
    return (0, _web.createComponent)(FormControlContext.Provider, {
        value: formControlContext,
        get children () {
            return (0, _web.createComponent)(TextFieldContext.Provider, {
                value: context,
                get children () {
                    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
                        as: "div",
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "group",
                        get id () {
                            return (0, _utils.access)(formControlProps.id);
                        }
                    }, ()=>formControlContext.dataset(), others));
                }
            });
        }
    });
}
/**
 * The native html textarea of the textfield.
 */ function TextFieldTextArea(props) {
    let ref;
    const context = useTextFieldContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("textarea")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "autoResize",
        "submitOnEnter",
        "onKeyPress"
    ]);
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>ref,
        ()=>local.autoResize,
        ()=>context.value()
    ], ([ref, autoResize])=>{
        if (!ref || !autoResize) return;
        adjustHeight(ref);
    }));
    const onKeyPress = (event)=>{
        if (ref && local.submitOnEnter && event.key === "Enter" && !event.shiftKey) {
            if (ref.form) {
                ref.form.requestSubmit();
                event.preventDefault();
            }
        }
    };
    return (0, _web.createComponent)(TextFieldInputBase, (0, _web.mergeProps)({
        as: "textarea",
        get ["aria-multiline"] () {
            return local.submitOnEnter ? "false" : undefined;
        },
        get onKeyPress () {
            return (0, _utils.composeEventHandlers)([
                local.onKeyPress,
                onKeyPress
            ]);
        },
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        }
    }, others));
}
/**
 * Adjust the height of the textarea based on its text value.
 */ function adjustHeight(el) {
    const prevAlignment = el.style.alignSelf;
    const prevOverflow = el.style.overflow;
    // Firefox scroll position is lost when `overflow: 'hidden'` is applied, so we skip applying it.
    // The measure/applied height is also incorrect/reset if we turn on and off
    // overflow: hidden in Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1787062
    const isFirefox = "MozAppearance" in el.style;
    if (!isFirefox) el.style.overflow = "hidden";
    el.style.alignSelf = "start";
    el.style.height = "auto";
    // offsetHeight - clientHeight accounts for the border/padding.
    el.style.height = `${el.scrollHeight + (el.offsetHeight - el.clientHeight)}px`;
    el.style.overflow = prevOverflow;
    el.style.alignSelf = prevAlignment;
}
var index$3 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Description: FormControlDescription,
    ErrorMessage: FormControlErrorMessage,
    Input: TextFieldInput,
    Label: FormControlLabel,
    Root: TextFieldRoot,
    TextArea: TextFieldTextArea
});
const ToastContext = (0, _solidJs.createContext)();
function useToastContext() {
    const context = (0, _solidJs.useContext)(ToastContext);
    if (context === undefined) throw new Error("[kobalte]: `useToastContext` must be used within a `Toast.Root` component");
    return context;
}
/**
 * The button that closes the toast.
 */ function ToastCloseButton(props) {
    const context = useToastContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "aria-label",
        "onClick"
    ]);
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        context.close();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get ["aria-label"] () {
            return local["aria-label"] || context.translations().close;
        },
        onClick: onClick
    }, others));
}
/**
 * An optional accessible description to be announced when the toast is open.
 */ function ToastDescription(props) {
    const context = useToastContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("description")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerDescriptionId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get id () {
            return local.id;
        }
    }, others));
}
const ToastRegionContext = (0, _solidJs.createContext)();
function useToastRegionContext() {
    const context = (0, _solidJs.useContext)(ToastRegionContext);
    if (context === undefined) throw new Error("[kobalte]: `useToastRegionContext` must be used within a `Toast.Region` component");
    return context;
}
const _tmpl$$2 = /*#__PURE__*/ (0, _web.template)(`<ol tabindex="-1">`);
/**
 * The list containing all rendered toasts.
 * Must be inside a `Toast.Region`.
 */ function ToastList(props) {
    let ref;
    const context = useToastRegionContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onFocusIn",
        "onFocusOut",
        "onPointerMove",
        "onPointerLeave"
    ]);
    const onFocusIn = (e)=>{
        (0, _utils.callHandler)(e, local.onFocusIn);
        if (context.pauseOnInteraction() && !context.isPaused()) context.pauseAllTimer();
    };
    const onFocusOut = (e)=>{
        (0, _utils.callHandler)(e, local.onFocusOut);
        // The newly focused element isn't inside the toast list.
        if (!(0, _utils.contains)(ref, e.relatedTarget)) context.resumeAllTimer();
    };
    const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (context.pauseOnInteraction() && !context.isPaused()) context.pauseAllTimer();
    };
    const onPointerLeave = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerLeave);
        // The current active element isn't inside the toast list.
        if (!(0, _utils.contains)(ref, (0, _utils.getDocument)(ref).activeElement)) context.resumeAllTimer();
    };
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        ()=>ref,
        ()=>context.hotkey()
    ], ([ref, hotkey])=>{
        if (0, _web.isServer) return;
        if (!ref) return;
        const doc = (0, _utils.getDocument)(ref);
        const onKeyDown = (event)=>{
            const isHotkeyPressed = hotkey.every((key)=>event[key] || event.code === key);
            if (isHotkeyPressed) (0, _utils.focusWithoutScrolling)(ref);
        };
        doc.addEventListener("keydown", onKeyDown);
        (0, _solidJs.onCleanup)(()=>doc.removeEventListener("keydown", onKeyDown));
    }));
    (0, _solidJs.createEffect)(()=>{
        if (!context.pauseOnPageIdle()) return;
        const win = (0, _utils.getWindow)(ref);
        win.addEventListener("blur", context.pauseAllTimer);
        win.addEventListener("focus", context.resumeAllTimer);
        (0, _solidJs.onCleanup)(()=>{
            win.removeEventListener("blur", context.pauseAllTimer);
            win.removeEventListener("focus", context.resumeAllTimer);
        });
    });
    return (()=>{
        const _el$ = _tmpl$$2();
        _el$.addEventListener("pointerleave", onPointerLeave);
        _el$.$$pointermove = onPointerMove;
        _el$.$$focusout = onFocusOut;
        _el$.$$focusin = onFocusIn;
        const _ref$ = (0, _utils.mergeRefs)((el)=>ref = el, local.ref);
        typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$);
        (0, _web.spread)(_el$, others, false, true);
        (0, _web.insert)(_el$, (0, _web.createComponent)((0, _solidJs.For), {
            get each () {
                return context.toasts();
            },
            children: (toast)=>toast.toastComponent({
                    get toastId () {
                        return toast.id;
                    }
                })
        }));
        return _el$;
    })();
}
(0, _web.delegateEvents)([
    "focusin",
    "focusout",
    "pointermove"
]);
/**
 * The component that visually represents the toast remaining lifetime.
 * Used to visually show the fill of `Toast.ProgressTrack`.
 */ function ToastProgressFill(props) {
    const rootContext = useToastRegionContext();
    const context = useToastContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "style"
    ]);
    const [lifeTime, setLifeTime] = (0, _solidJs.createSignal)(100);
    let totalElapsedTime = 0;
    (0, _solidJs.createEffect)(()=>{
        if (rootContext.isPaused() || context.isPersistent()) return;
        const intervalId = setInterval(()=>{
            const elapsedTime = new Date().getTime() - context.closeTimerStartTime() + totalElapsedTime;
            const life = Math.trunc(100 - elapsedTime / context.duration() * 100);
            setLifeTime(life < 0 ? 0 : life);
        });
        (0, _solidJs.onCleanup)(()=>{
            totalElapsedTime += new Date().getTime() - context.closeTimerStartTime();
            clearInterval(intervalId);
        });
    });
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get style () {
            return {
                "--kb-toast-progress-fill-width": `${lifeTime()}%`,
                ...local.style
            };
        }
    }, others));
}
/**
 * The component that visually represents the toast lifetime.
 * Act as a container for `Toast.ProgressFill`.
 */ function ToastProgressTrack(props) {
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        "aria-hidden": "true",
        role: "presentation"
    }, props));
}
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/tree/main/packages/%40react-aria/toast/intl
 */ const TOAST_HOTKEY_PLACEHOLDER = "{hotkey}";
const TOAST_INTL_TRANSLATIONS = {
    // `aria-label` of Toast.CloseButton.
    close: "Close"
};
const TOAST_REGION_INTL_TRANSLATIONS = {
    // `aria-label` of Toast.Region with notification count.
    notifications: (hotkeyPlaceholder)=>`Notifications (${hotkeyPlaceholder})`
};
const _tmpl$$1 = /*#__PURE__*/ (0, _web.template)(`<div role="region" tabindex="-1">`);
/**
 * The fixed area where toasts appear. Users can jump to by pressing a hotkey.
 * It is up to you to ensure the discoverability of the hotkey for keyboard users.
 */ function ToastRegion(props) {
    const defaultId = `toast-region-${(0, _solidJs.createUniqueId)()}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        hotkey: [
            "altKey",
            "KeyT"
        ],
        duration: 5000,
        limit: 3,
        swipeDirection: "right",
        swipeThreshold: 50,
        pauseOnInteraction: true,
        pauseOnPageIdle: true,
        topLayer: true,
        translations: TOAST_REGION_INTL_TRANSLATIONS
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "translations",
        "style",
        "hotkey",
        "duration",
        "limit",
        "swipeDirection",
        "swipeThreshold",
        "pauseOnInteraction",
        "pauseOnPageIdle",
        "topLayer",
        "aria-label",
        "regionId"
    ]);
    const toasts = (0, _solidJs.createMemo)(()=>toastStore.toasts().filter((toast)=>toast.region === local.regionId).slice(0, local.limit));
    const [isPaused, setIsPaused] = (0, _solidJs.createSignal)(false);
    const hasToasts = ()=>toasts().length > 0;
    const hotkeyLabel = ()=>{
        return local.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    };
    const ariaLabel = ()=>{
        const label = local["aria-label"] || local.translations.notifications(TOAST_HOTKEY_PLACEHOLDER);
        return label.replace(TOAST_HOTKEY_PLACEHOLDER, hotkeyLabel());
    };
    const topLayerAttr = ()=>({
            [DATA_TOP_LAYER_ATTR]: local.topLayer ? "" : undefined
        });
    const context = {
        isPaused,
        toasts,
        hotkey: ()=>local.hotkey,
        duration: ()=>local.duration,
        swipeDirection: ()=>local.swipeDirection,
        swipeThreshold: ()=>local.swipeThreshold,
        pauseOnInteraction: ()=>local.pauseOnInteraction,
        pauseOnPageIdle: ()=>local.pauseOnPageIdle,
        pauseAllTimer: ()=>setIsPaused(true),
        resumeAllTimer: ()=>setIsPaused(false),
        generateId: (0, _utils.createGenerateId)(()=>others.id)
    };
    return (0, _web.createComponent)(ToastRegionContext.Provider, {
        value: context,
        get children () {
            const _el$ = _tmpl$$1();
            (0, _web.spread)(_el$, (0, _web.mergeProps)({
                get ["aria-label"] () {
                    return ariaLabel();
                },
                get style () {
                    return {
                        "pointer-events": hasToasts() ? local.topLayer ? "auto" : undefined : "none",
                        ...local.style
                    };
                }
            }, topLayerAttr, others), false, false);
            return _el$;
        }
    });
}
const _tmpl$ = /*#__PURE__*/ (0, _web.template)(`<li role="status" tabindex="0" aria-atomic="true">`);
const TOAST_SWIPE_START_EVENT = "toast.swipeStart";
const TOAST_SWIPE_MOVE_EVENT = "toast.swipeMove";
const TOAST_SWIPE_CANCEL_EVENT = "toast.swipeCancel";
const TOAST_SWIPE_END_EVENT = "toast.swipeEnd";
function ToastRoot(props) {
    const defaultId = `toast-${(0, _solidJs.createUniqueId)()}`;
    const rootContext = useToastRegionContext();
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        priority: "high",
        translations: TOAST_INTL_TRANSLATIONS
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "translations",
        "toastId",
        "style",
        "priority",
        "duration",
        "persistent",
        "onPause",
        "onResume",
        "onSwipeStart",
        "onSwipeMove",
        "onSwipeCancel",
        "onSwipeEnd",
        "onEscapeKeyDown",
        "onKeyDown",
        "onPointerDown",
        "onPointerMove",
        "onPointerUp"
    ]);
    const [isOpen, setIsOpen] = (0, _solidJs.createSignal)(true);
    const [titleId, setTitleId] = (0, _solidJs.createSignal)();
    const [descriptionId, setDescriptionId] = (0, _solidJs.createSignal)();
    const [isAnimationEnabled, setIsAnimationEnabled] = (0, _solidJs.createSignal)(true);
    const presence = createPresence(isOpen);
    const duration = (0, _solidJs.createMemo)(()=>local.duration || rootContext.duration());
    let closeTimerId;
    let closeTimerStartTime = 0;
    let closeTimerRemainingTime = duration();
    let pointerStart = null;
    let swipeDelta = null;
    const close = ()=>{
        setIsOpen(false);
        // Restore animation for the exit phase, which have been disabled if it's a toast update.
        setIsAnimationEnabled(true);
    };
    const deleteToast = ()=>{
        toastStore.remove(local.toastId);
    };
    const startTimer = (duration)=>{
        if (!duration || local.persistent) return;
        window.clearTimeout(closeTimerId);
        closeTimerStartTime = new Date().getTime();
        closeTimerId = window.setTimeout(close, duration);
    };
    const resumeTimer = ()=>{
        startTimer(closeTimerRemainingTime);
        local.onResume?.();
    };
    const pauseTimer = ()=>{
        const elapsedTime = new Date().getTime() - closeTimerStartTime;
        closeTimerRemainingTime = closeTimerRemainingTime - elapsedTime;
        window.clearTimeout(closeTimerId);
        local.onPause?.();
    };
    const onKeyDown = (e)=>{
        (0, _utils.callHandler)(e, local.onKeyDown);
        if (e.key !== "Escape") return;
        local.onEscapeKeyDown?.(e);
        if (!e.defaultPrevented) close();
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        if (e.button !== 0) return;
        pointerStart = {
            x: e.clientX,
            y: e.clientY
        };
    };
    const onPointerMove = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerMove);
        if (!pointerStart) return;
        const x = e.clientX - pointerStart.x;
        const y = e.clientY - pointerStart.y;
        const hasSwipeMoveStarted = Boolean(swipeDelta);
        const isHorizontalSwipe = [
            "left",
            "right"
        ].includes(rootContext.swipeDirection());
        const clamp = [
            "left",
            "up"
        ].includes(rootContext.swipeDirection()) ? Math.min : Math.max;
        const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
        const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
        const moveStartBuffer = e.pointerType === "touch" ? 10 : 2;
        const delta = {
            x: clampedX,
            y: clampedY
        };
        const eventDetail = {
            originalEvent: e,
            delta
        };
        if (hasSwipeMoveStarted) {
            swipeDelta = delta;
            handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE_EVENT, local.onSwipeMove, eventDetail);
            const { x: x1 , y: y1  } = delta;
            e.currentTarget.setAttribute("data-swipe", "move");
            e.currentTarget.style.setProperty("--kb-toast-swipe-move-x", `${x1}px`);
            e.currentTarget.style.setProperty("--kb-toast-swipe-move-y", `${y1}px`);
        } else if (isDeltaInDirection(delta, rootContext.swipeDirection(), moveStartBuffer)) {
            swipeDelta = delta;
            handleAndDispatchCustomEvent(TOAST_SWIPE_START_EVENT, local.onSwipeStart, eventDetail);
            e.currentTarget.setAttribute("data-swipe", "start");
            e.target.setPointerCapture(e.pointerId);
        } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) // User is swiping in wrong direction, so we disable swipe gesture
        // for the current pointer down interaction
        pointerStart = null;
    };
    const onPointerUp = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerUp);
        const delta = swipeDelta;
        const target = e.target;
        if (target.hasPointerCapture(e.pointerId)) target.releasePointerCapture(e.pointerId);
        swipeDelta = null;
        pointerStart = null;
        if (delta) {
            const toast = e.currentTarget;
            const eventDetail = {
                originalEvent: e,
                delta
            };
            if (isDeltaInDirection(delta, rootContext.swipeDirection(), rootContext.swipeThreshold())) {
                handleAndDispatchCustomEvent(TOAST_SWIPE_END_EVENT, local.onSwipeEnd, eventDetail);
                const { x , y  } = delta;
                e.currentTarget.setAttribute("data-swipe", "end");
                e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
                e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
                e.currentTarget.style.setProperty("--kb-toast-swipe-end-x", `${x}px`);
                e.currentTarget.style.setProperty("--kb-toast-swipe-end-y", `${y}px`);
                close();
            } else {
                handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL_EVENT, local.onSwipeCancel, eventDetail);
                e.currentTarget.setAttribute("data-swipe", "cancel");
                e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
                e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
                e.currentTarget.style.removeProperty("--kb-toast-swipe-end-x");
                e.currentTarget.style.removeProperty("--kb-toast-swipe-end-y");
            }
            // Prevent click event from triggering on items within the toast when
            // pointer up is part of a swipe gesture
            toast.addEventListener("click", (event)=>event.preventDefault(), {
                once: true
            });
        }
    };
    (0, _solidJs.onMount)(()=>{
        // Disable animation for updated toast.
        if (rootContext.toasts().find((toast)=>toast.id === local.toastId && toast.update)) setIsAnimationEnabled(false);
    });
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>rootContext.isPaused(), (isPaused)=>{
        if (isPaused) pauseTimer();
        else resumeTimer();
    }, {
        defer: true
    }));
    // start timer when toast opens or duration changes.
    // we include `open` in deps because closed !== unmounted when animating,
    // so it could reopen before being completely unmounted
    (0, _solidJs.createEffect)((0, _solidJs.on)([
        isOpen,
        duration
    ], ([isOpen, duration])=>{
        if (isOpen && !rootContext.isPaused()) startTimer(duration);
    }));
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>toastStore.get(local.toastId)?.dismiss, (dismiss)=>dismiss && close()));
    (0, _solidJs.createEffect)((0, _solidJs.on)(()=>presence.isPresent(), (isPresent)=>!isPresent && deleteToast()));
    const context = {
        translations: ()=>local.translations,
        close,
        duration,
        isPersistent: ()=>local.persistent ?? false,
        closeTimerStartTime: ()=>closeTimerStartTime,
        generateId: (0, _utils.createGenerateId)(()=>others.id),
        registerTitleId: createRegisterId(setTitleId),
        registerDescriptionId: createRegisterId(setDescriptionId)
    };
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return presence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(ToastContext.Provider, {
                value: context,
                get children () {
                    const _el$ = _tmpl$();
                    _el$.$$pointerup = onPointerUp;
                    _el$.$$pointermove = onPointerMove;
                    _el$.$$pointerdown = onPointerDown;
                    _el$.$$keydown = onKeyDown;
                    const _ref$ = (0, _utils.mergeRefs)(presence.setRef, local.ref);
                    typeof _ref$ === "function" && (0, _web.use)(_ref$, _el$);
                    (0, _web.spread)(_el$, (0, _web.mergeProps)({
                        get style () {
                            return {
                                animation: isAnimationEnabled() ? undefined : "none",
                                "user-select": "none",
                                "touch-action": "none",
                                ...local.style
                            };
                        },
                        get ["aria-live"] () {
                            return local.priority === "high" ? "assertive" : "polite";
                        },
                        get ["aria-labelledby"] () {
                            return titleId();
                        },
                        get ["aria-describedby"] () {
                            return descriptionId();
                        },
                        get ["data-opened"] () {
                            return isOpen() ? "" : undefined;
                        },
                        get ["data-closed"] () {
                            return !isOpen() ? "" : undefined;
                        },
                        get ["data-swipe-direction"] () {
                            return rootContext.swipeDirection();
                        }
                    }, others), false, false);
                    return _el$;
                }
            });
        }
    });
}
function isDeltaInDirection(delta, direction, threshold = 0) {
    const deltaX = Math.abs(delta.x);
    const deltaY = Math.abs(delta.y);
    const isDeltaX = deltaX > deltaY;
    if (direction === "left" || direction === "right") return isDeltaX && deltaX > threshold;
    else return !isDeltaX && deltaY > threshold;
}
function handleAndDispatchCustomEvent(name, handler, detail) {
    const currentTarget = detail.originalEvent.currentTarget;
    const event = new CustomEvent(name, {
        bubbles: true,
        cancelable: true,
        detail
    });
    if (handler) currentTarget.addEventListener(name, handler, {
        once: true
    });
    currentTarget.dispatchEvent(event);
}
(0, _web.delegateEvents)([
    "keydown",
    "pointerdown",
    "pointermove",
    "pointerup"
]);
/**
 * An accessible title to be announced when the toast is open.
 */ function ToastTitle(props) {
    const context = useToastContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("title")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerTitleId(local.id)));
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "div",
        get id () {
            return local.id;
        }
    }, others));
}
var index$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    CloseButton: ToastCloseButton,
    Description: ToastDescription,
    List: ToastList,
    ProgressFill: ToastProgressFill,
    ProgressTrack: ToastProgressTrack,
    Region: ToastRegion,
    Root: ToastRoot,
    Title: ToastTitle
});
/**
 * A two-state button that allow users to toggle a selection on or off.
 * This component is based on the [WAI-ARIA Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/button/)
 */ function ToggleButtonRoot(props) {
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "children",
        "pressed",
        "defaultPressed",
        "onChange",
        "onClick"
    ]);
    const state = createToggleState({
        isSelected: ()=>local.pressed,
        defaultIsSelected: ()=>local.defaultPressed,
        onSelectedChange: (selected)=>local.onChange?.(selected),
        isDisabled: ()=>others.disabled
    });
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        state.toggle();
    };
    return (0, _web.createComponent)(ButtonRoot, (0, _web.mergeProps)({
        get ["aria-pressed"] () {
            return state.isSelected();
        },
        get ["data-pressed"] () {
            return state.isSelected() ? "" : undefined;
        },
        onClick: onClick
    }, others, {
        get children () {
            return (0, _web.createComponent)(ToggleButtonRootChild, {
                get state () {
                    return {
                        pressed: state.isSelected
                    };
                },
                get children () {
                    return local.children;
                }
            });
        }
    }));
}
function ToggleButtonRootChild(props) {
    const resolvedChildren = (0, _solidJs.children)(()=>{
        const body = props.children;
        return (0, _utils.isFunction)(body) ? body(props.state) : body;
    });
    return (0, _web.memo)(resolvedChildren);
}
var index$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Root: ToggleButtonRoot
});
const TooltipContext = (0, _solidJs.createContext)();
function useTooltipContext() {
    const context = (0, _solidJs.useContext)(TooltipContext);
    if (context === undefined) throw new Error("[kobalte]: `useTooltipContext` must be used within a `Tooltip` component");
    return context;
}
/**
 * Contains the content to be rendered when the tooltip is open.
 */ function TooltipContent(props) {
    const context = useTooltipContext();
    props = (0, _utils.mergeDefaultProps)({
        id: context.generateId("content")
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "style"
    ]);
    (0, _solidJs.createEffect)(()=>(0, _solidJs.onCleanup)(context.registerContentId(others.id)));
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)(PopperPositioner, {
                get children () {
                    return (0, _web.createComponent)(DismissableLayer, (0, _web.mergeProps)({
                        ref (r$) {
                            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                                context.setContentRef(el);
                                context.contentPresence.setRef(el);
                            }, local.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        role: "tooltip",
                        disableOutsidePointerEvents: false,
                        get style () {
                            return {
                                "--kb-tooltip-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                                position: "relative",
                                ...local.style
                            };
                        },
                        onFocusOutside: (e)=>e.preventDefault(),
                        onDismiss: ()=>context.hideTooltip(true)
                    }, ()=>context.dataset(), others));
                }
            });
        }
    });
}
/**
 * Portals its children into the `body` when the tooltip is open.
 */ function TooltipPortal(props) {
    const context = useTooltipContext();
    return (0, _web.createComponent)((0, _solidJs.Show), {
        get when () {
            return context.contentPresence.isPresent();
        },
        get children () {
            return (0, _web.createComponent)((0, _web.Portal), props);
        }
    });
}
/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts
 * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts
 */ /**
 * Construct a polygon based on the floating element placement relative to the anchor.
 */ function getTooltipSafeArea(placement, anchorEl, floatingEl) {
    const basePlacement = placement.split("-")[0];
    const anchorRect = anchorEl.getBoundingClientRect();
    const floatingRect = floatingEl.getBoundingClientRect();
    const polygon = [];
    const anchorCenterX = anchorRect.left + anchorRect.width / 2;
    const anchorCenterY = anchorRect.top + anchorRect.height / 2;
    switch(basePlacement){
        case "top":
            polygon.push([
                anchorRect.left,
                anchorCenterY
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                anchorRect.right,
                anchorCenterY
            ]);
            break;
        case "right":
            polygon.push([
                anchorCenterX,
                anchorRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                anchorCenterX,
                anchorRect.bottom
            ]);
            break;
        case "bottom":
            polygon.push([
                anchorRect.left,
                anchorCenterY
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                anchorRect.right,
                anchorCenterY
            ]);
            break;
        case "left":
            polygon.push([
                anchorCenterX,
                anchorRect.top
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.top
            ]);
            polygon.push([
                floatingRect.left,
                floatingRect.bottom
            ]);
            polygon.push([
                floatingRect.right,
                floatingRect.bottom
            ]);
            polygon.push([
                anchorCenterX,
                anchorRect.bottom
            ]);
            break;
    }
    return polygon;
}
const tooltips = {};
let tooltipsCounter = 0;
let globalWarmedUp = false;
let globalWarmUpTimeout;
let globalCoolDownTimeout;
/**
 * A popup that displays information related to an element
 * when the element receives keyboard focus or the mouse hovers over it.
 */ function TooltipRoot(props) {
    const defaultId = `tooltip-${(0, _solidJs.createUniqueId)()}`;
    // This is not the DOM id.
    const tooltipId = `${++tooltipsCounter}`;
    props = (0, _utils.mergeDefaultProps)({
        id: defaultId,
        openDelay: 700,
        closeDelay: 300
    }, props);
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "id",
        "open",
        "defaultOpen",
        "onOpenChange",
        "disabled",
        "triggerOnFocusOnly",
        "openDelay",
        "closeDelay",
        "ignoreSafeArea",
        "forceMount"
    ]);
    let closeTimeoutId;
    const [contentId, setContentId] = (0, _solidJs.createSignal)();
    const [triggerRef, setTriggerRef] = (0, _solidJs.createSignal)();
    const [contentRef, setContentRef] = (0, _solidJs.createSignal)();
    const [currentPlacement, setCurrentPlacement] = (0, _solidJs.createSignal)(others.placement);
    const disclosureState = createDisclosureState({
        open: ()=>local.open,
        defaultOpen: ()=>local.defaultOpen,
        onOpenChange: (isOpen)=>local.onOpenChange?.(isOpen)
    });
    const contentPresence = createPresence(()=>local.forceMount || disclosureState.isOpen());
    const ensureTooltipEntry = ()=>{
        tooltips[tooltipId] = hideTooltip;
    };
    const closeOpenTooltips = ()=>{
        for(const hideTooltipId in tooltips)if (hideTooltipId !== tooltipId) {
            tooltips[hideTooltipId](true);
            delete tooltips[hideTooltipId];
        }
    };
    const hideTooltip = (immediate = false)=>{
        if (0, _web.isServer) return;
        if (immediate || local.closeDelay && local.closeDelay <= 0) {
            window.clearTimeout(closeTimeoutId);
            closeTimeoutId = undefined;
            disclosureState.close();
        } else if (!closeTimeoutId) closeTimeoutId = window.setTimeout(()=>{
            closeTimeoutId = undefined;
            disclosureState.close();
        }, local.closeDelay);
        window.clearTimeout(globalWarmUpTimeout);
        globalWarmUpTimeout = undefined;
        if (globalWarmedUp) {
            window.clearTimeout(globalCoolDownTimeout);
            globalCoolDownTimeout = window.setTimeout(()=>{
                delete tooltips[tooltipId];
                globalCoolDownTimeout = undefined;
                globalWarmedUp = false;
            }, local.closeDelay);
        }
    };
    const showTooltip = ()=>{
        if (0, _web.isServer) return;
        clearTimeout(closeTimeoutId);
        closeTimeoutId = undefined;
        closeOpenTooltips();
        ensureTooltipEntry();
        globalWarmedUp = true;
        disclosureState.open();
        window.clearTimeout(globalWarmUpTimeout);
        globalWarmUpTimeout = undefined;
        window.clearTimeout(globalCoolDownTimeout);
        globalCoolDownTimeout = undefined;
    };
    const warmupTooltip = ()=>{
        if (0, _web.isServer) return;
        closeOpenTooltips();
        ensureTooltipEntry();
        if (!disclosureState.isOpen() && !globalWarmUpTimeout && !globalWarmedUp) globalWarmUpTimeout = window.setTimeout(()=>{
            globalWarmUpTimeout = undefined;
            globalWarmedUp = true;
            showTooltip();
        }, local.openDelay);
        else if (!disclosureState.isOpen()) showTooltip();
    };
    const openTooltip = (immediate = false)=>{
        if (0, _web.isServer) return;
        if (!immediate && local.openDelay && local.openDelay > 0 && !closeTimeoutId) warmupTooltip();
        else showTooltip();
    };
    const cancelOpening = ()=>{
        if (0, _web.isServer) return;
        window.clearTimeout(globalWarmUpTimeout);
        globalWarmUpTimeout = undefined;
        globalWarmedUp = false;
    };
    const cancelClosing = ()=>{
        if (0, _web.isServer) return;
        window.clearTimeout(closeTimeoutId);
        closeTimeoutId = undefined;
    };
    const isTargetOnTooltip = (target)=>{
        return (0, _utils.contains)(triggerRef(), target) || (0, _utils.contains)(contentRef(), target);
    };
    const getPolygonSafeArea = (placement)=>{
        const triggerEl = triggerRef();
        const contentEl = contentRef();
        if (!triggerEl || !contentEl) return;
        return getTooltipSafeArea(placement, triggerEl, contentEl);
    };
    const onHoverOutside = (event)=>{
        const target = event.target;
        // Don't close if the mouse is moving through valid tooltip element.
        if (isTargetOnTooltip(target)) {
            cancelClosing();
            return;
        }
        if (!local.ignoreSafeArea) {
            const polygon = getPolygonSafeArea(currentPlacement());
            //Don't close if the current's event mouse position is inside the polygon safe area.
            if (polygon && (0, _utils.isPointInPolygon)((0, _utils.getEventPoint)(event), polygon)) {
                cancelClosing();
                return;
            }
        }
        // If there's already a scheduled timeout to hide the tooltip, we do nothing.
        if (closeTimeoutId) return;
        // Otherwise, hide the tooltip after the close delay.
        hideTooltip();
    };
    (0, _solidJs.createEffect)(()=>{
        if (0, _web.isServer) return;
        if (!disclosureState.isOpen()) return;
        const doc = (0, _utils.getDocument)();
        // Checks whether the mouse is moving outside the tooltip.
        // If yes, hide the tooltip after the close delay.
        doc.addEventListener("pointermove", onHoverOutside, true);
        (0, _solidJs.onCleanup)(()=>{
            doc.removeEventListener("pointermove", onHoverOutside, true);
        });
    });
    // Close the tooltip if the trigger is scrolled.
    (0, _solidJs.createEffect)(()=>{
        const trigger = triggerRef();
        if (!trigger || !disclosureState.isOpen()) return;
        const handleScroll = (event)=>{
            const target = event.target;
            if ((0, _utils.contains)(target, trigger)) hideTooltip(true);
        };
        const win = (0, _utils.getWindow)();
        win.addEventListener("scroll", handleScroll, {
            capture: true
        });
        (0, _solidJs.onCleanup)(()=>{
            win.removeEventListener("scroll", handleScroll, {
                capture: true
            });
        });
    });
    (0, _solidJs.onCleanup)(()=>{
        clearTimeout(closeTimeoutId);
        const tooltip = tooltips[tooltipId];
        if (tooltip) delete tooltips[tooltipId];
    });
    const dataset = (0, _solidJs.createMemo)(()=>({
            "data-expanded": disclosureState.isOpen() ? "" : undefined,
            "data-closed": !disclosureState.isOpen() ? "" : undefined
        }));
    const context = {
        dataset,
        isOpen: disclosureState.isOpen,
        isDisabled: ()=>local.disabled ?? false,
        triggerOnFocusOnly: ()=>local.triggerOnFocusOnly ?? false,
        contentId,
        contentPresence,
        openTooltip,
        hideTooltip,
        cancelOpening,
        generateId: (0, _utils.createGenerateId)(()=>props.id),
        registerContentId: createRegisterId(setContentId),
        isTargetOnTooltip,
        setTriggerRef,
        setContentRef
    };
    return (0, _web.createComponent)(TooltipContext.Provider, {
        value: context,
        get children () {
            return (0, _web.createComponent)(PopperRoot, (0, _web.mergeProps)({
                anchorRef: triggerRef,
                contentRef: contentRef,
                onCurrentPlacementChange: setCurrentPlacement
            }, others));
        }
    });
}
/**
 * The button that opens the tooltip when hovered.
 */ function TooltipTrigger(props) {
    let ref;
    const context = useTooltipContext();
    const [local, others] = (0, _solidJs.splitProps)(props, [
        "ref",
        "onPointerEnter",
        "onPointerLeave",
        "onPointerDown",
        "onClick",
        "onFocus",
        "onBlur",
        "onTouchStart"
    ]);
    let isPointerDown = false;
    let isHovered = false;
    let isFocused = false;
    const handlePointerUp = ()=>{
        isPointerDown = false;
    };
    const handleShow = ()=>{
        if (!context.isOpen() && (isHovered || isFocused)) context.openTooltip(isFocused);
    };
    const handleHide = (immediate)=>{
        if (context.isOpen() && !isHovered && !isFocused) context.hideTooltip(immediate);
    };
    const onPointerEnter = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerEnter);
        if (e.pointerType === "touch" || context.triggerOnFocusOnly() || context.isDisabled() || e.defaultPrevented) return;
        isHovered = true;
        handleShow();
    };
    const onPointerLeave = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerLeave);
        if (e.pointerType === "touch") return;
        // No matter how the trigger is left, we should close the tooltip.
        isHovered = false;
        isFocused = false;
        if (context.isOpen()) handleHide();
        else context.cancelOpening();
    };
    const onPointerDown = (e)=>{
        (0, _utils.callHandler)(e, local.onPointerDown);
        isPointerDown = true;
        (0, _utils.getDocument)(ref).addEventListener("pointerup", handlePointerUp, {
            once: true
        });
    };
    const onClick = (e)=>{
        (0, _utils.callHandler)(e, local.onClick);
        // No matter how the trigger is left, we should close the tooltip.
        isHovered = false;
        isFocused = false;
        handleHide(true);
    };
    const onFocus = (e)=>{
        (0, _utils.callHandler)(e, local.onFocus);
        if (context.isDisabled() || e.defaultPrevented || isPointerDown) return;
        isFocused = true;
        handleShow();
    };
    const onBlur = (e)=>{
        (0, _utils.callHandler)(e, local.onBlur);
        const relatedTarget = e.relatedTarget;
        if (context.isTargetOnTooltip(relatedTarget)) return;
        // No matter how the trigger is left, we should close the tooltip.
        isHovered = false;
        isFocused = false;
        handleHide(true);
    };
    (0, _solidJs.onCleanup)(()=>{
        if (0, _web.isServer) return;
        (0, _utils.getDocument)(ref).removeEventListener("pointerup", handlePointerUp);
    });
    // We purposefully avoid using Kobalte `Button` here because tooltip triggers can be any element
    // and should not always be announced as a button to screen readers.
    return (0, _web.createComponent)(Polymorphic, (0, _web.mergeProps)({
        as: "button",
        ref (r$) {
            const _ref$ = (0, _utils.mergeRefs)((el)=>{
                context.setTriggerRef(el);
                ref = el;
            }, local.ref);
            typeof _ref$ === "function" && _ref$(r$);
        },
        get ["aria-describedby"] () {
            return (0, _web.memo)(()=>!!context.isOpen())() ? context.contentId() : undefined;
        },
        onPointerEnter: onPointerEnter,
        onPointerLeave: onPointerLeave,
        onPointerDown: onPointerDown,
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur
    }, ()=>context.dataset(), others));
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Arrow: PopperArrow,
    Content: TooltipContent,
    Portal: TooltipPortal,
    Root: TooltipRoot,
    Trigger: TooltipTrigger
});

},{"@kobalte/utils":"fM4gX","solid-js/store":"iDjqj","solid-js/web":"eGRlU","solid-js":"f1z31","@internationalized/date":"bh5Gu","@floating-ui/dom":"3m4w3","@internationalized/number":"jVksD","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fM4gX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createEventListener", ()=>(0, _eventListener.createEventListener));
parcelHelpers.export(exports, "Key", ()=>(0, _keyed.Key));
parcelHelpers.export(exports, "ReactiveMap", ()=>(0, _map.ReactiveMap));
parcelHelpers.export(exports, "createMediaQuery", ()=>(0, _media.createMediaQuery));
parcelHelpers.export(exports, "combineProps", ()=>(0, _props.combineProps));
parcelHelpers.export(exports, "mergeRefs", ()=>(0, _refs.mergeRefs));
parcelHelpers.export(exports, "access", ()=>(0, _utils.access));
parcelHelpers.export(exports, "accessWith", ()=>(0, _utils.accessWith));
parcelHelpers.export(exports, "chain", ()=>(0, _utils.chain));
/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit-utils/src/array.ts
 */ /*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/utils/src/assertion.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/solidjs-community/solid-aria/blob/2c5f54feb5cfea514b1ee0a52d0416878f882351/packages/utils/src/createGlobalListeners.ts
 */ /*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/232bc79018ec20967fec1e097a9474aba3bb5be7/packages/ariakit-utils/src/dom.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/cf9ab24f3255be1530d0f584061a01aa1e8180e6/packages/@react-aria/utils/src/platform.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/focusWithoutScrolling.ts
 */ /*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/main/packages/ariakit-utils/src/focus.ts
 *
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/focus/src/isElementVisible.ts
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/focus/src/FocusScope.tsx
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/f6e686fe9d3b983d48650980c1ecfdde320bc62f/packages/@react-aria/focus/src/FocusScope.tsx
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/getScrollParent.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/isVirtualEvent.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/ff3e690fffc6c54367b8057e28a0e5b9211f37b5/packages/@react-stately/utils/src/number.ts
 */ /*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts
 * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/utils/src/runAfterTransition.ts
 */ /*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/utils/src/scrollIntoView.ts
 */ parcelHelpers.export(exports, "EventKey", ()=>EventKey) //# sourceMappingURL=out.js.map
;
parcelHelpers.export(exports, "FOCUSABLE_ELEMENT_SELECTOR", ()=>FOCUSABLE_ELEMENT_SELECTOR);
parcelHelpers.export(exports, "TABBABLE_ELEMENT_SELECTOR", ()=>TABBABLE_ELEMENT_SELECTOR);
parcelHelpers.export(exports, "addItemToArray", ()=>addItemToArray);
parcelHelpers.export(exports, "callHandler", ()=>callHandler);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "composeEventHandlers", ()=>composeEventHandlers);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "createFocusManager", ()=>createFocusManager);
parcelHelpers.export(exports, "createGenerateId", ()=>createGenerateId);
parcelHelpers.export(exports, "createGlobalListeners", ()=>createGlobalListeners);
parcelHelpers.export(exports, "debugPolygon", ()=>debugPolygon);
parcelHelpers.export(exports, "focusWithoutScrolling", ()=>focusWithoutScrolling);
parcelHelpers.export(exports, "getActiveElement", ()=>getActiveElement);
parcelHelpers.export(exports, "getAllTabbableIn", ()=>getAllTabbableIn);
parcelHelpers.export(exports, "getDocument", ()=>getDocument);
parcelHelpers.export(exports, "getEventPoint", ()=>getEventPoint);
parcelHelpers.export(exports, "getFocusableTreeWalker", ()=>getFocusableTreeWalker);
parcelHelpers.export(exports, "getScrollParent", ()=>getScrollParent);
parcelHelpers.export(exports, "getWindow", ()=>getWindow);
parcelHelpers.export(exports, "hasFocusWithin", ()=>hasFocusWithin);
parcelHelpers.export(exports, "isAndroid", ()=>isAndroid);
parcelHelpers.export(exports, "isAppleDevice", ()=>isAppleDevice);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isChrome", ()=>isChrome);
parcelHelpers.export(exports, "isCtrlKey", ()=>isCtrlKey);
parcelHelpers.export(exports, "isElementVisible", ()=>isElementVisible);
parcelHelpers.export(exports, "isFocusable", ()=>isFocusable);
parcelHelpers.export(exports, "isFrame", ()=>isFrame);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isIOS", ()=>isIOS);
parcelHelpers.export(exports, "isIPad", ()=>isIPad);
parcelHelpers.export(exports, "isIPhone", ()=>isIPhone);
parcelHelpers.export(exports, "isMac", ()=>isMac);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "isPointInPolygon", ()=>isPointInPolygon);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isTabbable", ()=>isTabbable);
parcelHelpers.export(exports, "isVirtualClick", ()=>isVirtualClick);
parcelHelpers.export(exports, "isVirtualPointerEvent", ()=>isVirtualPointerEvent);
parcelHelpers.export(exports, "isWebKit", ()=>isWebKit);
parcelHelpers.export(exports, "mergeDefaultProps", ()=>mergeDefaultProps);
parcelHelpers.export(exports, "noop", ()=>noop);
parcelHelpers.export(exports, "removeItemFromArray", ()=>removeItemFromArray);
parcelHelpers.export(exports, "runAfterTransition", ()=>runAfterTransition);
parcelHelpers.export(exports, "scrollIntoView", ()=>scrollIntoView);
parcelHelpers.export(exports, "scrollIntoViewport", ()=>scrollIntoViewport);
parcelHelpers.export(exports, "snapValueToStep", ()=>snapValueToStep);
parcelHelpers.export(exports, "visuallyHiddenStyles", ()=>visuallyHiddenStyles);
var _solidJs = require("solid-js");
var _eventListener = require("@solid-primitives/event-listener");
var _keyed = require("@solid-primitives/keyed");
var _map = require("@solid-primitives/map");
var _media = require("@solid-primitives/media");
var _props = require("@solid-primitives/props");
var _refs = require("@solid-primitives/refs");
var _utils = require("@solid-primitives/utils");
// src/array.ts
function addItemToArray(array, item, index = -1) {
    if (!(index in array)) return [
        ...array,
        item
    ];
    return [
        ...array.slice(0, index),
        item,
        ...array.slice(index)
    ];
}
function removeItemFromArray(array, item) {
    const updatedArray = [
        ...array
    ];
    const index = updatedArray.indexOf(item);
    if (index !== -1) updatedArray.splice(index, 1);
    return updatedArray;
}
// src/assertion.ts
function isNumber(value) {
    return typeof value === "number";
}
function isArray(value) {
    return Array.isArray(value);
}
function isString(value) {
    return Object.prototype.toString.call(value) === "[object String]";
}
function isFunction(value) {
    return typeof value === "function";
}
// src/create-generate-id.ts
function createGenerateId(baseId) {
    return (suffix)=>`${baseId()}-${suffix}`;
}
function createGlobalListeners() {
    const globalListeners = /* @__PURE__ */ new Map();
    const addGlobalListener = (eventTarget, type, listener, options)=>{
        const fn = options?.once ? (...args)=>{
            globalListeners.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.set(listener, {
            type,
            eventTarget,
            fn,
            options
        });
        eventTarget.addEventListener(type, listener, options);
    };
    const removeGlobalListener = (eventTarget, type, listener, options)=>{
        const fn = globalListeners.get(listener)?.fn || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.delete(listener);
    };
    const removeAllGlobalListeners = ()=>{
        globalListeners.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    };
    (0, _solidJs.onCleanup)(()=>{
        removeAllGlobalListeners();
    });
    return {
        addGlobalListener,
        removeGlobalListener,
        removeAllGlobalListeners
    };
}
// src/dom.ts
function contains(parent, child) {
    if (!parent) return false;
    return parent === child || parent.contains(child);
}
function getActiveElement(node, activeDescendant = false) {
    const { activeElement  } = getDocument(node);
    if (!activeElement?.nodeName) return null;
    if (isFrame(activeElement) && activeElement.contentDocument) return getActiveElement(activeElement.contentDocument.body, activeDescendant);
    if (activeDescendant) {
        const id = activeElement.getAttribute("aria-activedescendant");
        if (id) {
            const element = getDocument(activeElement).getElementById(id);
            if (element) return element;
        }
    }
    return activeElement;
}
function getWindow(node) {
    return getDocument(node).defaultView || window;
}
function getDocument(node) {
    return node ? node.ownerDocument || node : document;
}
function isFrame(element) {
    return element.tagName === "IFRAME";
}
// src/enums.ts
var EventKey = /* @__PURE__ */ ((EventKey2)=>{
    EventKey2["Escape"] = "Escape";
    EventKey2["Enter"] = "Enter";
    EventKey2["Tab"] = "Tab";
    EventKey2["Space"] = " ";
    EventKey2["ArrowDown"] = "ArrowDown";
    EventKey2["ArrowLeft"] = "ArrowLeft";
    EventKey2["ArrowRight"] = "ArrowRight";
    EventKey2["ArrowUp"] = "ArrowUp";
    EventKey2["End"] = "End";
    EventKey2["Home"] = "Home";
    EventKey2["PageDown"] = "PageDown";
    EventKey2["PageUp"] = "PageUp";
    return EventKey2;
})(EventKey || {});
// src/platform.ts
function testUserAgent(re) {
    if (typeof window === "undefined" || window.navigator == null) return false;
    return(// @ts-ignore
    window.navigator["userAgentData"]?.brands.some((brand)=>re.test(brand.brand)) || re.test(window.navigator.userAgent));
}
function testPlatform(re) {
    return typeof window !== "undefined" && window.navigator != null ? // @ts-ignore
    re.test(window.navigator["userAgentData"]?.platform || window.navigator.platform) : false;
}
function isMac() {
    return testPlatform(/^Mac/i);
}
function isIPhone() {
    return testPlatform(/^iPhone/i);
}
function isIPad() {
    return testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
    return isIPhone() || isIPad();
}
function isAppleDevice() {
    return isMac() || isIOS();
}
function isWebKit() {
    return testUserAgent(/AppleWebKit/i) && !isChrome();
}
function isChrome() {
    return testUserAgent(/Chrome/i);
}
function isAndroid() {
    return testUserAgent(/Android/i);
}
// src/events.ts
function callHandler(event, handler) {
    if (handler) {
        if (isFunction(handler)) handler(event);
        else handler[0](handler[1], event);
    }
    return event?.defaultPrevented;
}
function composeEventHandlers(handlers) {
    return (event)=>{
        for (const handler of handlers)callHandler(event, handler);
    };
}
function isCtrlKey(e) {
    if (isMac()) return e.metaKey && !e.ctrlKey;
    return e.ctrlKey && !e.metaKey;
}
// src/focus-without-scrolling.ts
function focusWithoutScrolling(element) {
    if (!element) return;
    if (supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        const scrollableElements = getScrollableElements(element);
        element.focus();
        restoreScrollPosition(scrollableElements);
    }
}
var supportsPreventScrollCached = null;
function supportsPreventScroll() {
    if (supportsPreventScrollCached == null) {
        supportsPreventScrollCached = false;
        try {
            const focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {}
    }
    return supportsPreventScrollCached;
}
function getScrollableElements(element) {
    let parent = element.parentNode;
    const scrollableElements = [];
    const rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function restoreScrollPosition(scrollableElements) {
    for (const { element , scrollTop , scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}
// src/tabbable.ts
var focusableElements = [
    "input:not([type='hidden']):not([disabled])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "[tabindex]",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]:not([contenteditable='false'])"
];
var tabbableElements = [
    ...focusableElements,
    '[tabindex]:not([tabindex="-1"]):not([disabled])'
];
var FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
var TABBABLE_ELEMENT_SELECTOR = tabbableElements.join(':not([hidden]):not([tabindex="-1"]),');
function getAllTabbableIn(container, includeContainer) {
    const elements = Array.from(container.querySelectorAll(FOCUSABLE_ELEMENT_SELECTOR));
    const tabbableElements2 = elements.filter(isTabbable);
    if (includeContainer && isTabbable(container)) tabbableElements2.unshift(container);
    tabbableElements2.forEach((element, i)=>{
        if (isFrame(element) && element.contentDocument) {
            const frameBody = element.contentDocument.body;
            const allFrameTabbable = getAllTabbableIn(frameBody, false);
            tabbableElements2.splice(i, 1, ...allFrameTabbable);
        }
    });
    return tabbableElements2;
}
function isTabbable(element) {
    return isFocusable(element) && !hasNegativeTabIndex(element);
}
function isFocusable(element) {
    return element.matches(FOCUSABLE_ELEMENT_SELECTOR) && isElementVisible(element);
}
function hasNegativeTabIndex(element) {
    const tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
    return tabIndex < 0;
}
function isElementVisible(element, childElement) {
    return element.nodeName !== "#comment" && isStyleVisible(element) && isAttributeVisible(element, childElement) && (!element.parentElement || isElementVisible(element.parentElement, element));
}
function isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    const { display , visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        if (!element.ownerDocument.defaultView) return isVisible;
        const { getComputedStyle  } = element.ownerDocument.defaultView;
        const { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function hasFocusWithin(element) {
    const activeElement = getActiveElement(element);
    if (!activeElement) return false;
    if (!contains(element, activeElement)) {
        const activeDescendant = activeElement.getAttribute("aria-activedescendant");
        if (!activeDescendant) return false;
        if (!("id" in element)) return false;
        if (activeDescendant === element.id) return true;
        return !!element.querySelector(`#${CSS.escape(activeDescendant)}`);
    } else return true;
}
// src/focus-manager.ts
function createFocusManager(ref, defaultOptions = ()=>({})) {
    const focusNext = (opts = {})=>{
        const root = ref();
        if (!root) return;
        const { from =defaultOptions().from || document.activeElement , tabbable =defaultOptions().tabbable , wrap =defaultOptions().wrap , accept =defaultOptions().accept  } = opts;
        const walker = getFocusableTreeWalker(root, {
            tabbable,
            accept
        });
        if (from && root.contains(from)) walker.currentNode = from;
        let nextNode = walker.nextNode();
        if (!nextNode && wrap) {
            walker.currentNode = root;
            nextNode = walker.nextNode();
        }
        if (nextNode) focusElement(nextNode, true);
        return nextNode;
    };
    const focusPrevious = (opts = {})=>{
        const root = ref();
        if (!root) return;
        const { from =defaultOptions().from || document.activeElement , tabbable =defaultOptions().tabbable , wrap =defaultOptions().wrap , accept =defaultOptions().accept  } = opts;
        const walker = getFocusableTreeWalker(root, {
            tabbable,
            accept
        });
        if (from && root.contains(from)) walker.currentNode = from;
        else {
            const next = last(walker);
            if (next) focusElement(next, true);
            return next;
        }
        let previousNode = walker.previousNode();
        if (!previousNode && wrap) {
            walker.currentNode = root;
            previousNode = last(walker);
        }
        if (previousNode) focusElement(previousNode, true);
        return previousNode;
    };
    const focusFirst = (opts = {})=>{
        const root = ref();
        if (!root) return;
        const { tabbable =defaultOptions().tabbable , accept =defaultOptions().accept  } = opts;
        const walker = getFocusableTreeWalker(root, {
            tabbable,
            accept
        });
        const nextNode = walker.nextNode();
        if (nextNode) focusElement(nextNode, true);
        return nextNode;
    };
    const focusLast = (opts = {})=>{
        const root = ref();
        if (!root) return;
        const { tabbable =defaultOptions().tabbable , accept =defaultOptions().accept  } = opts;
        const walker = getFocusableTreeWalker(root, {
            tabbable,
            accept
        });
        const next = last(walker);
        if (next) focusElement(next, true);
        return next;
    };
    return {
        focusNext,
        focusPrevious,
        focusFirst,
        focusLast
    };
}
function focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        focusWithoutScrolling(element);
    } catch (err) {}
    else if (element != null) try {
        element.focus();
    } catch (err1) {}
}
function last(walker) {
    let next;
    let last2;
    do {
        last2 = walker.lastChild();
        if (last2) next = last2;
    }while (last2);
    return next;
}
function isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function getFocusableTreeWalker(root, opts, scope) {
    const selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            if (opts?.from?.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && isElementVisible(node) && (!scope || isElementInScope(node, scope)) && (!opts?.accept || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts?.from) walker.currentNode = opts.from;
    return walker;
}
// src/get-scroll-parent.ts
function getScrollParent(node) {
    while(node && !isScrollable(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function isScrollable(node) {
    const style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}
// src/is-virtual-event.ts
function isVirtualClick(event) {
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    if (isAndroid() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}
// src/noop.ts
function noop() {
    return;
}
// src/number.ts
function clamp(value, min = -Infinity, max = Infinity) {
    return Math.min(Math.max(value, min), max);
}
function snapValueToStep(value, min, max, step) {
    const remainder = (value - (isNaN(min) ? 0 : min)) % step;
    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;
    if (!isNaN(min)) {
        if (snappedValue < min) snappedValue = min;
        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;
    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;
    const string = step.toString();
    const index = string.indexOf(".");
    const precision = index >= 0 ? string.length - index : 0;
    if (precision > 0) {
        const pow = Math.pow(10, precision);
        snappedValue = Math.round(snappedValue * pow) / pow;
    }
    return snappedValue;
}
// src/polygon.ts
function getEventPoint(event) {
    return [
        event.clientX,
        event.clientY
    ];
}
function isPointInPolygon(point, polygon) {
    const [x, y] = point;
    let inside = false;
    const length = polygon.length;
    for(let l = length, i = 0, j = l - 1; i < l; j = i++){
        const [xi, yi] = polygon[i];
        const [xj, yj] = polygon[j];
        const [, vy] = polygon[j === 0 ? l - 1 : j - 1] || [
            0,
            0
        ];
        const where = (yi - yj) * (x - xi) - (xi - xj) * (y - yi);
        if (yj < yi) {
            if (y >= yj && y < yi) {
                if (where === 0) return true;
                if (where > 0) {
                    if (y === yj) {
                        if (y > vy) inside = !inside;
                    } else inside = !inside;
                }
            }
        } else if (yi < yj) {
            if (y > yi && y <= yj) {
                if (where === 0) return true;
                if (where < 0) {
                    if (y === yj) {
                        if (y < vy) inside = !inside;
                    } else inside = !inside;
                }
            }
        } else if (y == yi && (x >= xj && x <= xi || x >= xi && x <= xj)) return true;
    }
    return inside;
}
function getPolygon() {
    const id = "debug-polygon";
    const existingPolygon = document.getElementById(id);
    if (existingPolygon) return existingPolygon;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.fill = "green";
    svg.style.opacity = "0.2";
    svg.style.position = "fixed";
    svg.style.pointerEvents = "none";
    svg.style.zIndex = "999999";
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    polygon.setAttribute("id", id);
    polygon.setAttribute("points", "0,0 0,0");
    svg.appendChild(polygon);
    document.body.appendChild(svg);
    return polygon;
}
function debugPolygon(polygon) {
    const polygonElement = getPolygon();
    const points = polygon.map((point)=>point.join(",")).join(" ");
    polygonElement.setAttribute("points", points);
    return polygonElement.parentElement;
}
function mergeDefaultProps(defaultProps, props) {
    return (0, _solidJs.mergeProps)(defaultProps, props);
}
// src/run-after-transition.ts
var transitionsByElement = /* @__PURE__ */ new Map();
var transitionCallbacks = /* @__PURE__ */ new Set();
function setupGlobalEvents() {
    if (typeof window === "undefined") return;
    const onTransitionStart = (e)=>{
        if (!e.target) return;
        let transitions = transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = /* @__PURE__ */ new Set();
            transitionsByElement.set(e.target, transitions);
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    const onTransitionEnd = (e)=>{
        if (!e.target) return;
        const properties = transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            transitionsByElement.delete(e.target);
        }
        if (transitionsByElement.size === 0) {
            for (const cb of transitionCallbacks)cb();
            transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", setupGlobalEvents);
}
function runAfterTransition(fn) {
    requestAnimationFrame(()=>{
        if (transitionsByElement.size === 0) fn();
        else transitionCallbacks.add(fn);
    });
}
// src/scroll-into-view.ts
function scrollIntoView(scrollView, element) {
    const offsetX = relativeOffset(scrollView, element, "left");
    const offsetY = relativeOffset(scrollView, element, "top");
    const width = element.offsetWidth;
    const height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    const maxX = x + scrollView.offsetWidth;
    const maxY = y + scrollView.offsetHeight;
    if (offsetX <= x) x = offsetX;
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= y) y = offsetY;
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
function relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function scrollIntoViewport(targetElement, opts) {
    if (document.contains(targetElement)) {
        const root = document.scrollingElement || document.documentElement;
        const isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        if (!isScrollPrevented) {
            const { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement?.scrollIntoView?.({
                block: "nearest"
            });
            const { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                opts?.containingElement?.scrollIntoView?.({
                    block: "center",
                    inline: "center"
                });
                targetElement.scrollIntoView?.({
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = getScrollParent(targetElement);
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                scrollIntoView(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = getScrollParent(targetElement);
            }
        }
    }
}
// src/styles.ts
var visuallyHiddenStyles = {
    border: "0",
    clip: "rect(0 0 0 0)",
    "clip-path": "inset(50%)",
    height: "1px",
    margin: "0 -1px -1px 0",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px",
    "white-space": "nowrap"
};

},{"solid-js":"f1z31","@solid-primitives/event-listener":"1poSB","@solid-primitives/keyed":"60fDH","@solid-primitives/map":false,"@solid-primitives/media":"70FAY","@solid-primitives/props":"dPUSw","@solid-primitives/refs":"hO6Py","@solid-primitives/utils":"6V0Tj","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1poSB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DocumentEventListener", ()=>DocumentEventListener);
parcelHelpers.export(exports, "WindowEventListener", ()=>WindowEventListener);
parcelHelpers.export(exports, "createEventListener", ()=>createEventListener);
parcelHelpers.export(exports, "createEventListenerMap", ()=>createEventListenerMap);
parcelHelpers.export(exports, "createEventSignal", ()=>createEventSignal);
parcelHelpers.export(exports, "eventListener", ()=>eventListener);
parcelHelpers.export(exports, "makeEventListener", ()=>makeEventListener);
parcelHelpers.export(exports, "makeEventListenerStack", ()=>makeEventListenerStack);
parcelHelpers.export(exports, "preventDefault", ()=>preventDefault);
parcelHelpers.export(exports, "stopImmediatePropagation", ()=>stopImmediatePropagation);
parcelHelpers.export(exports, "stopPropagation", ()=>stopPropagation);
var _utils = require("@solid-primitives/utils");
var _solidJs = require("solid-js");
var _web = require("solid-js/web");
// src/eventListener.ts
function makeEventListener(target, type, handler, options) {
    target.addEventListener(type, handler, options);
    return (0, _utils.tryOnCleanup)(target.removeEventListener.bind(target, type, handler, options));
}
function createEventListener(targets, type, handler, options) {
    if (0, _web.isServer) return;
    const attachListeners = ()=>{
        (0, _utils.asArray)((0, _utils.access)(targets)).forEach((el)=>{
            if (el) (0, _utils.asArray)((0, _utils.access)(type)).forEach((type2)=>makeEventListener(el, type2, handler, options));
        });
    };
    if (typeof targets === "function") (0, _solidJs.createEffect)(attachListeners);
    else (0, _solidJs.createRenderEffect)(attachListeners);
}
function createEventSignal(target, type, options) {
    if (0, _web.isServer) return ()=>void 0;
    const [lastEvent, setLastEvent] = (0, _solidJs.createSignal)();
    createEventListener(target, type, setLastEvent, options);
    return lastEvent;
}
var eventListener = (target, props)=>{
    (0, _solidJs.createEffect)(()=>{
        const [type, handler, options] = props();
        makeEventListener(target, type, handler, options);
    });
};
function createEventListenerMap(targets, handlersMap, options) {
    if (0, _web.isServer) return;
    for (const [eventName, handler] of (0, _utils.entries)(handlersMap))if (handler) createEventListener(targets, eventName, handler, options);
}
var attachPropListeners = (target, props)=>{
    (0, _utils.keys)(props).forEach((attr)=>{
        if (attr.startsWith("on") && typeof props[attr] === "function") makeEventListener(target, attr.substring(2).toLowerCase(), props[attr]);
    });
};
var WindowEventListener = (props)=>{
    if (0, _web.isServer) return null;
    attachPropListeners(window, props);
};
var DocumentEventListener = (props)=>{
    if (0, _web.isServer) return null;
    attachPropListeners(document, props);
};
function makeEventListenerStack(target, options) {
    if (0, _web.isServer) return [
        ()=>()=>void 0,
        ()=>void 0
    ];
    const { push , execute  } = (0, _utils.createCallbackStack)();
    return [
        (type, handler, overwriteOptions)=>{
            const clear = makeEventListener(target, type, handler, overwriteOptions ?? options);
            push(clear);
            return clear;
        },
        (0, _solidJs.onCleanup)(execute)
    ];
}
// src/callbackWrappers.ts
var preventDefault = (callback)=>(e)=>{
        e.preventDefault();
        callback(e);
    };
var stopPropagation = (callback)=>(e)=>{
        e.stopPropagation();
        callback(e);
    };
var stopImmediatePropagation = (callback)=>(e)=>{
        e.stopImmediatePropagation();
        callback(e);
    };

},{"@solid-primitives/utils":"6V0Tj","solid-js":"f1z31","solid-js/web":"eGRlU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6V0Tj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EQUALS_FALSE_OPTIONS", ()=>(0, _r5675YmuJs.EQUALS_FALSE_OPTIONS));
parcelHelpers.export(exports, "INTERNAL_OPTIONS", ()=>(0, _r5675YmuJs.INTERNAL_OPTIONS));
parcelHelpers.export(exports, "access", ()=>(0, _r5675YmuJs.access));
parcelHelpers.export(exports, "accessArray", ()=>(0, _r5675YmuJs.accessArray));
parcelHelpers.export(exports, "accessWith", ()=>(0, _r5675YmuJs.accessWith));
parcelHelpers.export(exports, "arrayEquals", ()=>(0, _r5675YmuJs.arrayEquals));
parcelHelpers.export(exports, "asAccessor", ()=>(0, _r5675YmuJs.asAccessor));
parcelHelpers.export(exports, "asArray", ()=>(0, _r5675YmuJs.asArray));
parcelHelpers.export(exports, "chain", ()=>(0, _r5675YmuJs.chain));
parcelHelpers.export(exports, "clamp", ()=>(0, _r5675YmuJs.clamp));
parcelHelpers.export(exports, "compare", ()=>(0, _r5675YmuJs.compare));
parcelHelpers.export(exports, "createCallbackStack", ()=>(0, _r5675YmuJs.createCallbackStack));
parcelHelpers.export(exports, "createHydratableSignal", ()=>(0, _r5675YmuJs.createHydratableSignal));
parcelHelpers.export(exports, "createHydrateSignal", ()=>(0, _r5675YmuJs.createHydrateSignal));
parcelHelpers.export(exports, "createMicrotask", ()=>(0, _r5675YmuJs.createMicrotask));
parcelHelpers.export(exports, "defaultEquals", ()=>(0, _r5675YmuJs.defaultEquals));
parcelHelpers.export(exports, "defer", ()=>(0, _r5675YmuJs.defer));
parcelHelpers.export(exports, "entries", ()=>(0, _r5675YmuJs.entries));
parcelHelpers.export(exports, "falseFn", ()=>(0, _r5675YmuJs.falseFn));
parcelHelpers.export(exports, "filterNonNullable", ()=>(0, _r5675YmuJs.filterNonNullable));
parcelHelpers.export(exports, "handleDiffArray", ()=>(0, _r5675YmuJs.handleDiffArray));
parcelHelpers.export(exports, "isClient", ()=>(0, _r5675YmuJs.isClient));
parcelHelpers.export(exports, "isDev", ()=>(0, _r5675YmuJs.isDev));
parcelHelpers.export(exports, "isNonNullable", ()=>(0, _r5675YmuJs.isNonNullable));
parcelHelpers.export(exports, "isObject", ()=>(0, _r5675YmuJs.isObject));
parcelHelpers.export(exports, "isProd", ()=>(0, _r5675YmuJs.isProd));
parcelHelpers.export(exports, "isServer", ()=>(0, _r5675YmuJs.isServer));
parcelHelpers.export(exports, "keys", ()=>(0, _r5675YmuJs.keys));
parcelHelpers.export(exports, "noop", ()=>(0, _r5675YmuJs.noop));
parcelHelpers.export(exports, "ofClass", ()=>(0, _r5675YmuJs.ofClass));
parcelHelpers.export(exports, "reverseChain", ()=>(0, _r5675YmuJs.reverseChain));
parcelHelpers.export(exports, "trueFn", ()=>(0, _r5675YmuJs.trueFn));
parcelHelpers.export(exports, "tryOnCleanup", ()=>(0, _r5675YmuJs.tryOnCleanup));
parcelHelpers.export(exports, "withAccess", ()=>(0, _r5675YmuJs.withAccess));
var _r5675YmuJs = require("../chunk/R5675YMU.js");

},{"../chunk/R5675YMU.js":"47KzN","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"47KzN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isServer", ()=>(0, _web.isServer));
parcelHelpers.export(exports, "EQUALS_FALSE_OPTIONS", ()=>EQUALS_FALSE_OPTIONS);
parcelHelpers.export(exports, "INTERNAL_OPTIONS", ()=>INTERNAL_OPTIONS);
parcelHelpers.export(exports, "access", ()=>access);
parcelHelpers.export(exports, "accessArray", ()=>accessArray);
parcelHelpers.export(exports, "accessWith", ()=>accessWith);
parcelHelpers.export(exports, "arrayEquals", ()=>arrayEquals);
parcelHelpers.export(exports, "asAccessor", ()=>asAccessor);
parcelHelpers.export(exports, "asArray", ()=>asArray);
parcelHelpers.export(exports, "chain", ()=>chain);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "compare", ()=>compare);
parcelHelpers.export(exports, "createCallbackStack", ()=>createCallbackStack);
parcelHelpers.export(exports, "createHydratableSignal", ()=>createHydratableSignal);
parcelHelpers.export(exports, "createHydrateSignal", ()=>createHydrateSignal);
parcelHelpers.export(exports, "createMicrotask", ()=>createMicrotask);
parcelHelpers.export(exports, "defaultEquals", ()=>defaultEquals);
parcelHelpers.export(exports, "defer", ()=>defer);
parcelHelpers.export(exports, "entries", ()=>entries);
parcelHelpers.export(exports, "falseFn", ()=>falseFn);
parcelHelpers.export(exports, "filterNonNullable", ()=>filterNonNullable);
parcelHelpers.export(exports, "handleDiffArray", ()=>handleDiffArray);
parcelHelpers.export(exports, "isClient", ()=>isClient);
parcelHelpers.export(exports, "isDev", ()=>isDev);
parcelHelpers.export(exports, "isNonNullable", ()=>isNonNullable);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isProd", ()=>isProd);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "noop", ()=>noop);
parcelHelpers.export(exports, "ofClass", ()=>ofClass);
parcelHelpers.export(exports, "reverseChain", ()=>reverseChain);
parcelHelpers.export(exports, "trueFn", ()=>trueFn);
parcelHelpers.export(exports, "tryOnCleanup", ()=>tryOnCleanup);
parcelHelpers.export(exports, "withAccess", ()=>withAccess);
var _solidJs = require("solid-js");
var _web = require("solid-js/web");
// src/index.ts
var isClient = !(0, _web.isServer);
var isDev = isClient && !!(0, _solidJs.DEV);
var isProd = !isDev;
var noop = ()=>void 0;
var trueFn = ()=>true;
var falseFn = ()=>false;
var defaultEquals = (0, _solidJs.equalFn);
var EQUALS_FALSE_OPTIONS = {
    equals: false
};
var INTERNAL_OPTIONS = {
    internal: true
};
var ofClass = (v, c)=>v instanceof c || v && v.constructor === c;
function isObject(value) {
    return value !== null && (typeof value === "object" || typeof value === "function");
}
var isNonNullable = (i)=>i != null;
var filterNonNullable = (arr)=>arr.filter(isNonNullable);
var compare = (a, b)=>a < b ? -1 : a > b ? 1 : 0;
var arrayEquals = (a, b)=>a === b || a.length === b.length && a.every((e, i)=>e === b[i]);
function chain(callbacks) {
    return (...args)=>{
        for (const callback of callbacks)callback && callback(...args);
    };
}
function reverseChain(callbacks) {
    return (...args)=>{
        for(let i = callbacks.length - 1; i >= 0; i--){
            const callback = callbacks[i];
            callback && callback(...args);
        }
    };
}
var clamp = (n, min, max)=>Math.min(Math.max(n, min), max);
var access = (v)=>typeof v === "function" && !v.length ? v() : v;
var asArray = (value)=>Array.isArray(value) ? value : value ? [
        value
    ] : [];
var accessArray = (list)=>list.map((v)=>access(v));
var withAccess = (value, fn)=>{
    const _value = access(value);
    fn(_value);
};
var asAccessor = (v)=>typeof v === "function" ? v : ()=>v;
function accessWith(valueOrFn, ...args) {
    return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
function defer(deps, fn, initialValue) {
    const isArray = Array.isArray(deps);
    let prevInput;
    let shouldDefer = true;
    return (prevValue)=>{
        let input;
        if (isArray) {
            input = Array(deps.length);
            for(let i = 0; i < deps.length; i++)input[i] = deps[i]();
        } else input = deps();
        if (shouldDefer) {
            shouldDefer = false;
            prevInput = input;
            return initialValue;
        }
        const result = (0, _solidJs.untrack)(()=>fn(input, prevInput, prevValue));
        prevInput = input;
        return result;
    };
}
var entries = Object.entries;
var keys = Object.keys;
var tryOnCleanup = isDev ? (fn)=>(0, _solidJs.getOwner)() ? (0, _solidJs.onCleanup)(fn) : fn : (0, _solidJs.onCleanup);
var createCallbackStack = ()=>{
    let stack = [];
    const clear = ()=>stack = [];
    return {
        push: (...callbacks)=>stack.push(...callbacks),
        execute (arg0, arg1, arg2, arg3) {
            stack.forEach((cb)=>cb(arg0, arg1, arg2, arg3));
            clear();
        },
        clear
    };
};
function createMicrotask(fn) {
    let calls = 0;
    let args;
    (0, _solidJs.onCleanup)(()=>calls = 0);
    return (...a)=>{
        args = a, calls++;
        queueMicrotask(()=>--calls === 0 && fn(...args));
    };
}
function createHydratableSignal(serverValue, update, options) {
    if (0, _web.isServer) return (0, _solidJs.createSignal)(serverValue, options);
    if ((0, _solidJs.sharedConfig).context) {
        const [state, setState] = (0, _solidJs.createSignal)(serverValue, options);
        (0, _solidJs.onMount)(()=>setState(()=>update()));
        return [
            state,
            setState
        ];
    }
    return (0, _solidJs.createSignal)(update(), options);
}
var createHydrateSignal = createHydratableSignal;
function handleDiffArray(current, prev, handleAdded, handleRemoved) {
    const currLength = current.length;
    const prevLength = prev.length;
    let i = 0;
    if (!prevLength) {
        for(; i < currLength; i++)handleAdded(current[i]);
        return;
    }
    if (!currLength) {
        for(; i < prevLength; i++)handleRemoved(prev[i]);
        return;
    }
    for(; i < prevLength; i++){
        if (prev[i] !== current[i]) break;
    }
    let prevEl;
    let currEl;
    prev = prev.slice(i);
    current = current.slice(i);
    for (prevEl of prev)if (!current.includes(prevEl)) handleRemoved(prevEl);
    for (currEl of current)if (!prev.includes(currEl)) handleAdded(currEl);
}

},{"solid-js":"f1z31","solid-js/web":"eGRlU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"60fDH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Entries", ()=>Entries);
parcelHelpers.export(exports, "Key", ()=>Key);
parcelHelpers.export(exports, "Rerun", ()=>Rerun);
parcelHelpers.export(exports, "keyArray", ()=>keyArray);
var _solidJs = require("solid-js");
var _web = require("solid-js/web");
// src/index.ts
var FALLBACK = Symbol("fallback");
function dispose(list) {
    for (const o of list)o.dispose();
}
function keyArray(items, keyFn, mapFn, options = {}) {
    if (0, _web.isServer) {
        const itemsRef = items();
        let s = [];
        if (itemsRef && itemsRef.length) for(let i = 0, len = itemsRef.length; i < len; i++)s.push(mapFn(()=>itemsRef[i], ()=>i));
        else if (options.fallback) s = [
            options.fallback()
        ];
        return ()=>s;
    }
    const prev = /* @__PURE__ */ new Map();
    (0, _solidJs.onCleanup)(()=>dispose(prev.values()));
    return ()=>{
        const list = items() || [];
        list[0, _solidJs.$TRACK];
        return (0, _solidJs.untrack)(()=>{
            if (!list.length) {
                dispose(prev.values());
                prev.clear();
                if (!options.fallback) return [];
                const fb2 = (0, _solidJs.createRoot)((dispose2)=>{
                    prev.set(FALLBACK, {
                        dispose: dispose2
                    });
                    return options.fallback();
                });
                return [
                    fb2
                ];
            }
            const result = new Array(list.length);
            const fb = prev.get(FALLBACK);
            if (!prev.size || fb) {
                fb?.dispose();
                prev.delete(FALLBACK);
                for(let i = 0; i < list.length; i++){
                    const item = list[i];
                    const key = keyFn(item, i);
                    addNewItem(result, item, i, key);
                }
                return result;
            }
            const prevKeys = new Set(prev.keys());
            for(let i1 = 0; i1 < list.length; i1++){
                const item1 = list[i1];
                const key1 = keyFn(item1, i1);
                prevKeys.delete(key1);
                const lookup = prev.get(key1);
                if (lookup) {
                    result[i1] = lookup.mapped;
                    lookup.setIndex?.(i1);
                    lookup.setItem(()=>item1);
                } else addNewItem(result, item1, i1, key1);
            }
            for (const key2 of prevKeys){
                prev.get(key2)?.dispose();
                prev.delete(key2);
            }
            return result;
        });
    };
    function addNewItem(list, item, i, key) {
        (0, _solidJs.createRoot)((dispose2)=>{
            const [getItem, setItem] = (0, _solidJs.createSignal)(item);
            const save = {
                setItem,
                dispose: dispose2
            };
            if (mapFn.length > 1) {
                const [index, setIndex] = (0, _solidJs.createSignal)(i);
                save.setIndex = setIndex;
                save.mapped = mapFn(getItem, index);
            } else save.mapped = mapFn(getItem);
            prev.set(key, save);
            list[i] = save.mapped;
        });
    }
}
function Key(props) {
    const { by  } = props;
    return (0, _solidJs.createMemo)(keyArray(()=>props.each, typeof by === "function" ? by : (v)=>v[by], props.children, "fallback" in props ? {
        fallback: ()=>props.fallback
    } : void 0));
}
function Entries(props) {
    const mapFn = props.children;
    return (0, _solidJs.createMemo)((0, _solidJs.mapArray)(()=>props.of && Object.keys(props.of), mapFn.length < 3 ? (key)=>mapFn(key, ()=>props.of[key]) : (key, i)=>mapFn(key, ()=>props.of[key], i), "fallback" in props ? {
        fallback: ()=>props.fallback
    } : void 0));
}
function Rerun(props) {
    const key = typeof props.on === "function" || Array.isArray(props.on) ? props.on : ()=>props.on;
    return (0, _solidJs.createMemo)((0, _solidJs.on)(key, (a, b)=>{
        const child = props.children;
        return typeof child === "function" && child.length > 0 ? child(a, b) : child;
    }));
}

},{"solid-js":"f1z31","solid-js/web":"eGRlU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"70FAY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createBreakpoints", ()=>createBreakpoints);
parcelHelpers.export(exports, "createMediaQuery", ()=>createMediaQuery);
parcelHelpers.export(exports, "createPrefersDark", ()=>createPrefersDark);
parcelHelpers.export(exports, "makeMediaQueryListener", ()=>makeMediaQueryListener);
parcelHelpers.export(exports, "sortBreakpoints", ()=>sortBreakpoints);
parcelHelpers.export(exports, "usePrefersDark", ()=>usePrefersDark);
var _web = require("solid-js/web");
var _eventListener = require("@solid-primitives/event-listener");
var _utils = require("@solid-primitives/utils");
var _staticStore = require("@solid-primitives/static-store");
var _rootless = require("@solid-primitives/rootless");
// src/index.ts
function makeMediaQueryListener(query, callback) {
    if (0, _web.isServer) return 0, _utils.noop;
    const mql = typeof query === "string" ? window.matchMedia(query) : query;
    return (0, _eventListener.makeEventListener)(mql, "change", callback);
}
function createMediaQuery(query, serverFallback = false) {
    if (0, _web.isServer) return ()=>serverFallback;
    const mql = window.matchMedia(query);
    const [state, setState] = (0, _utils.createHydratableSignal)(serverFallback, ()=>mql.matches);
    const update = ()=>setState(mql.matches);
    (0, _eventListener.makeEventListener)(mql, "change", update);
    return state;
}
function createPrefersDark(serverFallback) {
    return createMediaQuery("(prefers-color-scheme: dark)", serverFallback);
}
var usePrefersDark = /* @__PURE__ */ (0, _rootless.createHydratableSingletonRoot)(createPrefersDark.bind(void 0, false));
var getEmptyMatchesFromBreakpoints = (breakpoints)=>(0, _utils.entries)(breakpoints).reduce((matches, [key])=>{
        matches[key] = false;
        return matches;
    }, {});
function createBreakpoints(breakpoints, options = {}) {
    const fallback = Object.defineProperty(options.fallbackState ?? getEmptyMatchesFromBreakpoints(breakpoints), "key", {
        enumerable: false,
        get: ()=>Object.keys(breakpoints).pop()
    });
    if ((0, _web.isServer) || !window.matchMedia) return fallback;
    const { mediaFeature ="min-width" , watchChange =true  } = options;
    const [matches, setMatches] = (0, _staticStore.createHydratableStaticStore)(fallback, ()=>{
        const matches2 = {};
        (0, _utils.entries)(breakpoints).forEach(([token, width])=>{
            const mql = window.matchMedia(`(${mediaFeature}: ${width})`);
            matches2[token] = mql.matches;
            if (watchChange) (0, _eventListener.makeEventListener)(mql, "change", (e)=>setMatches(token, e.matches));
        });
        return matches2;
    });
    return Object.defineProperty(matches, "key", {
        enumerable: false,
        get: ()=>Object.keys(matches).findLast((token)=>matches[token])
    });
}
function sortBreakpoints(breakpoints) {
    const sorted = (0, _utils.entries)(breakpoints);
    sorted.sort((x, y)=>parseInt(x[1], 10) - parseInt(y[1], 10));
    return sorted.reduce((obj, [key, value])=>{
        obj[key] = value;
        return obj;
    }, {});
}

},{"solid-js/web":"eGRlU","@solid-primitives/event-listener":"1poSB","@solid-primitives/utils":"6V0Tj","@solid-primitives/static-store":"NcyTO","@solid-primitives/rootless":"84NVs","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"NcyTO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createDerivedStaticStore", ()=>createDerivedStaticStore);
parcelHelpers.export(exports, "createHydratableStaticStore", ()=>createHydratableStaticStore);
parcelHelpers.export(exports, "createStaticStore", ()=>createStaticStore);
var _utils = require("@solid-primitives/utils");
var _solidJs = require("solid-js");
var _web = require("solid-js/web");
// src/index.ts
function createStaticStore(init) {
    const copy = {
        ...init
    }, store = {
        ...init
    }, cache = {};
    const getValue = (key)=>{
        let signal = cache[key];
        if (!signal) {
            if (!(0, _solidJs.getListener)()) return copy[key];
            cache[key] = signal = (0, _solidJs.createSignal)(copy[key], {
                internal: true
            });
            delete copy[key];
        }
        return signal[0]();
    };
    for(const key in init)Object.defineProperty(store, key, {
        get: ()=>getValue(key),
        enumerable: true
    });
    const setValue = (key, value)=>{
        const signal = cache[key];
        if (signal) return signal[1](value);
        if (key in copy) copy[key] = (0, _utils.accessWith)(value, [
            copy[key]
        ]);
    };
    return [
        store,
        (a, b)=>{
            if ((0, _utils.isObject)(a)) {
                const entries = (0, _solidJs.untrack)(()=>Object.entries((0, _utils.accessWith)(a, store)));
                (0, _solidJs.batch)(()=>{
                    for (const [key, value] of entries)setValue(key, ()=>value);
                });
            } else setValue(a, b);
            return store;
        }
    ];
}
function createHydratableStaticStore(serverValue, update) {
    if (0, _web.isServer) return createStaticStore(serverValue);
    if ((0, _solidJs.sharedConfig).context) {
        const [state, setState] = createStaticStore(serverValue);
        (0, _solidJs.onMount)(()=>setState(update()));
        return [
            state,
            setState
        ];
    }
    return createStaticStore(update());
}
function createDerivedStaticStore(fn, value, options) {
    const o = (0, _solidJs.getOwner)(), fnMemo = (0, _solidJs.createMemo)(fn, value, options), store = {
        ...(0, _solidJs.untrack)(fnMemo)
    }, cache = {};
    for(const key in store)Object.defineProperty(store, key, {
        get () {
            let keyMemo = cache[key];
            if (!keyMemo) {
                if (!(0, _solidJs.getListener)()) return fnMemo()[key];
                (0, _solidJs.runWithOwner)(o, ()=>cache[key] = keyMemo = (0, _solidJs.createMemo)(()=>fnMemo()[key]));
            }
            return keyMemo();
        },
        enumerable: true
    });
    return store;
}

},{"@solid-primitives/utils":"6V0Tj","solid-js":"f1z31","solid-js/web":"eGRlU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"84NVs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createBranch", ()=>createBranch);
parcelHelpers.export(exports, "createCallback", ()=>createCallback);
parcelHelpers.export(exports, "createDisposable", ()=>createDisposable);
parcelHelpers.export(exports, "createHydratableSingletonRoot", ()=>createHydratableSingletonRoot);
parcelHelpers.export(exports, "createRootPool", ()=>createRootPool);
parcelHelpers.export(exports, "createSharedRoot", ()=>createSharedRoot);
parcelHelpers.export(exports, "createSingletonRoot", ()=>createSingletonRoot);
parcelHelpers.export(exports, "createSubRoot", ()=>createSubRoot);
var _solidJs = require("solid-js");
var _web = require("solid-js/web");
var _utils = require("@solid-primitives/utils");
// src/index.ts
function createSubRoot(fn, ...owners) {
    if (owners.length === 0) owners = [
        (0, _solidJs.getOwner)()
    ];
    return (0, _solidJs.createRoot)((dispose)=>{
        (0, _utils.asArray)((0, _utils.access)(owners)).forEach((owner)=>owner && (0, _solidJs.runWithOwner)(owner, (0, _solidJs.onCleanup).bind(void 0, dispose)));
        return fn(dispose);
    }, owners[0]);
}
var createBranch = createSubRoot;
var createCallback = (callback, owner = (0, _solidJs.getOwner)())=>owner ? (...args)=>(0, _solidJs.runWithOwner)(owner, ()=>callback(...args)) : callback;
function createDisposable(fn, ...owners) {
    return createSubRoot((dispose)=>{
        fn(dispose);
        return dispose;
    }, ...owners);
}
function createSingletonRoot(factory, detachedOwner = (0, _solidJs.getOwner)()) {
    let listeners = 0, value, disposeRoot;
    return ()=>{
        listeners++;
        (0, _solidJs.onCleanup)(()=>{
            listeners--;
            queueMicrotask(()=>{
                if (!listeners && disposeRoot) {
                    disposeRoot();
                    disposeRoot = value = void 0;
                }
            });
        });
        if (!disposeRoot) (0, _solidJs.createRoot)((dispose)=>value = factory(disposeRoot = dispose), detachedOwner);
        return value;
    };
}
var createSharedRoot = createSingletonRoot;
function createHydratableSingletonRoot(factory) {
    const owner = (0, _solidJs.getOwner)();
    const singleton = createSingletonRoot(factory, owner);
    return ()=>(0, _web.isServer) || (0, _solidJs.sharedConfig).context ? (0, _solidJs.createRoot)(factory, owner) : singleton();
}
function createRootPool(factory, options = {}) {
    if (0, _web.isServer) {
        const owner2 = (0, _solidJs.getOwner)();
        return (args)=>(0, _solidJs.createRoot)((dispose)=>factory(()=>args, (0, _utils.trueFn), dispose), owner2);
    }
    let length = 0;
    const { limit =100  } = options, pool = new Array(limit), owner = (0, _solidJs.getOwner)(), mapRoot = factory.length > 1 ? (dispose, [args, set])=>{
        const [active, setA] = (0, _solidJs.createSignal)(true);
        const root = {
            dispose,
            set,
            setA,
            active,
            v: factory(args, active, ()=>disposeRoot(root))
        };
        return root;
    } : (dispose, [args, set])=>({
            dispose,
            set,
            setA: (0, _utils.trueFn),
            active: (0, _utils.trueFn),
            v: factory(args, (0, _utils.trueFn), (0, _utils.noop))
        }), limitPool = (0, _utils.createMicrotask)(()=>{
        if (length > limit) {
            for(let i = limit; i < length; i++){
                pool[i].dispose();
                pool[i] = void 0;
            }
            length = limit;
        }
    }), cleanupRoot = (root)=>{
        if (root.dispose !== (0, _utils.noop)) {
            pool[length++] = root;
            root.setA(false);
            limitPool();
        }
    }, disposeRoot = (root)=>{
        root.dispose();
        root.dispose = (0, _utils.noop);
        if (root.active()) root.setA(false);
        else {
            pool[pool.indexOf(root)] = pool[--length];
            pool[length] = void 0;
        }
    };
    (0, _solidJs.onCleanup)(()=>{
        for(let i = 0; i < length; i++)pool[i].dispose();
        length = 0;
    });
    return (arg)=>{
        let root;
        if (length) {
            root = pool[--length];
            pool[length] = void 0;
            (0, _solidJs.batch)(()=>{
                root.set(()=>arg);
                root.setA(true);
            });
        } else root = (0, _solidJs.createRoot)((dispose)=>mapRoot(dispose, (0, _solidJs.createSignal)(arg)), owner);
        (0, _solidJs.onCleanup)(()=>cleanupRoot(root));
        return root.v;
    };
}

},{"solid-js":"f1z31","solid-js/web":"eGRlU","@solid-primitives/utils":"6V0Tj","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dPUSw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineProps", ()=>combineProps);
parcelHelpers.export(exports, "combineStyle", ()=>combineStyle);
parcelHelpers.export(exports, "createPropsPredicate", ()=>createPropsPredicate);
parcelHelpers.export(exports, "filterProps", ()=>filterProps);
parcelHelpers.export(exports, "propTraps", ()=>propTraps);
parcelHelpers.export(exports, "stringStyleToObject", ()=>stringStyleToObject);
var _solidJs = require("solid-js");
var _utils = require("@solid-primitives/utils");
// src/propTraps.ts
function trueFn() {
    return true;
}
var propTraps = {
    get (_, property, receiver) {
        if (property === (0, _solidJs.$PROXY)) return receiver;
        return _.get(property);
    },
    has (_, property) {
        return _.has(property);
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor (_, property) {
        return {
            configurable: true,
            enumerable: true,
            get () {
                return _.get(property);
            },
            set: trueFn,
            deleteProperty: trueFn
        };
    },
    ownKeys (_) {
        return _.keys();
    }
};
function filterProps(props, predicate) {
    return new Proxy({
        get (property) {
            return property in props && predicate(property) ? props[property] : void 0;
        },
        has (property) {
            return property in props && predicate(property);
        },
        keys () {
            return Object.keys(props).filter(predicate);
        }
    }, propTraps);
}
function createPropsPredicate(props, predicate) {
    const cache = (0, _solidJs.createMemo)(()=>{
        return {};
    }, void 0, {
        equals: false
    });
    return (key)=>{
        const cacheRef = cache();
        const cached = cacheRef[key];
        if (cached !== void 0) return cached;
        const v = predicate(key);
        cacheRef[key] = v;
        return v;
    };
}
var extractCSSregex = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
function stringStyleToObject(style) {
    const object = {};
    let match;
    while(match = extractCSSregex.exec(style))object[match[1]] = match[2];
    return object;
}
function combineStyle(a, b) {
    if (typeof a === "string") {
        if (typeof b === "string") return `${a};${b}`;
        a = stringStyleToObject(a);
    } else if (typeof b === "string") b = stringStyleToObject(b);
    return {
        ...a,
        ...b
    };
}
var reduce = (sources, key, calc)=>{
    let v = void 0;
    for (const props of sources){
        const propV = (0, _utils.access)(props)[key];
        if (!v) v = propV;
        else if (propV) v = calc(v, propV);
    }
    return v;
};
function combineProps(...args) {
    const restArgs = Array.isArray(args[0]);
    const sources = restArgs ? args[0] : args;
    if (sources.length === 1) return sources[0];
    const chainFn = restArgs && args[1]?.reverseEventHandlers ? (0, _utils.reverseChain) : (0, _utils.chain);
    const listeners = {};
    for (const props of sources){
        const propsObj = (0, _utils.access)(props);
        for(const key in propsObj)if (key[0] === "o" && key[1] === "n" && key[2]) {
            const v = propsObj[key];
            const name = key.toLowerCase();
            const callback = typeof v === "function" ? v : // jsx event handlers can be tuples of [callback, arg]
            Array.isArray(v) ? v.length === 1 ? v[0] : v[0].bind(void 0, v[1]) : void 0;
            if (callback) listeners[name] ? listeners[name].push(callback) : listeners[name] = [
                callback
            ];
            else delete listeners[name];
        }
    }
    const merge = (0, _solidJs.mergeProps)(...sources);
    return new Proxy({
        get (key) {
            if (typeof key !== "string") return Reflect.get(merge, key);
            if (key === "style") return reduce(sources, "style", combineStyle);
            if (key === "ref") {
                const callbacks = [];
                for (const props of sources){
                    const cb = (0, _utils.access)(props)[key];
                    if (typeof cb === "function") callbacks.push(cb);
                }
                return chainFn(callbacks);
            }
            if (key[0] === "o" && key[1] === "n" && key[2]) {
                const callbacks1 = listeners[key.toLowerCase()];
                return callbacks1 ? chainFn(callbacks1) : Reflect.get(merge, key);
            }
            if (key === "class" || key === "className") return reduce(sources, key, (a, b)=>`${a} ${b}`);
            if (key === "classList") return reduce(sources, key, (a, b)=>({
                    ...a,
                    ...b
                }));
            return Reflect.get(merge, key);
        },
        has (key) {
            return Reflect.has(merge, key);
        },
        keys () {
            return Object.keys(merge);
        }
    }, propTraps);
}

},{"solid-js":"f1z31","@solid-primitives/utils":"6V0Tj","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hO6Py":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Ref", ()=>Ref);
parcelHelpers.export(exports, "Refs", ()=>Refs);
parcelHelpers.export(exports, "defaultElementPredicate", ()=>defaultElementPredicate);
parcelHelpers.export(exports, "getFirstChild", ()=>getFirstChild);
parcelHelpers.export(exports, "getResolvedElements", ()=>getResolvedElements);
parcelHelpers.export(exports, "mergeRefs", ()=>mergeRefs);
parcelHelpers.export(exports, "resolveElements", ()=>resolveElements);
parcelHelpers.export(exports, "resolveFirst", ()=>resolveFirst);
var _utils = require("@solid-primitives/utils");
var _solidJs = require("solid-js");
var _web = require("solid-js/web");
// src/index.ts
function mergeRefs(...refs) {
    return (0, _utils.chain)(refs);
}
var defaultElementPredicate = (0, _web.isServer) ? (item)=>item != null && typeof item === "object" && "t" in item : (item)=>item instanceof Element;
function getResolvedElements(value, predicate) {
    if (predicate(value)) return value;
    if (typeof value === "function" && !value.length) return getResolvedElements(value(), predicate);
    if (Array.isArray(value)) {
        const results = [];
        for (const item of value){
            const result = getResolvedElements(item, predicate);
            if (result) Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
        }
        return results.length ? results : null;
    }
    return null;
}
function resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {
    const children2 = (0, _solidJs.createMemo)(fn);
    const memo = (0, _solidJs.createMemo)(()=>getResolvedElements(children2(), (0, _web.isServer) ? serverPredicate : predicate));
    memo.toArray = ()=>{
        const value = memo();
        return Array.isArray(value) ? value : value ? [
            value
        ] : [];
    };
    return memo;
}
function getFirstChild(value, predicate) {
    if (predicate(value)) return value;
    if (typeof value === "function" && !value.length) return getFirstChild(value(), predicate);
    if (Array.isArray(value)) for (const item of value){
        const result = getFirstChild(item, predicate);
        if (result) return result;
    }
    return null;
}
function resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {
    const children2 = (0, _solidJs.createMemo)(fn);
    return (0, _solidJs.createMemo)(()=>getFirstChild(children2(), (0, _web.isServer) ? serverPredicate : predicate));
}
function Refs(props) {
    if (0, _web.isServer) return props.children;
    const cb = props.ref, resolved = (0, _solidJs.children)(()=>props.children);
    let prev = [];
    (0, _solidJs.createComputed)(()=>{
        const els = resolved.toArray().filter(defaultElementPredicate);
        if (!(0, _utils.arrayEquals)(prev, els)) (0, _solidJs.untrack)(()=>cb(els));
        prev = els;
    }, []);
    (0, _solidJs.onCleanup)(()=>prev.length && cb([]));
    return resolved;
}
function Ref(props) {
    if (0, _web.isServer) return props.children;
    const cb = props.ref, resolved = (0, _solidJs.children)(()=>props.children);
    let prev;
    (0, _solidJs.createComputed)(()=>{
        const el = resolved.toArray().find(defaultElementPredicate);
        if (el !== prev) (0, _solidJs.untrack)(()=>cb(el));
        prev = el;
    });
    (0, _solidJs.onCleanup)(()=>prev && cb(void 0));
    return resolved;
}

},{"@solid-primitives/utils":"6V0Tj","solid-js":"f1z31","solid-js/web":"eGRlU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"iDjqj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$RAW", ()=>$RAW);
parcelHelpers.export(exports, "DEV", ()=>DEV);
parcelHelpers.export(exports, "createMutable", ()=>createMutable);
parcelHelpers.export(exports, "createStore", ()=>createStore);
parcelHelpers.export(exports, "modifyMutable", ()=>modifyMutable);
parcelHelpers.export(exports, "produce", ()=>produce);
parcelHelpers.export(exports, "reconcile", ()=>reconcile);
parcelHelpers.export(exports, "unwrap", ()=>unwrap);
var _solidJs = require("solid-js");
const $RAW = Symbol("store-raw"), $NODE = Symbol("store-node"), $HAS = Symbol("store-has"), $SELF = Symbol("store-self");
function wrap$1(value) {
    let p = value[0, _solidJs.$PROXY];
    if (!p) {
        Object.defineProperty(value, (0, _solidJs.$PROXY), {
            value: p = new Proxy(value, proxyTraps$1)
        });
        if (!Array.isArray(value)) {
            const keys = Object.keys(value), desc = Object.getOwnPropertyDescriptors(value);
            for(let i = 0, l = keys.length; i < l; i++){
                const prop = keys[i];
                if (desc[prop].get) Object.defineProperty(value, prop, {
                    enumerable: desc[prop].enumerable,
                    get: desc[prop].get.bind(p)
                });
            }
        }
    }
    return p;
}
function isWrappable(obj) {
    let proto;
    return obj != null && typeof obj === "object" && (obj[0, _solidJs.$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
}
function unwrap(item, set = new Set()) {
    let result, unwrapped, v, prop;
    if (result = item != null && item[$RAW]) return result;
    if (!isWrappable(item) || set.has(item)) return item;
    if (Array.isArray(item)) {
        if (Object.isFrozen(item)) item = item.slice(0);
        else set.add(item);
        for(let i = 0, l = item.length; i < l; i++){
            v = item[i];
            if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
        }
    } else {
        if (Object.isFrozen(item)) item = Object.assign({}, item);
        else set.add(item);
        const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);
        for(let i1 = 0, l1 = keys.length; i1 < l1; i1++){
            prop = keys[i1];
            if (desc[prop].get) continue;
            v = item[prop];
            if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;
        }
    }
    return item;
}
function getNodes(target, symbol) {
    let nodes = target[symbol];
    if (!nodes) Object.defineProperty(target, symbol, {
        value: nodes = Object.create(null)
    });
    return nodes;
}
function getNode(nodes, property, value) {
    if (nodes[property]) return nodes[property];
    const [s, set] = (0, _solidJs.createSignal)(value, {
        equals: false,
        internal: true
    });
    s.$ = set;
    return nodes[property] = s;
}
function proxyDescriptor$1(target, property) {
    const desc = Reflect.getOwnPropertyDescriptor(target, property);
    if (!desc || desc.get || !desc.configurable || property === (0, _solidJs.$PROXY) || property === $NODE) return desc;
    delete desc.value;
    delete desc.writable;
    desc.get = ()=>target[0, _solidJs.$PROXY][property];
    return desc;
}
function trackSelf(target) {
    (0, _solidJs.getListener)() && getNode(getNodes(target, $NODE), $SELF)();
}
function ownKeys(target) {
    trackSelf(target);
    return Reflect.ownKeys(target);
}
const proxyTraps$1 = {
    get (target, property, receiver) {
        if (property === $RAW) return target;
        if (property === (0, _solidJs.$PROXY)) return receiver;
        if (property === (0, _solidJs.$TRACK)) {
            trackSelf(target);
            return receiver;
        }
        const nodes = getNodes(target, $NODE);
        const tracked = nodes[property];
        let value = tracked ? tracked() : target[property];
        if (property === $NODE || property === $HAS || property === "__proto__") return value;
        if (!tracked) {
            const desc = Object.getOwnPropertyDescriptor(target, property);
            if ((0, _solidJs.getListener)() && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();
        }
        return isWrappable(value) ? wrap$1(value) : value;
    },
    has (target, property) {
        if (property === $RAW || property === (0, _solidJs.$PROXY) || property === (0, _solidJs.$TRACK) || property === $NODE || property === $HAS || property === "__proto__") return true;
        (0, _solidJs.getListener)() && getNode(getNodes(target, $HAS), property)();
        return property in target;
    },
    set () {
        return true;
    },
    deleteProperty () {
        return true;
    },
    ownKeys: ownKeys,
    getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(state, property, value, deleting = false) {
    if (!deleting && state[property] === value) return;
    const prev = state[property], len = state.length;
    if (value === undefined) {
        delete state[property];
        if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();
    } else {
        state[property] = value;
        if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();
    }
    let nodes = getNodes(state, $NODE), node;
    if (node = getNode(nodes, property, prev)) node.$(()=>value);
    if (Array.isArray(state) && state.length !== len) {
        for(let i = state.length; i < len; i++)(node = nodes[i]) && node.$();
        (node = getNode(nodes, "length", len)) && node.$(state.length);
    }
    (node = nodes[$SELF]) && node.$();
}
function mergeStoreNode(state, value) {
    const keys = Object.keys(value);
    for(let i = 0; i < keys.length; i += 1){
        const key = keys[i];
        setProperty(state, key, value[key]);
    }
}
function updateArray(current, next) {
    if (typeof next === "function") next = next(current);
    next = unwrap(next);
    if (Array.isArray(next)) {
        if (current === next) return;
        let i = 0, len = next.length;
        for(; i < len; i++){
            const value = next[i];
            if (current[i] !== value) setProperty(current, i, value);
        }
        setProperty(current, "length", len);
    } else mergeStoreNode(current, next);
}
function updatePath(current, path, traversed = []) {
    let part, prev = current;
    if (path.length > 1) {
        part = path.shift();
        const partType = typeof part, isArray = Array.isArray(current);
        if (Array.isArray(part)) {
            for(let i = 0; i < part.length; i++)updatePath(current, [
                part[i]
            ].concat(path), traversed);
            return;
        } else if (isArray && partType === "function") {
            for(let i1 = 0; i1 < current.length; i1++)if (part(current[i1], i1)) updatePath(current, [
                i1
            ].concat(path), traversed);
            return;
        } else if (isArray && partType === "object") {
            const { from =0 , to =current.length - 1 , by =1  } = part;
            for(let i2 = from; i2 <= to; i2 += by)updatePath(current, [
                i2
            ].concat(path), traversed);
            return;
        } else if (path.length > 1) {
            updatePath(current[part], path, [
                part
            ].concat(traversed));
            return;
        }
        prev = current[part];
        traversed = [
            part
        ].concat(traversed);
    }
    let value = path[0];
    if (typeof value === "function") {
        value = value(prev, traversed);
        if (value === prev) return;
    }
    if (part === undefined && value == undefined) return;
    value = unwrap(value);
    if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) mergeStoreNode(prev, value);
    else setProperty(current, part, value);
}
function createStore(...[store, options]) {
    const unwrappedStore = unwrap(store || {});
    const isArray = Array.isArray(unwrappedStore);
    const wrappedStore = wrap$1(unwrappedStore);
    function setStore(...args) {
        (0, _solidJs.batch)(()=>{
            isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
        });
    }
    return [
        wrappedStore,
        setStore
    ];
}
function proxyDescriptor(target, property) {
    const desc = Reflect.getOwnPropertyDescriptor(target, property);
    if (!desc || desc.get || desc.set || !desc.configurable || property === (0, _solidJs.$PROXY) || property === $NODE) return desc;
    delete desc.value;
    delete desc.writable;
    desc.get = ()=>target[0, _solidJs.$PROXY][property];
    desc.set = (v)=>target[0, _solidJs.$PROXY][property] = v;
    return desc;
}
const proxyTraps = {
    get (target, property, receiver) {
        if (property === $RAW) return target;
        if (property === (0, _solidJs.$PROXY)) return receiver;
        if (property === (0, _solidJs.$TRACK)) {
            trackSelf(target);
            return receiver;
        }
        const nodes = getNodes(target, $NODE);
        const tracked = nodes[property];
        let value = tracked ? tracked() : target[property];
        if (property === $NODE || property === $HAS || property === "__proto__") return value;
        if (!tracked) {
            const desc = Object.getOwnPropertyDescriptor(target, property);
            const isFunction = typeof value === "function";
            if ((0, _solidJs.getListener)() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();
            else if (value != null && isFunction && value === Array.prototype[property]) return (...args)=>(0, _solidJs.batch)(()=>Array.prototype[property].apply(receiver, args));
        }
        return isWrappable(value) ? wrap(value) : value;
    },
    has (target, property) {
        if (property === $RAW || property === (0, _solidJs.$PROXY) || property === (0, _solidJs.$TRACK) || property === $NODE || property === $HAS || property === "__proto__") return true;
        (0, _solidJs.getListener)() && getNode(getNodes(target, $HAS), property)();
        return property in target;
    },
    set (target, property, value) {
        (0, _solidJs.batch)(()=>setProperty(target, property, unwrap(value)));
        return true;
    },
    deleteProperty (target, property) {
        (0, _solidJs.batch)(()=>setProperty(target, property, undefined, true));
        return true;
    },
    ownKeys: ownKeys,
    getOwnPropertyDescriptor: proxyDescriptor
};
function wrap(value) {
    let p = value[0, _solidJs.$PROXY];
    if (!p) {
        Object.defineProperty(value, (0, _solidJs.$PROXY), {
            value: p = new Proxy(value, proxyTraps)
        });
        const keys = Object.keys(value), desc = Object.getOwnPropertyDescriptors(value);
        for(let i = 0, l = keys.length; i < l; i++){
            const prop = keys[i];
            if (desc[prop].get) {
                const get = desc[prop].get.bind(p);
                Object.defineProperty(value, prop, {
                    get
                });
            }
            if (desc[prop].set) {
                const og = desc[prop].set, set = (v)=>(0, _solidJs.batch)(()=>og.call(p, v));
                Object.defineProperty(value, prop, {
                    set
                });
            }
        }
    }
    return p;
}
function createMutable(state, options) {
    const unwrappedStore = unwrap(state || {});
    const wrappedStore = wrap(unwrappedStore);
    return wrappedStore;
}
function modifyMutable(state, modifier) {
    (0, _solidJs.batch)(()=>modifier(unwrap(state)));
}
const $ROOT = Symbol("store-root");
function applyState(target, parent, property, merge, key) {
    const previous = parent[property];
    if (target === previous) return;
    const isArray = Array.isArray(target);
    if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray !== Array.isArray(previous) || key && target[key] !== previous[key])) {
        setProperty(parent, property, target);
        return;
    }
    if (isArray) {
        if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {
            let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
            for(start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++)applyState(target[start], previous, start, merge, key);
            const temp = new Array(target.length), newIndices = new Map();
            for(end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]); end--, newEnd--)temp[newEnd] = previous[end];
            if (start > newEnd || start > end) {
                for(j = start; j <= newEnd; j++)setProperty(previous, j, target[j]);
                for(; j < target.length; j++){
                    setProperty(previous, j, temp[j]);
                    applyState(target[j], previous, j, merge, key);
                }
                if (previous.length > target.length) setProperty(previous, "length", target.length);
                return;
            }
            newIndicesNext = new Array(newEnd + 1);
            for(j = newEnd; j >= start; j--){
                item = target[j];
                keyVal = key && item ? item[key] : item;
                i = newIndices.get(keyVal);
                newIndicesNext[j] = i === undefined ? -1 : i;
                newIndices.set(keyVal, j);
            }
            for(i = start; i <= end; i++){
                item = previous[i];
                keyVal = key && item ? item[key] : item;
                j = newIndices.get(keyVal);
                if (j !== undefined && j !== -1) {
                    temp[j] = previous[i];
                    j = newIndicesNext[j];
                    newIndices.set(keyVal, j);
                }
            }
            for(j = start; j < target.length; j++)if (j in temp) {
                setProperty(previous, j, temp[j]);
                applyState(target[j], previous, j, merge, key);
            } else setProperty(previous, j, target[j]);
        } else for(let i1 = 0, len = target.length; i1 < len; i1++)applyState(target[i1], previous, i1, merge, key);
        if (previous.length > target.length) setProperty(previous, "length", target.length);
        return;
    }
    const targetKeys = Object.keys(target);
    for(let i2 = 0, len1 = targetKeys.length; i2 < len1; i2++)applyState(target[targetKeys[i2]], previous, targetKeys[i2], merge, key);
    const previousKeys = Object.keys(previous);
    for(let i3 = 0, len2 = previousKeys.length; i3 < len2; i3++)if (target[previousKeys[i3]] === undefined) setProperty(previous, previousKeys[i3], undefined);
}
function reconcile(value, options = {}) {
    const { merge , key ="id"  } = options, v = unwrap(value);
    return (state)=>{
        if (!isWrappable(state) || !isWrappable(v)) return v;
        const res = applyState(v, {
            [$ROOT]: state
        }, $ROOT, merge, key);
        return res === undefined ? state : res;
    };
}
const producers = new WeakMap();
const setterTraps = {
    get (target, property) {
        if (property === $RAW) return target;
        const value = target[property];
        let proxy;
        return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;
    },
    set (target, property, value) {
        setProperty(target, property, unwrap(value));
        return true;
    },
    deleteProperty (target, property) {
        setProperty(target, property, undefined, true);
        return true;
    }
};
function produce(fn) {
    return (state)=>{
        if (isWrappable(state)) {
            let proxy;
            if (!(proxy = producers.get(state))) producers.set(state, proxy = new Proxy(state, setterTraps));
            fn(proxy);
        }
        return state;
    };
}
const DEV = undefined;

},{"solid-js":"f1z31","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bh5Gu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CalendarDate", ()=>$35ea8db9cb2ccb90$export$99faa760c7908e4f);
parcelHelpers.export(exports, "CalendarDateTime", ()=>$35ea8db9cb2ccb90$export$ca871e8dbb80966f);
parcelHelpers.export(exports, "Time", ()=>$35ea8db9cb2ccb90$export$680ea196effce5f);
parcelHelpers.export(exports, "ZonedDateTime", ()=>$35ea8db9cb2ccb90$export$d3b7288e7994edea);
parcelHelpers.export(exports, "GregorianCalendar", ()=>$3b62074eb05584b2$export$80ee6245ec4f29ec);
parcelHelpers.export(exports, "JapaneseCalendar", ()=>$62225008020f0a13$export$b746ab2b60cdffbf);
parcelHelpers.export(exports, "BuddhistCalendar", ()=>$8d73d47422ca7302$export$42d20a78301dee44);
parcelHelpers.export(exports, "TaiwanCalendar", ()=>$5f31bd6f0c8940b2$export$65e01080afcb0799);
parcelHelpers.export(exports, "PersianCalendar", ()=>$f3ed2e4472ae7e25$export$37fccdbfd14c5939);
parcelHelpers.export(exports, "IndianCalendar", ()=>$82c358003bdda0a8$export$39f31c639fa15726);
parcelHelpers.export(exports, "IslamicCivilCalendar", ()=>$f2f3e0e3a817edbd$export$2066795aadd37bfc);
parcelHelpers.export(exports, "IslamicTabularCalendar", ()=>$f2f3e0e3a817edbd$export$37f0887f2f9d22f7);
parcelHelpers.export(exports, "IslamicUmalquraCalendar", ()=>$f2f3e0e3a817edbd$export$5baab4758c231076);
parcelHelpers.export(exports, "HebrewCalendar", ()=>$7c5f6fbf42389787$export$ca405048b8fb5af);
parcelHelpers.export(exports, "EthiopicCalendar", ()=>$b956b2d7a6cf451f$export$26ba6eab5e20cd7d);
parcelHelpers.export(exports, "EthiopicAmeteAlemCalendar", ()=>$b956b2d7a6cf451f$export$d72e0c37005a4914);
parcelHelpers.export(exports, "CopticCalendar", ()=>$b956b2d7a6cf451f$export$fe6243cbe1a4b7c1);
parcelHelpers.export(exports, "createCalendar", ()=>$64244302c3013299$export$dd0bbc9b26defe37);
parcelHelpers.export(exports, "toCalendarDate", ()=>$11d87f3f76e88657$export$93522d1a439f3617);
parcelHelpers.export(exports, "toCalendarDateTime", ()=>$11d87f3f76e88657$export$b21e0b124e224484);
parcelHelpers.export(exports, "toTime", ()=>$11d87f3f76e88657$export$d33f79e3ffc3dc83);
parcelHelpers.export(exports, "toCalendar", ()=>$11d87f3f76e88657$export$b4a036af3fc0b032);
parcelHelpers.export(exports, "toZoned", ()=>$11d87f3f76e88657$export$84c95a83c799e074);
parcelHelpers.export(exports, "toTimeZone", ()=>$11d87f3f76e88657$export$538b00033cc11c75);
parcelHelpers.export(exports, "toLocalTimeZone", ()=>$11d87f3f76e88657$export$d9b67bc93c097491);
parcelHelpers.export(exports, "fromDate", ()=>$11d87f3f76e88657$export$e57ff100d91bd4b9);
parcelHelpers.export(exports, "fromAbsolute", ()=>$11d87f3f76e88657$export$1b96692a1ba042ac);
parcelHelpers.export(exports, "isSameDay", ()=>$14e0f24ef4ac5c92$export$ea39ec197993aef0);
parcelHelpers.export(exports, "isSameMonth", ()=>$14e0f24ef4ac5c92$export$a18c89cbd24170ff);
parcelHelpers.export(exports, "isSameYear", ()=>$14e0f24ef4ac5c92$export$5841f9eb9773f25f);
parcelHelpers.export(exports, "isEqualDay", ()=>$14e0f24ef4ac5c92$export$91b62ebf2ba703ee);
parcelHelpers.export(exports, "isEqualMonth", ()=>$14e0f24ef4ac5c92$export$5a8da0c44a3afdf2);
parcelHelpers.export(exports, "isEqualYear", ()=>$14e0f24ef4ac5c92$export$ea840f5a6dda8147);
parcelHelpers.export(exports, "isToday", ()=>$14e0f24ef4ac5c92$export$629b0a497aa65267);
parcelHelpers.export(exports, "getDayOfWeek", ()=>$14e0f24ef4ac5c92$export$2061056d06d7cdf7);
parcelHelpers.export(exports, "now", ()=>$14e0f24ef4ac5c92$export$461939dd4422153);
parcelHelpers.export(exports, "today", ()=>$14e0f24ef4ac5c92$export$d0bdf45af03a6ea3);
parcelHelpers.export(exports, "getHoursInDay", ()=>$14e0f24ef4ac5c92$export$126c91c941de7e);
parcelHelpers.export(exports, "getLocalTimeZone", ()=>$14e0f24ef4ac5c92$export$aa8b41735afcabd2);
parcelHelpers.export(exports, "startOfMonth", ()=>$14e0f24ef4ac5c92$export$a5a3b454ada2268e);
parcelHelpers.export(exports, "startOfWeek", ()=>$14e0f24ef4ac5c92$export$42c81a444fbfb5d4);
parcelHelpers.export(exports, "startOfYear", ()=>$14e0f24ef4ac5c92$export$f91e89d3d0406102);
parcelHelpers.export(exports, "endOfMonth", ()=>$14e0f24ef4ac5c92$export$a2258d9c4118825c);
parcelHelpers.export(exports, "endOfWeek", ()=>$14e0f24ef4ac5c92$export$ef8b6d9133084f4e);
parcelHelpers.export(exports, "endOfYear", ()=>$14e0f24ef4ac5c92$export$8b7aa55c66d5569e);
parcelHelpers.export(exports, "getMinimumMonthInYear", ()=>$14e0f24ef4ac5c92$export$5412ac11713b72ad);
parcelHelpers.export(exports, "getMinimumDayInMonth", ()=>$14e0f24ef4ac5c92$export$b2f4953d301981d5);
parcelHelpers.export(exports, "getWeeksInMonth", ()=>$14e0f24ef4ac5c92$export$ccc1b2479e7dd654);
parcelHelpers.export(exports, "minDate", ()=>$14e0f24ef4ac5c92$export$5c333a116e949cdd);
parcelHelpers.export(exports, "maxDate", ()=>$14e0f24ef4ac5c92$export$a75f2bff57811055);
parcelHelpers.export(exports, "isWeekend", ()=>$14e0f24ef4ac5c92$export$618d60ea299da42);
parcelHelpers.export(exports, "isWeekday", ()=>$14e0f24ef4ac5c92$export$ee9d87258e1d19ed);
parcelHelpers.export(exports, "parseDate", ()=>$fae977aafc393c5c$export$6b862160d295c8e);
parcelHelpers.export(exports, "parseDateTime", ()=>$fae977aafc393c5c$export$588937bcd60ade55);
parcelHelpers.export(exports, "parseTime", ()=>$fae977aafc393c5c$export$c9698ec7f05a07e1);
parcelHelpers.export(exports, "parseAbsolute", ()=>$fae977aafc393c5c$export$5adfdab05168c219);
parcelHelpers.export(exports, "parseAbsoluteToLocal", ()=>$fae977aafc393c5c$export$8e384432362ed0f0);
parcelHelpers.export(exports, "parseZonedDateTime", ()=>$fae977aafc393c5c$export$fd7893f06e92a6a4);
parcelHelpers.export(exports, "parseDuration", ()=>$fae977aafc393c5c$export$ecae829bb3747ea6);
parcelHelpers.export(exports, "DateFormatter", ()=>$fb18d541ea1ad717$export$ad991b66133851cf);
var _classPrivateFieldInit = require("@swc/helpers/_/_class_private_field_init");
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
    return amount - numerator * Math.floor(amount / numerator);
}
function $2b4dce13dd5a17fa$export$784d13d8ee351f07(date) {
    if (date.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date.calendar, date.era, date.year, date.month, date.day);
    else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date.calendar, date.year, date.month, date.day);
}
function $2b4dce13dd5a17fa$export$27fa0172ae2644b3(date) {
    if (date.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(date.calendar, date.era, date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
    else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(date.calendar, date.year, date.month, date.day, date.hour, date.minute, date.second);
}
const $3b62074eb05584b2$var$EPOCH = 1721426; // 001/01/03 Julian C.E.
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
    year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
    let y1 = year - 1;
    let monthOffset = -2;
    if (month <= 2) monthOffset = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
    return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
    return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
    let era = "AD";
    if (year <= 0) {
        era = "BC";
        year = 1 - year;
    }
    return [
        era,
        year
    ];
}
const $3b62074eb05584b2$var$daysInMonth = {
    standard: [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ],
    leapyear: [
        31,
        29,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ]
};
class $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let jd0 = jd;
        let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
        let quadricent = Math.floor(depoch / 146097);
        let dqc = $2b4dce13dd5a17fa$export$842a2cf37af977e1(depoch, 146097);
        let cent = Math.floor(dqc / 36524);
        let dcent = $2b4dce13dd5a17fa$export$842a2cf37af977e1(dqc, 36524);
        let quad = Math.floor(dcent / 1461);
        let dquad = $2b4dce13dd5a17fa$export$842a2cf37af977e1(dcent, 1461);
        let yindex = Math.floor(dquad / 365);
        let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
        let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
        let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
        let leapAdj = 2;
        if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
        else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
        let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
        let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(era, year, month, day);
    }
    toJulianDay(date) {
        return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMonthsInYear(date) {
        return 12;
    }
    getDaysInYear(date) {
        return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getYearsInEra(date) {
        return 9999;
    }
    getEras() {
        return [
            "BC",
            "AD"
        ];
    }
    isInverseEra(date) {
        return date.era === "BC";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BC" ? "AD" : "BC";
            date.year = 1 - date.year;
        }
    }
    constructor(){
        this.identifier = "gregory";
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Data from https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/weekData.json
// Locales starting on Sunday have been removed for compression.
const $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BY: 1,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    HR: 1,
    HU: 1,
    IE: 1,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JO: 6,
    KG: 1,
    KW: 6,
    KZ: 1,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MK: 1,
    MN: 1,
    MQ: 1,
    MV: 5,
    MY: 1,
    NL: 1,
    NO: 1,
    NZ: 1,
    OM: 6,
    PL: 1,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SD: 6,
    SE: 1,
    SI: 1,
    SK: 1,
    SM: 1,
    SY: 6,
    TJ: 1,
    TM: 1,
    TR: 1,
    UA: 1,
    UY: 1,
    UZ: 1,
    VA: 1,
    VN: 1,
    XK: 1
};
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {
    b = $11d87f3f76e88657$export$b4a036af3fc0b032(b, a.calendar);
    return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b) {
    b = $11d87f3f76e88657$export$b4a036af3fc0b032(b, a.calendar);
    // In the Japanese calendar, months can span multiple eras/years, so only compare the first of the month.
    a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);
    b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);
    return a.era === b.era && a.year === b.year && a.month === b.month;
}
function $14e0f24ef4ac5c92$export$5841f9eb9773f25f(a, b) {
    b = $11d87f3f76e88657$export$b4a036af3fc0b032(b, a.calendar);
    a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);
    b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);
    return a.era === b.era && a.year === b.year;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(a, b) {
    a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);
    b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month;
}
function $14e0f24ef4ac5c92$export$ea840f5a6dda8147(a, b) {
    a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);
    b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    // If julian is negative, then julian % 7 will be negative, so we adjust
    // accordingly.  Julian day 0 is Monday.
    let dayOfWeek = Math.ceil(julian + 1 - $14e0f24ef4ac5c92$var$getWeekStart(locale)) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
    return $11d87f3f76e88657$export$1b96692a1ba042ac(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
    return $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {
    return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {
    return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);
}
function $14e0f24ef4ac5c92$var$timeToMs(a) {
    return a.hour * 3600000 + a.minute * 60000 + a.second * 1000 + a.millisecond;
}
function $14e0f24ef4ac5c92$export$126c91c941de7e(a, timeZone) {
    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(a, timeZone);
    let tomorrow = a.add({
        days: 1
    });
    let tomorrowMs = $11d87f3f76e88657$export$5107c82f94518f5c(tomorrow, timeZone);
    return (tomorrowMs - ms) / 3600000;
}
let $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
    // TODO: invalidate this somehow?
    if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
    // Use `subtract` instead of `set` so we don't get constrained in an era.
    return date.subtract({
        days: date.day - 1
    });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
    return date.add({
        days: date.calendar.getDaysInMonth(date) - date.day
    });
}
function $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {
    return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({
        months: date.month - 1
    }));
}
function $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {
    return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({
        months: date.calendar.getMonthsInYear(date) - date.month
    }));
}
function $14e0f24ef4ac5c92$export$5412ac11713b72ad(date) {
    if (date.calendar.getMinimumMonthInYear) return date.calendar.getMinimumMonthInYear(date);
    return 1;
}
function $14e0f24ef4ac5c92$export$b2f4953d301981d5(date) {
    if (date.calendar.getMinimumDayInMonth) return date.calendar.getMinimumDayInMonth(date);
    return 1;
}
function $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale) {
    let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
    return date.subtract({
        days: dayOfWeek
    });
}
function $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale) {
    return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale).add({
        days: 6
    });
}
const $14e0f24ef4ac5c92$var$cachedRegions = new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
    // If the Intl.Locale API is available, use it to get the region for the locale.
    // @ts-ignore
    if (Intl.Locale) {
        // Constructing an Intl.Locale is expensive, so cache the result.
        let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
        if (!region) {
            // @ts-ignore
            region = new Intl.Locale(locale).maximize().region;
            if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
        }
        return region;
    }
    // If not, just try splitting the string.
    // If the second part of the locale string is 'u',
    // then this is a unicode extension, so ignore it.
    // Otherwise, it should be the region.
    let part = locale.split("-")[1];
    return part === "u" ? undefined : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
    // TODO: use Intl.Locale for this once browsers support the weekInfo property
    // https://github.com/tc39/proposal-intl-locale-info
    let region = $14e0f24ef4ac5c92$var$getRegion(locale);
    return region ? $2fe286d2fb449abb$export$7a5acbd77d414bd9[region] || 0 : 0;
}
function $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale) {
    let days = date.calendar.getDaysInMonth(date);
    return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale) + days) / 7);
}
function $14e0f24ef4ac5c92$export$5c333a116e949cdd(a, b) {
    if (a && b) return a.compare(b) <= 0 ? a : b;
    return a || b;
}
function $14e0f24ef4ac5c92$export$a75f2bff57811055(a, b) {
    if (a && b) return a.compare(b) >= 0 ? a : b;
    return a || b;
}
const $14e0f24ef4ac5c92$var$WEEKEND_DATA = {
    AF: [
        4,
        5
    ],
    AE: [
        5,
        6
    ],
    BH: [
        5,
        6
    ],
    DZ: [
        5,
        6
    ],
    EG: [
        5,
        6
    ],
    IL: [
        5,
        6
    ],
    IQ: [
        5,
        6
    ],
    IR: [
        5,
        5
    ],
    JO: [
        5,
        6
    ],
    KW: [
        5,
        6
    ],
    LY: [
        5,
        6
    ],
    OM: [
        5,
        6
    ],
    QA: [
        5,
        6
    ],
    SA: [
        5,
        6
    ],
    SD: [
        5,
        6
    ],
    SY: [
        5,
        6
    ],
    YE: [
        5,
        6
    ]
};
function $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    // If julian is negative, then julian % 7 will be negative, so we adjust
    // accordingly.  Julian day 0 is Monday.
    let dayOfWeek = Math.ceil(julian + 1) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    let region = $14e0f24ef4ac5c92$var$getRegion(locale);
    // Use Intl.Locale for this once weekInfo is supported.
    // https://github.com/tc39/proposal-intl-locale-info
    let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [
        6,
        0
    ];
    return dayOfWeek === start || dayOfWeek === end;
}
function $14e0f24ef4ac5c92$export$ee9d87258e1d19ed(date, locale) {
    return !$14e0f24ef4ac5c92$export$618d60ea299da42(date, locale);
}
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
    date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
    let year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(date.era, date.year);
    return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
    // Note: Date.UTC() interprets one and two-digit years as being in the
    // 20th century, so don't use it
    let date = new Date();
    date.setUTCHours(hour, minute, second, millisecond);
    date.setUTCFullYear(year, month - 1, day);
    return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
    // Fast path for UTC.
    if (timeZone === "UTC") return 0;
    // Fast path: for local timezone after 1970, use native Date.
    if (ms > 0 && timeZone === $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) return new Date(ms).getTimezoneOffset() * -60000;
    let { year: year , month: month , day: day , hour: hour , minute: minute , second: second  } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
    let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
    return utc - Math.floor(ms / 1000) * 1000;
}
const $11d87f3f76e88657$var$formattersByTimeZone = new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
    let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat("en-US", {
            timeZone: timeZone,
            hour12: false,
            era: "short",
            year: "numeric",
            month: "numeric",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
        });
        $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
    }
    let parts = formatter.formatToParts(new Date(ms));
    let namedParts = {};
    for (let part of parts)if (part.type !== "literal") namedParts[part.type] = part.value;
    return {
        // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
        year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
        month: +namedParts.month,
        day: +namedParts.day,
        hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
        minute: +namedParts.minute,
        second: +namedParts.second
    };
}
const $11d87f3f76e88657$var$DAYMILLIS = 86400000;
function $11d87f3f76e88657$export$136f38efe7caf549(date, timeZone) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date);
    let earlier = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let later = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    return $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later);
}
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
    let found = earlier === later ? [
        earlier
    ] : [
        earlier,
        later
    ];
    return found.filter((absolute)=>$11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
    let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
    let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
    // Fast path: if the time zone is UTC, use native Date.
    if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
    // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.
    if (timeZone === $14e0f24ef4ac5c92$export$aa8b41735afcabd2() && disambiguation === "compatible") {
        dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
        // Don't use Date constructor here because two-digit years are interpreted in the 20th century.
        let date1 = new Date();
        let year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(dateTime.era, dateTime.year);
        date1.setFullYear(year, dateTime.month - 1, dateTime.day);
        date1.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
        return date1.getTime();
    }
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
    let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
    if (valid.length === 1) return valid[0];
    if (valid.length > 1) switch(disambiguation){
        // 'compatible' means 'earlier' for "fall back" transitions
        case "compatible":
        case "earlier":
            return valid[0];
        case "later":
            return valid[valid.length - 1];
        case "reject":
            throw new RangeError("Multiple possible absolute times found");
    }
    switch(disambiguation){
        case "earlier":
            return Math.min(ms - offsetBefore, ms - offsetAfter);
        // 'compatible' means 'later' for "spring forward" transitions
        case "compatible":
        case "later":
            return Math.max(ms - offsetBefore, ms - offsetAfter);
        case "reject":
            throw new RangeError("No such absolute time found");
    }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
    return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
    let offset = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
    let date = new Date(ms + offset);
    let year = date.getUTCFullYear();
    let month = date.getUTCMonth() + 1;
    let day = date.getUTCDate();
    let hour = date.getUTCHours();
    let minute = date.getUTCMinutes();
    let second = date.getUTCSeconds();
    let millisecond = date.getUTCMilliseconds();
    return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(year, month, day, timeZone, offset, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$e57ff100d91bd4b9(date, timeZone) {
    return $11d87f3f76e88657$export$1b96692a1ba042ac(date.getTime(), timeZone);
}
function $11d87f3f76e88657$export$d7f92bcd3596b086(date) {
    return $11d87f3f76e88657$export$e57ff100d91bd4b9(date, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$6f4d78149f3f53ac(date) {
    return {
        era: date.era,
        year: date.year,
        month: date.month,
        day: date.day
    };
}
function $11d87f3f76e88657$export$4d0393e732857be5(date) {
    return {
        hour: date.hour,
        minute: date.minute,
        second: date.second,
        millisecond: date.millisecond
    };
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
    let hour = 0, minute = 0, second = 0, millisecond = 0;
    if ("timeZone" in date) ({ hour: hour , minute: minute , second: second , millisecond: millisecond  } = date);
    else if ("hour" in date && !time) return date;
    if (time) ({ hour: hour , minute: minute , second: second , millisecond: millisecond  } = time);
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$d33f79e3ffc3dc83(dateTime) {
    return new $35ea8db9cb2ccb90$export$680ea196effce5f(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
    if (date.calendar.identifier === calendar.identifier) return date;
    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
    let copy = date.copy();
    copy.calendar = calendar;
    copy.era = calendarDate.era;
    copy.year = calendarDate.year;
    copy.month = calendarDate.month;
    copy.day = calendarDate.day;
    $735220c2d4774dd3$export$c4e2ecac49351ef2(copy);
    return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
    if (date instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
        if (date.timeZone === timeZone) return date;
        return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
    }
    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
    return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}
function $11d87f3f76e88657$export$d9b67bc93c097491(date) {
    return $11d87f3f76e88657$export$538b00033cc11c75(date, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
const $735220c2d4774dd3$var$ONE_HOUR = 3600000;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
    let mutableDate = date.copy();
    let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
    $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
    mutableDate.month += duration.months || 0;
    $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
    $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
    mutableDate.day += (duration.weeks || 0) * 7;
    mutableDate.day += duration.days || 0;
    mutableDate.day += days;
    $735220c2d4774dd3$var$balanceDay(mutableDate);
    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
    // Constrain in case adding ended up with a date outside the valid range for the calendar system.
    // The behavior here is slightly different than when constraining in the `set` function in that
    // we adjust smaller fields to their minimum/maximum values rather than constraining each field
    // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.
    if (mutableDate.year < 1) {
        mutableDate.year = 1;
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
    if (mutableDate.year > maxYear) {
        var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
        let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
        mutableDate.year = maxYear;
        mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
        mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    if (mutableDate.month < 1) {
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
    if (mutableDate.month > maxMonth) {
        mutableDate.month = maxMonth;
        mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
    return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
    var _date_calendar_isInverseEra, _date_calendar;
    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
    date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
    while(date.month < 1){
        $735220c2d4774dd3$var$addYears(date, -1);
        date.month += date.calendar.getMonthsInYear(date);
    }
    let monthsInYear = 0;
    while(date.month > (monthsInYear = date.calendar.getMonthsInYear(date))){
        date.month -= monthsInYear;
        $735220c2d4774dd3$var$addYears(date, 1);
    }
}
function $735220c2d4774dd3$var$balanceDay(date) {
    while(date.day < 1){
        date.month--;
        $735220c2d4774dd3$var$balanceYearMonth(date);
        date.day += date.calendar.getDaysInMonth(date);
    }
    while(date.day > date.calendar.getDaysInMonth(date)){
        date.day -= date.calendar.getDaysInMonth(date);
        date.month++;
        $735220c2d4774dd3$var$balanceYearMonth(date);
    }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
    if (date.calendar.constrainDate) date.calendar.constrainDate(date);
    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
    $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
    let inverseDuration = {};
    for(let key in duration)if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
    return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
    return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
    let mutableDate = date.copy();
    if (fields.era != null) mutableDate.era = fields.era;
    if (fields.year != null) mutableDate.year = fields.year;
    if (fields.month != null) mutableDate.month = fields.month;
    if (fields.day != null) mutableDate.day = fields.day;
    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
    return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
    let mutableValue = value.copy();
    if (fields.hour != null) mutableValue.hour = fields.hour;
    if (fields.minute != null) mutableValue.minute = fields.minute;
    if (fields.second != null) mutableValue.second = fields.second;
    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
    $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
    return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
    time.second += Math.floor(time.millisecond / 1000);
    time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1000);
    time.minute += Math.floor(time.second / 60);
    time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
    time.hour += Math.floor(time.minute / 60);
    time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
    let days = Math.floor(time.hour / 24);
    time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
    return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
    time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));
    time.second = Math.max(0, Math.min(time.second, 59));
    time.minute = Math.max(0, Math.min(time.minute, 59));
    time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a, b) {
    let result = a % b;
    if (result < 0) result += b;
    return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
    time.hour += duration.hours || 0;
    time.minute += duration.minutes || 0;
    time.second += duration.seconds || 0;
    time.millisecond += duration.milliseconds || 0;
    return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
    let res = time.copy();
    $735220c2d4774dd3$var$addTimeFields(res, duration);
    return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
    return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "era":
            {
                let eras = value.calendar.getEras();
                let eraIndex = eras.indexOf(value.era);
                if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
                eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
                mutable.era = eras[eraIndex];
                // Constrain the year and other fields within the era, so the era doesn't change when we balance below.
                $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
                break;
            }
        case "year":
            var _mutable_calendar_isInverseEra, _mutable_calendar;
            if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
            // The year field should not cycle within the era as that can cause weird behavior affecting other fields.
            // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back
            // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.
            mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
            if (mutable.year === -Infinity) mutable.year = 1;
            if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
            break;
        case "month":
            mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        case "day":
            mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
    return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "hour":
            {
                let hours = value.hour;
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = hours >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);
                break;
            }
        case "minute":
            mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "second":
            mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "millisecond":
            mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min, max, round = false) {
    if (round) {
        value += Math.sign(amount);
        if (value < min) value = max;
        let div = Math.abs(amount);
        if (amount > 0) value = Math.ceil(value / div) * div;
        else value = Math.floor(value / div) * div;
        if (value > max) value = min;
    } else {
        value += amount;
        if (value < min) value = max - (min - value - 1);
        else if (value > max) value = min + (value - max - 1);
    }
    return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
    let ms;
    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
        let res = $735220c2d4774dd3$export$e16d8520af44a096($11d87f3f76e88657$export$b21e0b124e224484(dateTime), {
            years: duration.years,
            months: duration.months,
            weeks: duration.weeks,
            days: duration.days
        });
        // Changing the date may change the timezone offset, so we need to recompute
        // using the 'compatible' disambiguation.
        ms = $11d87f3f76e88657$export$5107c82f94518f5c(res, dateTime.timeZone);
    } else ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime) - dateTime.offset;
    // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.
    // For example, adding one hour during a DST transition may result in the hour field staying the same or
    // skipping an hour. This results in the offset field changing value instead of the specified field.
    ms += duration.milliseconds || 0;
    ms += (duration.seconds || 0) * 1000;
    ms += (duration.minutes || 0) * 60000;
    ms += (duration.hours || 0) * 3600000;
    let res1 = $11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone);
    return $11d87f3f76e88657$export$b4a036af3fc0b032(res1, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
    return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
    // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.
    // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC
    // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.
    switch(field){
        case "hour":
            {
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = dateTime.hour >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                // The minimum and maximum hour may be affected by daylight saving time.
                // For example, it might jump forward at midnight, and skip 1am.
                // Or it might end at midnight and repeat the 11pm hour. To handle this, we get
                // the possible absolute times for the min and max, and find the maximum range
                // that is within the current day.
                let plainDateTime = $11d87f3f76e88657$export$b21e0b124e224484(dateTime);
                let minDate = $11d87f3f76e88657$export$b4a036af3fc0b032($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: min
                }), new $3b62074eb05584b2$export$80ee6245ec4f29ec());
                let minAbsolute = [
                    $11d87f3f76e88657$export$5107c82f94518f5c(minDate, dateTime.timeZone, "earlier"),
                    $11d87f3f76e88657$export$5107c82f94518f5c(minDate, dateTime.timeZone, "later")
                ].filter((ms)=>$11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone).day === minDate.day)[0];
                let maxDate = $11d87f3f76e88657$export$b4a036af3fc0b032($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: max
                }), new $3b62074eb05584b2$export$80ee6245ec4f29ec());
                let maxAbsolute = [
                    $11d87f3f76e88657$export$5107c82f94518f5c(maxDate, dateTime.timeZone, "earlier"),
                    $11d87f3f76e88657$export$5107c82f94518f5c(maxDate, dateTime.timeZone, "later")
                ].filter((ms)=>$11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone).day === maxDate.day).pop();
                // Since hours may repeat, we need to operate on the absolute time in milliseconds.
                // This is done in hours from the Unix epoch so that cycleValue works correctly,
                // and then converted back to milliseconds.
                let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime) - dateTime.offset;
                let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
                let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
                ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
                // Now compute the new timezone offset, and convert the absolute time back to local time.
                return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone), dateTime.calendar);
            }
        case "minute":
        case "second":
        case "millisecond":
            // @ts-ignore
            return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
        case "era":
        case "year":
        case "month":
        case "day":
            {
                let res = $735220c2d4774dd3$export$d52ced6badfb9a4c($11d87f3f76e88657$export$b21e0b124e224484(dateTime), field, amount, options);
                let ms1 = $11d87f3f76e88657$export$5107c82f94518f5c(res, dateTime.timeZone);
                return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms1, dateTime.timeZone), dateTime.calendar);
            }
        default:
            throw new Error("Unsupported field " + field);
    }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
    // Set the date/time fields, and recompute the UTC offset to account for DST changes.
    // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.
    let plainDateTime = $11d87f3f76e88657$export$b21e0b124e224484(dateTime);
    let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
    // If the resulting plain date time values are equal, return the original time.
    // We don't want to change the offset when setting the time to the same value.
    if (res.compare(plainDateTime) === 0) return dateTime;
    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(res, dateTime.timeZone, disambiguation);
    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone), dateTime.calendar);
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $fae977aafc393c5c$var$TIME_RE = /^(\d{2})(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $fae977aafc393c5c$var$DATE_RE = /^(\d{4})-(\d{2})-(\d{2})$/;
const $fae977aafc393c5c$var$DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $fae977aafc393c5c$var$ZONED_DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?)?\[(.*?)\]$/;
const $fae977aafc393c5c$var$ABSOLUTE_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
const $fae977aafc393c5c$var$DATE_TIME_DURATION_RE = /^((?<negative>-)|\+)?P((?<years>\d*)Y)?((?<months>\d*)M)?((?<weeks>\d*)W)?((?<days>\d*)D)?((?<time>T)((?<hours>\d*[.,]?\d{1,9})H)?((?<minutes>\d*[.,]?\d{1,9})M)?((?<seconds>\d*[.,]?\d{1,9})S)?)?$/;
const $fae977aafc393c5c$var$requiredDurationTimeGroups = [
    "hours",
    "minutes",
    "seconds"
];
const $fae977aafc393c5c$var$requiredDurationGroups = [
    "years",
    "months",
    "weeks",
    "days",
    ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$c9698ec7f05a07e1(value) {
    let m = value.match($fae977aafc393c5c$var$TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 time string: " + value);
    return new $35ea8db9cb2ccb90$export$680ea196effce5f($fae977aafc393c5c$var$parseNumber(m[1], 0, 23), m[2] ? $fae977aafc393c5c$var$parseNumber(m[2], 0, 59) : 0, m[3] ? $fae977aafc393c5c$var$parseNumber(m[3], 0, 59) : 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, Infinity) * 1000 : 0);
}
function $fae977aafc393c5c$export$6b862160d295c8e(value) {
    let m = value.match($fae977aafc393c5c$var$DATE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date string: " + value);
    let date = new $35ea8db9cb2ccb90$export$99faa760c7908e4f($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
}
function $fae977aafc393c5c$export$588937bcd60ade55(value) {
    let m = value.match($fae977aafc393c5c$var$DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new $35ea8db9cb2ccb90$export$ca871e8dbb80966f($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
}
function $fae977aafc393c5c$export$fd7893f06e92a6a4(value, disambiguation) {
    let m = value.match($fae977aafc393c5c$var$ZONED_DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new $35ea8db9cb2ccb90$export$d3b7288e7994edea($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    let plainDateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
    let ms;
    if (m[8]) {
        var _m_;
        date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 3600000 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 60000;
        ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
        // Validate offset against parsed date.
        let absolutes = $11d87f3f76e88657$export$136f38efe7caf549(plainDateTime, date.timeZone);
        if (!absolutes.includes(ms)) throw new Error(`Offset ${$fae977aafc393c5c$var$offsetToString(date.offset)} is invalid for ${$fae977aafc393c5c$export$4223de14708adc63(date)} in ${date.timeZone}`);
    } else ms = $11d87f3f76e88657$export$5107c82f94518f5c($11d87f3f76e88657$export$b21e0b124e224484(plainDateTime), date.timeZone, disambiguation);
    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, date.timeZone);
}
function $fae977aafc393c5c$export$5adfdab05168c219(value, timeZone) {
    let m = value.match($fae977aafc393c5c$var$ABSOLUTE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new $35ea8db9cb2ccb90$export$d3b7288e7994edea($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, timeZone, 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    var _m_;
    if (m[8]) date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 3600000 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 60000;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
}
function $fae977aafc393c5c$export$8e384432362ed0f0(value) {
    return $fae977aafc393c5c$export$5adfdab05168c219(value, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function $fae977aafc393c5c$var$parseNumber(value, min, max) {
    let val = Number(value);
    if (val < min || val > max) throw new RangeError(`Value out of range: ${min} <= ${val} <= ${max}`);
    return val;
}
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
    return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1000).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
    let gregorianDate = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
    return `${String(gregorianDate.year).padStart(4, "0")}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
    // @ts-ignore
    return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset) {
    let sign = Math.sign(offset) < 0 ? "-" : "+";
    offset = Math.abs(offset);
    let offsetHours = Math.floor(offset / 3600000);
    let offsetMinutes = offset % 3600000 / 60000;
    return `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
    return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}
function $fae977aafc393c5c$export$ecae829bb3747ea6(value) {
    var _match_groups, _match_groups1, _match_groups2, _match_groups3, _match_groups4, _match_groups5, _match_groups6, _match_groups7, _match_groups8;
    const match = value.match($fae977aafc393c5c$var$DATE_TIME_DURATION_RE);
    if (!match) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    const parseDurationGroup = (group, isNegative, min, max)=>{
        if (!group) return 0;
        try {
            const sign = isNegative ? -1 : 1;
            return sign * $fae977aafc393c5c$var$parseNumber(group.replace(",", "."), min, max);
        } catch  {
            throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
        }
    };
    const isNegative = !!((_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups.negative);
    const hasRequiredGroups = $fae977aafc393c5c$var$requiredDurationGroups.some((group)=>{
        var _match_groups;
        return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];
    });
    if (!hasRequiredGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    const durationStringIncludesTime = (_match_groups1 = match.groups) === null || _match_groups1 === void 0 ? void 0 : _match_groups1.time;
    if (durationStringIncludesTime) {
        const hasRequiredDurationTimeGroups = $fae977aafc393c5c$var$requiredDurationTimeGroups.some((group)=>{
            var _match_groups;
            return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];
        });
        if (!hasRequiredDurationTimeGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    }
    const duration = {
        years: parseDurationGroup((_match_groups2 = match.groups) === null || _match_groups2 === void 0 ? void 0 : _match_groups2.years, isNegative, 0, 9999),
        months: parseDurationGroup((_match_groups3 = match.groups) === null || _match_groups3 === void 0 ? void 0 : _match_groups3.months, isNegative, 0, 12),
        weeks: parseDurationGroup((_match_groups4 = match.groups) === null || _match_groups4 === void 0 ? void 0 : _match_groups4.weeks, isNegative, 0, Infinity),
        days: parseDurationGroup((_match_groups5 = match.groups) === null || _match_groups5 === void 0 ? void 0 : _match_groups5.days, isNegative, 0, 31),
        hours: parseDurationGroup((_match_groups6 = match.groups) === null || _match_groups6 === void 0 ? void 0 : _match_groups6.hours, isNegative, 0, 23),
        minutes: parseDurationGroup((_match_groups7 = match.groups) === null || _match_groups7 === void 0 ? void 0 : _match_groups7.minutes, isNegative, 0, 59),
        seconds: parseDurationGroup((_match_groups8 = match.groups) === null || _match_groups8 === void 0 ? void 0 : _match_groups8.seconds, isNegative, 0, 59)
    };
    if (duration.hours !== undefined && duration.hours % 1 !== 0 && (duration.minutes || duration.seconds)) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);
    if (duration.minutes !== undefined && duration.minutes % 1 !== 0 && duration.seconds) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);
    return duration;
}
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
    let calendar = typeof args[0] === "object" ? args.shift() : new $3b62074eb05584b2$export$80ee6245ec4f29ec();
    let era;
    if (typeof args[0] === "string") era = args.shift();
    else {
        let eras = calendar.getEras();
        era = eras[eras.length - 1];
    }
    let year = args.shift();
    let month = args.shift();
    let day = args.shift();
    return [
        calendar,
        era,
        year,
        month,
        day
    ];
}
var // i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.
// If that behavior is desired, use the AnyCalendarDate interface instead.
// @ts-ignore
$35ea8db9cb2ccb90$var$_type = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$99faa760c7908e4f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
        else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
    }
    /** Returns a new `CalendarDate` with the given duration added to it. */ add(duration) {
        return $735220c2d4774dd3$export$e16d8520af44a096(this, duration);
    }
    /** Returns a new `CalendarDate` with the given duration subtracted from it. */ subtract(duration) {
        return $735220c2d4774dd3$export$4e2d2ead65e5f7e3(this, duration);
    }
    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return $735220c2d4774dd3$export$adaa4cf7ef1b65be(this, fields);
    }
    /**
   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return $735220c2d4774dd3$export$d52ced6badfb9a4c(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */ toDate(timeZone) {
        return $11d87f3f76e88657$export$e67a095c620b86fe(this, timeZone);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return $fae977aafc393c5c$export$60dfd74aa96791bd(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        return $14e0f24ef4ac5c92$export$68781ddf31c0090f(this, b);
    }
    constructor(...args){
        (0, _classPrivateFieldInit._)(this, $35ea8db9cb2ccb90$var$_type, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
    }
}
var // @ts-ignore
$35ea8db9cb2ccb90$var$_type1 = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$680ea196effce5f {
    /** Returns a copy of this time. */ copy() {
        return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `Time` with the given duration added to it. */ add(duration) {
        return $735220c2d4774dd3$export$7ed87b6bc2506470(this, duration);
    }
    /** Returns a new `Time` with the given duration subtracted from it. */ subtract(duration) {
        return $735220c2d4774dd3$export$fe34d3a381cd7501(this, duration);
    }
    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return $735220c2d4774dd3$export$e5d5e1c1822b6e56(this, fields);
    }
    /**
   * Returns a new `Time` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return $735220c2d4774dd3$export$dd02b3e0007dfe28(this, field, amount, options);
    }
    /** Converts the time to an ISO 8601 formatted string. */ toString() {
        return $fae977aafc393c5c$export$f59dee82248f5ad4(this);
    }
    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */ compare(b) {
        return $14e0f24ef4ac5c92$export$c19a80a9721b80f6(this, b);
    }
    constructor(hour = 0, minute = 0, second = 0, millisecond = 0){
        (0, _classPrivateFieldInit._)(this, $35ea8db9cb2ccb90$var$_type1, {
            writable: true,
            value: void 0
        });
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        $735220c2d4774dd3$export$7555de1e070510cb(this);
    }
}
var // @ts-ignore
$35ea8db9cb2ccb90$var$_type2 = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$ca871e8dbb80966f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
        else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `CalendarDateTime` with the given duration added to it. */ add(duration) {
        return $735220c2d4774dd3$export$e16d8520af44a096(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return $735220c2d4774dd3$export$4e2d2ead65e5f7e3(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return $735220c2d4774dd3$export$adaa4cf7ef1b65be($735220c2d4774dd3$export$e5d5e1c1822b6e56(this, fields), fields);
    }
    /**
   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        switch(field){
            case "era":
            case "year":
            case "month":
            case "day":
                return $735220c2d4774dd3$export$d52ced6badfb9a4c(this, field, amount, options);
            default:
                return $735220c2d4774dd3$export$dd02b3e0007dfe28(this, field, amount, options);
        }
    }
    /** Converts the date to a native JavaScript Date object in the given time zone. */ toDate(timeZone, disambiguation) {
        return $11d87f3f76e88657$export$e67a095c620b86fe(this, timeZone, disambiguation);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return $fae977aafc393c5c$export$4223de14708adc63(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        let res = $14e0f24ef4ac5c92$export$68781ddf31c0090f(this, b);
        if (res === 0) return $14e0f24ef4ac5c92$export$c19a80a9721b80f6(this, $11d87f3f76e88657$export$b21e0b124e224484(b));
        return res;
    }
    constructor(...args){
        (0, _classPrivateFieldInit._)(this, $35ea8db9cb2ccb90$var$_type2, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
    }
}
var // @ts-ignore
$35ea8db9cb2ccb90$var$_type3 = /*#__PURE__*/ new WeakMap();
class $35ea8db9cb2ccb90$export$d3b7288e7994edea {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
        else return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `ZonedDateTime` with the given duration added to it. */ add(duration) {
        return $735220c2d4774dd3$export$96b1d28349274637(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return $735220c2d4774dd3$export$6814caac34ca03c7(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields, disambiguation) {
        return $735220c2d4774dd3$export$31b5430eb18be4f8(this, fields, disambiguation);
    }
    /**
   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return $735220c2d4774dd3$export$9a297d111fc86b79(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object. */ toDate() {
        return $11d87f3f76e88657$export$83aac07b4c37b25(this);
    }
    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */ toString() {
        return $fae977aafc393c5c$export$bf79f1ebf4b18792(this);
    }
    /** Converts the date to an ISO 8601 formatted string in UTC. */ toAbsoluteString() {
        return this.toDate().toISOString();
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        // TODO: Is this a bad idea??
        return this.toDate().getTime() - $11d87f3f76e88657$export$84c95a83c799e074(b, this.timeZone).toDate().getTime();
    }
    constructor(...args){
        (0, _classPrivateFieldInit._)(this, $35ea8db9cb2ccb90$var$_type3, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
        let timeZone = args.shift();
        let offset = args.shift();
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.timeZone = timeZone;
        this.offset = offset;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $62225008020f0a13$var$ERA_START_DATES = [
    [
        1868,
        9,
        8
    ],
    [
        1912,
        7,
        30
    ],
    [
        1926,
        12,
        25
    ],
    [
        1989,
        1,
        8
    ],
    [
        2019,
        5,
        1
    ]
];
const $62225008020f0a13$var$ERA_END_DATES = [
    [
        1912,
        7,
        29
    ],
    [
        1926,
        12,
        24
    ],
    [
        1989,
        1,
        7
    ],
    [
        2019,
        4,
        30
    ]
];
const $62225008020f0a13$var$ERA_ADDENDS = [
    1867,
    1911,
    1925,
    1988,
    2018
];
const $62225008020f0a13$var$ERA_NAMES = [
    "meiji",
    "taisho",
    "showa",
    "heisei",
    "reiwa"
];
function $62225008020f0a13$var$findEraFromGregorianDate(date) {
    const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day])=>{
        if (date.year < year) return true;
        if (date.year === year && date.month < month) return true;
        if (date.year === year && date.month === month && date.day < day) return true;
        return false;
    });
    if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;
    if (idx === 0) return 0;
    return idx - 1;
}
function $62225008020f0a13$var$toGregorian(date) {
    let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];
    if (!eraAddend) throw new Error("Unknown era: " + date.era);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date.year + eraAddend, date.month, date.day);
}
class $62225008020f0a13$export$b746ab2b60cdffbf extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let date = super.fromJulianDay(jd);
        let era = $62225008020f0a13$var$findEraFromGregorianDate(date);
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($62225008020f0a13$var$toGregorian(date));
    }
    balanceDate(date) {
        let gregorianDate = $62225008020f0a13$var$toGregorian(date);
        let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);
        if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {
            date.era = $62225008020f0a13$var$ERA_NAMES[era];
            date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];
        }
        // Constrain in case we went before the first supported era.
        this.constrainDate(date);
    }
    constrainDate(date) {
        let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
        let end = $62225008020f0a13$var$ERA_END_DATES[idx];
        if (end != null) {
            let [endYear, endMonth, endDay] = end;
            // Constrain the year to the maximum possible value in the era.
            // Then constrain the month and day fields within that.
            let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];
            date.year = Math.max(1, Math.min(maxYear, date.year));
            if (date.year === maxYear) {
                date.month = Math.min(endMonth, date.month);
                if (date.month === endMonth) date.day = Math.min(endDay, date.day);
            }
        }
        if (date.year === 1 && idx >= 0) {
            let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];
            date.month = Math.max(startMonth, date.month);
            if (date.month === startMonth) date.day = Math.max(startDay, date.day);
        }
    }
    getEras() {
        return $62225008020f0a13$var$ERA_NAMES;
    }
    getYearsInEra(date) {
        // Get the number of years in the era, taking into account the date's month and day fields.
        let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
        let cur = $62225008020f0a13$var$ERA_START_DATES[era];
        let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];
        if (next == null) return 9999 - cur[0] + 1;
        let years = next[0] - cur[0];
        if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;
        return years;
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));
    }
    getMinimumMonthInYear(date) {
        let start = $62225008020f0a13$var$getMinimums(date);
        return start ? start[1] : 1;
    }
    getMinimumDayInMonth(date) {
        let start = $62225008020f0a13$var$getMinimums(date);
        return start && date.month === start[1] ? start[2] : 1;
    }
    constructor(...args){
        super(...args);
        this.identifier = "japanese";
    }
}
function $62225008020f0a13$var$getMinimums(date) {
    if (date.year === 1) {
        let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
        return $62225008020f0a13$var$ERA_START_DATES[idx];
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;
class $8d73d47422ca7302$export$42d20a78301dee44 extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let gregorianDate = super.fromJulianDay(jd);
        let year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(gregorianDate.era, gregorianDate.year);
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, year - $8d73d47422ca7302$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($8d73d47422ca7302$var$toGregorian(date));
    }
    getEras() {
        return [
            "BE"
        ];
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(date));
    }
    balanceDate() {}
    constructor(...args){
        super(...args);
        this.identifier = "buddhist";
    }
}
function $8d73d47422ca7302$var$toGregorian(date) {
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(date.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(era, year, date.month, date.day);
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;
function $5f31bd6f0c8940b2$var$gregorianYear(date) {
    return date.era === "minguo" ? date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
}
function $5f31bd6f0c8940b2$var$gregorianToTaiwan(year) {
    let y = year - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
    if (y > 0) return [
        "minguo",
        y
    ];
    else return [
        "before_minguo",
        1 - y
    ];
}
class $5f31bd6f0c8940b2$export$65e01080afcb0799 extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let date = super.fromJulianDay(jd);
        let extendedYear = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(date.era, date.year);
        let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan(extendedYear);
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, era, year, date.month, date.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(date));
    }
    getEras() {
        return [
            "before_minguo",
            "minguo"
        ];
    }
    balanceDate(date) {
        let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(date));
        date.era = era;
        date.year = year;
    }
    isInverseEra(date) {
        return date.era === "before_minguo";
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(date));
    }
    getYearsInEra(date) {
        return date.era === "before_minguo" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
    }
    constructor(...args){
        super(...args);
        this.identifier = "roc" // Republic of China
        ;
    }
}
function $5f31bd6f0c8940b2$var$toGregorian(date) {
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c($5f31bd6f0c8940b2$var$gregorianYear(date));
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(era, year, date.month, date.day);
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948321; // 622/03/19 Julian C.E.
function $f3ed2e4472ae7e25$var$isLeapYear(year) {
    let y0 = year > 0 ? year - 474 : year - 473;
    let y1 = $2b4dce13dd5a17fa$export$842a2cf37af977e1(y0, 2820) + 474;
    return $2b4dce13dd5a17fa$export$842a2cf37af977e1((y1 + 38) * 31, 128) < 31;
}
function $f3ed2e4472ae7e25$var$persianToJulianDay(year, month, day) {
    let y0 = year > 0 ? year - 474 : year - 473;
    let y1 = $2b4dce13dd5a17fa$export$842a2cf37af977e1(y0, 2820) + 474;
    let offset = month <= 7 ? 31 * (month - 1) : 30 * (month - 1) + 6;
    return $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 1029983 * Math.floor(y0 / 2820) + 365 * (y1 - 1) + Math.floor((31 * y1 - 5) / 128) + offset + day;
}
class $f3ed2e4472ae7e25$export$37fccdbfd14c5939 {
    fromJulianDay(jd) {
        let d0 = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(475, 1, 1);
        let n2820 = Math.floor(d0 / 1029983);
        let d1 = $2b4dce13dd5a17fa$export$842a2cf37af977e1(d0, 1029983);
        let y2820 = d1 === 1029982 ? 2820 : Math.floor((128 * d1 + 46878) / 46751);
        let year = 474 + 2820 * n2820 + y2820;
        if (year <= 0) year--;
        let yDay = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(year, 1, 1) + 1;
        let month = yDay <= 186 ? Math.ceil(yDay / 31) : Math.ceil((yDay - 6) / 31);
        let day = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(year, month, 1) + 1;
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, year, month, day);
    }
    toJulianDay(date) {
        return $f3ed2e4472ae7e25$var$persianToJulianDay(date.year, date.month, date.day);
    }
    getMonthsInYear() {
        return 12;
    }
    getDaysInMonth(date) {
        if (date.month <= 6) return 31;
        if (date.month <= 11) return 30;
        return $f3ed2e4472ae7e25$var$isLeapYear(date.year) ? 30 : 29;
    }
    getEras() {
        return [
            "AP"
        ];
    }
    getYearsInEra() {
        // 9378-10-10 persian is 9999-12-31 gregorian.
        // Round down to 9377 to set the maximum full year.
        return 9377;
    }
    constructor(){
        this.identifier = "persian";
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
// Starts in 78 AD,
const $82c358003bdda0a8$var$INDIAN_ERA_START = 78;
// The Indian year starts 80 days later than the Gregorian year.
const $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;
class $82c358003bdda0a8$export$39f31c639fa15726 extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        // Gregorian date for Julian day
        let date = super.fromJulianDay(jd);
        // Year in Saka era
        let indianYear = date.year - $82c358003bdda0a8$var$INDIAN_ERA_START;
        // Day number in Gregorian year (starting from 0)
        let yDay = jd - $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, 1, 1);
        let leapMonth;
        if (yDay < $82c358003bdda0a8$var$INDIAN_YEAR_START) {
            //  Day is at the end of the preceding Saka year
            indianYear--;
            // Days in leapMonth this year, previous Gregorian year
            leapMonth = $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year - 1) ? 31 : 30;
            yDay += leapMonth + 155 + 90 + 10;
        } else {
            // Days in leapMonth this year
            leapMonth = $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 31 : 30;
            yDay -= $82c358003bdda0a8$var$INDIAN_YEAR_START;
        }
        let indianMonth;
        let indianDay;
        if (yDay < leapMonth) {
            indianMonth = 1;
            indianDay = yDay + 1;
        } else {
            let mDay = yDay - leapMonth;
            if (mDay < 155) {
                indianMonth = Math.floor(mDay / 31) + 2;
                indianDay = mDay % 31 + 1;
            } else {
                mDay -= 155;
                indianMonth = Math.floor(mDay / 30) + 7;
                indianDay = mDay % 30 + 1;
            }
        }
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, indianYear, indianMonth, indianDay);
    }
    toJulianDay(date) {
        let extendedYear = date.year + $82c358003bdda0a8$var$INDIAN_ERA_START;
        let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
        let leapMonth;
        let jd;
        if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) {
            leapMonth = 31;
            jd = $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 21);
        } else {
            leapMonth = 30;
            jd = $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 22);
        }
        if (date.month === 1) return jd + date.day - 1;
        jd += leapMonth + Math.min(date.month - 2, 5) * 31;
        if (date.month >= 8) jd += (date.month - 7) * 30;
        jd += date.day - 1;
        return jd;
    }
    getDaysInMonth(date) {
        if (date.month === 1 && $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year + $82c358003bdda0a8$var$INDIAN_ERA_START)) return 31;
        if (date.month >= 2 && date.month <= 6) return 31;
        return 30;
    }
    getYearsInEra() {
        // 9999-12-31 gregorian is 9920-10-10 indian.
        // Round down to 9919 for the last full year.
        return 9919;
    }
    getEras() {
        return [
            "saka"
        ];
    }
    balanceDate() {}
    constructor(...args){
        super(...args);
        this.identifier = "indian";
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)
const $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)
const $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300;
const $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600;
const $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;
function $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, day) {
    return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}
function $f2f3e0e3a817edbd$var$julianDayToIslamic(calendar, epoch, jd) {
    let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
    let month = Math.min(12, Math.ceil((jd - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
    let day = jd - $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, 1) + 1;
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(calendar, year, month, day);
}
function $f2f3e0e3a817edbd$var$isLeapYear(year) {
    return (14 + 11 * year) % 30 < 11;
}
class $f2f3e0e3a817edbd$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, jd);
    }
    toJulianDay(date) {
        return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        let length = 29 + date.month % 2;
        if (date.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(date.year)) length++;
        return length;
    }
    getMonthsInYear() {
        return 12;
    }
    getDaysInYear(date) {
        return $f2f3e0e3a817edbd$var$isLeapYear(date.year) ? 355 : 354;
    }
    getYearsInEra() {
        // 9999 gregorian
        return 9665;
    }
    getEras() {
        return [
            "AH"
        ];
    }
    constructor(){
        this.identifier = "islamic-civil";
    }
}
class $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, jd);
    }
    toJulianDay(date) {
        return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);
    }
    constructor(...args){
        super(...args);
        this.identifier = "islamic-tbla";
    }
}
// Generated by scripts/generate-umalqura.js
const $f2f3e0e3a817edbd$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH;
let $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;
function $f2f3e0e3a817edbd$var$umalquraYearStart(year) {
    return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
function $f2f3e0e3a817edbd$var$umalquraMonthLength(year, month) {
    let idx = year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START;
    let mask = 0x01 << 11 - (month - 1);
    if (($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;
    else return 30;
}
function $f2f3e0e3a817edbd$var$umalquraMonthStart(year, month) {
    let day = $f2f3e0e3a817edbd$var$umalquraYearStart(year);
    for(let i = 1; i < month; i++)day += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);
    return day;
}
function $f2f3e0e3a817edbd$var$umalquraYearLength(year) {
    return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
class $f2f3e0e3a817edbd$export$5baab4758c231076 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        let days = jd - $f2f3e0e3a817edbd$var$CIVIL_EPOC;
        let startDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START);
        let endDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);
        if (days < startDays || days > endDays) return super.fromJulianDay(jd);
        else {
            let y = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1;
            let m = 1;
            let d = 1;
            while(d > 0){
                y++;
                d = days - $f2f3e0e3a817edbd$var$umalquraYearStart(y) + 1;
                let yearLength = $f2f3e0e3a817edbd$var$umalquraYearLength(y);
                if (d === yearLength) {
                    m = 12;
                    break;
                } else if (d < yearLength) {
                    let monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);
                    m = 1;
                    while(d > monthLength){
                        d -= monthLength;
                        m++;
                        monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);
                    }
                    break;
                }
            }
            return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, y, m, days - $f2f3e0e3a817edbd$var$umalquraMonthStart(y, m) + 1);
        }
    }
    toJulianDay(date) {
        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.toJulianDay(date);
        return $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);
    }
    getDaysInMonth(date) {
        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);
        return $f2f3e0e3a817edbd$var$umalquraMonthLength(date.year, date.month);
    }
    getDaysInYear(date) {
        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);
        return $f2f3e0e3a817edbd$var$umalquraYearLength(date.year);
    }
    constructor(){
        super();
        this.identifier = "islamic-umalqura";
        if (!$f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH) $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (c)=>c.charCodeAt(0)).buffer);
        if (!$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {
            $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);
            let yearStart = 0;
            for(let year = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; year <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; year++){
                $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = yearStart;
                for(let i = 1; i <= 12; i++)yearStart += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);
            }
        }
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997;
// Hebrew date calculations are performed in terms of days, hours, and
// "parts" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.
const $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
const $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
// An approximate value for the length of a lunar month.
// It is used to calculate the approximate year and month of a given
// absolute date.
const $7c5f6fbf42389787$var$MONTH_DAYS = 29;
const $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
const $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;
function $7c5f6fbf42389787$var$isLeapYear(year) {
    return $2b4dce13dd5a17fa$export$842a2cf37af977e1(year * 7 + 1, 19) < 7;
}
// Test for delay of start of new year and to avoid
// Sunday, Wednesday, and Friday as start of the new year.
function $7c5f6fbf42389787$var$hebrewDelay1(year) {
    let months = Math.floor((235 * year - 234) / 19);
    let parts = 12084 + 13753 * months;
    let day = months * 29 + Math.floor(parts / 25920);
    if ($2b4dce13dd5a17fa$export$842a2cf37af977e1(3 * (day + 1), 7) < 3) day += 1;
    return day;
}
// Check for delay in start of new year due to length of adjacent years
function $7c5f6fbf42389787$var$hebrewDelay2(year) {
    let last = $7c5f6fbf42389787$var$hebrewDelay1(year - 1);
    let present = $7c5f6fbf42389787$var$hebrewDelay1(year);
    let next = $7c5f6fbf42389787$var$hebrewDelay1(year + 1);
    if (next - present === 356) return 2;
    if (present - last === 382) return 1;
    return 0;
}
function $7c5f6fbf42389787$var$startOfYear(year) {
    return $7c5f6fbf42389787$var$hebrewDelay1(year) + $7c5f6fbf42389787$var$hebrewDelay2(year);
}
function $7c5f6fbf42389787$var$getDaysInYear(year) {
    return $7c5f6fbf42389787$var$startOfYear(year + 1) - $7c5f6fbf42389787$var$startOfYear(year);
}
function $7c5f6fbf42389787$var$getYearType(year) {
    let yearLength = $7c5f6fbf42389787$var$getDaysInYear(year);
    if (yearLength > 380) yearLength -= 30; // Subtract length of leap month.
    switch(yearLength){
        case 353:
            return 0; // deficient
        case 354:
            return 1; // normal
        case 355:
            return 2; // complete
    }
}
function $7c5f6fbf42389787$var$getDaysInMonth(year, month) {
    // Normalize month numbers from 1 - 13, even on non-leap years
    if (month >= 6 && !$7c5f6fbf42389787$var$isLeapYear(year)) month++;
    // First of all, dispose of fixed-length 29 day months
    if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;
    let yearType = $7c5f6fbf42389787$var$getYearType(year);
    // If it's Heshvan, days depend on length of year
    if (month === 2) return yearType === 2 ? 30 : 29;
    // Similarly, Kislev varies with the length of year
    if (month === 3) return yearType === 0 ? 29 : 30;
    // Adar I only exists in leap years
    if (month === 6) return $7c5f6fbf42389787$var$isLeapYear(year) ? 30 : 0;
    return 30;
}
class $7c5f6fbf42389787$export$ca405048b8fb5af {
    fromJulianDay(jd) {
        let d = jd - $7c5f6fbf42389787$var$HEBREW_EPOCH;
        let m = d * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS; // Months (approx)
        let year = Math.floor((19 * m + 234) / 235) + 1; // Years (approx)
        let ys = $7c5f6fbf42389787$var$startOfYear(year); // 1st day of year
        let dayOfYear = Math.floor(d - ys);
        // Because of the postponement rules, it's possible to guess wrong.  Fix it.
        while(dayOfYear < 1){
            year--;
            ys = $7c5f6fbf42389787$var$startOfYear(year);
            dayOfYear = Math.floor(d - ys);
        }
        // Now figure out which month we're in, and the date within that month
        let month = 1;
        let monthStart = 0;
        while(monthStart < dayOfYear){
            monthStart += $7c5f6fbf42389787$var$getDaysInMonth(year, month);
            month++;
        }
        month--;
        monthStart -= $7c5f6fbf42389787$var$getDaysInMonth(year, month);
        let day = dayOfYear - monthStart;
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, year, month, day);
    }
    toJulianDay(date) {
        let jd = $7c5f6fbf42389787$var$startOfYear(date.year);
        for(let month = 1; month < date.month; month++)jd += $7c5f6fbf42389787$var$getDaysInMonth(date.year, month);
        return jd + date.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;
    }
    getDaysInMonth(date) {
        return $7c5f6fbf42389787$var$getDaysInMonth(date.year, date.month);
    }
    getMonthsInYear(date) {
        return $7c5f6fbf42389787$var$isLeapYear(date.year) ? 13 : 12;
    }
    getDaysInYear(date) {
        return $7c5f6fbf42389787$var$getDaysInYear(date.year);
    }
    getYearsInEra() {
        // 6239 gregorian
        return 9999;
    }
    getEras() {
        return [
            "AM"
        ];
    }
    balanceYearMonth(date, previousDate) {
        // Keep date in the same month when switching between leap years and non leap years
        if (previousDate.year !== date.year) {
            if ($7c5f6fbf42389787$var$isLeapYear(previousDate.year) && !$7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;
            else if (!$7c5f6fbf42389787$var$isLeapYear(previousDate.year) && $7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;
        }
    }
    constructor(){
        this.identifier = "hebrew";
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.
const $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856;
const $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665;
// The delta between Amete Alem 1 and Amete Mihret 1
// AA 5501 = AM 1
const $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;
function $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, day) {
    return epoch // difference from Julian epoch to 1,1,1
     + 365 * year // number of days from years
     + Math.floor(year / 4) // extra day of leap year
     + 30 * (month - 1 // number of days from months (1 based)
    ) + day - 1 // number of days for present month (1 based)
    ;
}
function $b956b2d7a6cf451f$var$julianDayToCE(epoch, jd) {
    let year = Math.floor(4 * (jd - epoch) / 1461);
    let month = 1 + Math.floor((jd - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
    let day = jd + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, 1);
    return [
        year,
        month,
        day
    ];
}
function $b956b2d7a6cf451f$var$getLeapDay(year) {
    return Math.floor(year % 4 / 3);
}
function $b956b2d7a6cf451f$var$getDaysInMonth(year, month) {
    // The Ethiopian and Coptic calendars have 13 months, 12 of 30 days each and
    // an intercalary month at the end of the year of 5 or 6 days, depending whether
    // the year is a leap year or not. The Leap Year follows the same rules as the
    // Julian Calendar so that the extra month always has six days in the year before
    // a Julian Leap Year.
    if (month % 13 !== 0) return 30;
    else return $b956b2d7a6cf451f$var$getLeapDay(year) + 5;
}
class $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
        let era = "AM";
        if (year <= 0) {
            era = "AA";
            year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
        }
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, era, year, month, day);
    }
    toJulianDay(date) {
        let year = date.year;
        if (date.era === "AA") year -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
        return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $b956b2d7a6cf451f$var$getDaysInMonth(date.year, date.month);
    }
    getMonthsInYear() {
        return 13;
    }
    getDaysInYear(date) {
        return 365 + $b956b2d7a6cf451f$var$getLeapDay(date.year);
    }
    getYearsInEra(date) {
        // 9999-12-31 gregorian is 9992-20-02 ethiopic.
        // Round down to 9991 for the last full year.
        // AA 9999-01-01 ethiopic is 4506-09-30 gregorian.
        return date.era === "AA" ? 9999 : 9991;
    }
    getEras() {
        return [
            "AA",
            "AM"
        ];
    }
    constructor(){
        this.identifier = "ethiopic";
    }
}
class $b956b2d7a6cf451f$export$d72e0c37005a4914 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
        year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, "AA", year, month, day);
    }
    getEras() {
        return [
            "AA"
        ];
    }
    getYearsInEra() {
        // 9999-13-04 ethioaa is the maximum date, which is equivalent to 4506-09-29 gregorian.
        return 9999;
    }
    constructor(...args){
        super(...args);
        this.identifier = "ethioaa" // also known as 'ethiopic-amete-alem' in ICU
        ;
    }
}
class $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, jd);
        let era = "CE";
        if (year <= 0) {
            era = "BCE";
            year = 1 - year;
        }
        return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, era, year, month, day);
    }
    toJulianDay(date) {
        let year = date.year;
        if (date.era === "BCE") year = 1 - year;
        return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, year, date.month, date.day);
    }
    getDaysInMonth(date) {
        let year = date.year;
        if (date.era === "BCE") year = 1 - year;
        return $b956b2d7a6cf451f$var$getDaysInMonth(year, date.month);
    }
    isInverseEra(date) {
        return date.era === "BCE";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BCE" ? "CE" : "BCE";
            date.year = 1 - date.year;
        }
    }
    getEras() {
        return [
            "BCE",
            "CE"
        ];
    }
    getYearsInEra(date) {
        // 9999-12-30 gregorian is 9716-02-20 coptic.
        // Round down to 9715 for the last full year.
        // BCE 9999-01-01 coptic is BC 9716-06-15 gregorian.
        return date.era === "BCE" ? 9999 : 9715;
    }
    constructor(...args){
        super(...args);
        this.identifier = "coptic";
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $64244302c3013299$export$dd0bbc9b26defe37(name) {
    switch(name){
        case "buddhist":
            return new $8d73d47422ca7302$export$42d20a78301dee44();
        case "ethiopic":
            return new $b956b2d7a6cf451f$export$26ba6eab5e20cd7d();
        case "ethioaa":
            return new $b956b2d7a6cf451f$export$d72e0c37005a4914();
        case "coptic":
            return new $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1();
        case "hebrew":
            return new $7c5f6fbf42389787$export$ca405048b8fb5af();
        case "indian":
            return new $82c358003bdda0a8$export$39f31c639fa15726();
        case "islamic-civil":
            return new $f2f3e0e3a817edbd$export$2066795aadd37bfc();
        case "islamic-tbla":
            return new $f2f3e0e3a817edbd$export$37f0887f2f9d22f7();
        case "islamic-umalqura":
            return new $f2f3e0e3a817edbd$export$5baab4758c231076();
        case "japanese":
            return new $62225008020f0a13$export$b746ab2b60cdffbf();
        case "persian":
            return new $f3ed2e4472ae7e25$export$37fccdbfd14c5939();
        case "roc":
            return new $5f31bd6f0c8940b2$export$65e01080afcb0799();
        case "gregory":
        default:
            return new $3b62074eb05584b2$export$80ee6245ec4f29ec();
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $fb18d541ea1ad717$var$formatterCache = new Map();
class $fb18d541ea1ad717$export$ad991b66133851cf {
    /** Formats a date as a string according to the locale and format options passed to the constructor. */ format(value) {
        return this.formatter.format(value);
    }
    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */ formatToParts(value) {
        return this.formatter.formatToParts(value);
    }
    /** Formats a date range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRange === "function") return this.formatter.formatRange(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        // Very basic fallback for old browsers.
        return `${this.formatter.format(start)} \u{2013} ${this.formatter.format(end)}`;
    }
    /** Formats a date range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRangeToParts === "function") return this.formatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        let startParts = this.formatter.formatToParts(start);
        let endParts = this.formatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: "startRange"
                })),
            {
                type: "literal",
                value: " – ",
                source: "shared"
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: "endRange"
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let resolvedOptions = this.formatter.resolvedOptions();
        if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
            if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
            resolvedOptions.hourCycle = this.resolvedHourCycle;
            resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
        }
        // Safari uses a different name for the Ethiopic (Amete Alem) calendar.
        // https://bugs.webkit.org/show_bug.cgi?id=241564
        if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
        return resolvedOptions;
    }
    constructor(locale, options = {}){
        this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
        this.options = options;
    }
}
// There are multiple bugs involving the hour12 and hourCycle options in various browser engines.
//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)
//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)
//     rather than h12 (12:00 - 11:59).
//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal
//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]
// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791
// [2] https://github.com/tc39/ecma402/issues/402
// [3] https://bugs.webkit.org/show_bug.cgi?id=229313
// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802
const $fb18d541ea1ad717$var$hour12Preferences = {
    true: {
        // Only Japanese uses the h11 style for 12 hour time. All others use h12.
        ja: "h11"
    },
    false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
    // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.
    // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.
    if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
        options = {
            ...options
        };
        let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
        let defaultHourCycle = options.hour12 ? "h12" : "h23";
        options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
        delete options.hour12;
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.DateTimeFormat(locale, options);
    $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
let $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
    if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
        hour: "numeric",
        hour12: false
    }).format(new Date(2020, 2, 3, 0)) === "24";
    return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
let $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
    if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
        hour: "numeric",
        hour12: false
    }).resolvedOptions().hourCycle === "h12";
    return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
    if (!options.timeStyle && !options.hour) return undefined;
    // Work around buggy results in resolved hourCycle and hour12 options in WebKit.
    // Format the minimum possible hour and maximum possible hour in a day and parse the results.
    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
    locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
    let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
        ...options,
        timeZone: undefined // use local timezone
    });
    let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p)=>p.type === "hour").value, 10);
    let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p)=>p.type === "hour").value, 10);
    if (min === 0 && max === 23) return "h23";
    if (min === 24 && max === 23) return "h24";
    if (min === 0 && max === 11) return "h11";
    if (min === 12 && max === 11) return "h12";
    throw new Error("Unexpected hour cycle result");
}

},{"@swc/helpers/_/_class_private_field_init":"hKNVa","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hKNVa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_class_private_field_init", ()=>_class_private_field_init);
parcelHelpers.export(exports, "_", ()=>_class_private_field_init);
var _checkPrivateRedeclarationJs = require("./_check_private_redeclaration.js");
function _class_private_field_init(obj, privateMap, value) {
    (0, _checkPrivateRedeclarationJs._check_private_redeclaration)(obj, privateMap);
    privateMap.set(obj, value);
}

},{"./_check_private_redeclaration.js":"698AT","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"698AT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_check_private_redeclaration", ()=>_check_private_redeclaration);
parcelHelpers.export(exports, "_", ()=>_check_private_redeclaration);
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3m4w3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _core.detectOverflow));
parcelHelpers.export(exports, "offset", ()=>(0, _core.offset));
parcelHelpers.export(exports, "getOverflowAncestors", ()=>(0, _dom.getOverflowAncestors));
parcelHelpers.export(exports, "arrow", ()=>arrow);
parcelHelpers.export(exports, "autoPlacement", ()=>autoPlacement);
parcelHelpers.export(exports, "autoUpdate", ()=>autoUpdate);
parcelHelpers.export(exports, "computePosition", ()=>computePosition);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "hide", ()=>hide);
parcelHelpers.export(exports, "inline", ()=>inline);
parcelHelpers.export(exports, "limitShift", ()=>limitShift);
parcelHelpers.export(exports, "platform", ()=>platform);
parcelHelpers.export(exports, "shift", ()=>shift);
parcelHelpers.export(exports, "size", ()=>size);
var _core = require("@floating-ui/core");
var _utils = require("@floating-ui/utils");
var _dom = require("@floating-ui/utils/dom");
function getCssDimensions(element) {
    const css = (0, _dom.getComputedStyle)(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = (0, _dom.isHTMLElement)(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = (0, _utils.round)(width) !== offsetWidth || (0, _utils.round)(height) !== offsetHeight;
    if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
    }
    return {
        width,
        height,
        $: shouldFallback
    };
}
function unwrapElement(element) {
    return !(0, _dom.isElement)(element) ? element.contextElement : element;
}
function getScale(element) {
    const domElement = unwrapElement(element);
    if (!(0, _dom.isHTMLElement)(domElement)) return (0, _utils.createCoords)(1);
    const rect = domElement.getBoundingClientRect();
    const { width , height , $  } = getCssDimensions(domElement);
    let x = ($ ? (0, _utils.round)(rect.width) : rect.width) / width;
    let y = ($ ? (0, _utils.round)(rect.height) : rect.height) / height;
    // 0, NaN, or Infinity should always fallback to 1.
    if (!x || !Number.isFinite(x)) x = 1;
    if (!y || !Number.isFinite(y)) y = 1;
    return {
        x,
        y
    };
}
const noOffsets = /*#__PURE__*/ (0, _utils.createCoords)(0);
function getVisualOffsets(element) {
    const win = (0, _dom.getWindow)(element);
    if (!(0, _dom.isWebKit)() || !win.visualViewport) return noOffsets;
    return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
    };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) isFixed = false;
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0, _dom.getWindow)(element)) return false;
    return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) includeScale = false;
    if (isFixedStrategy === void 0) isFixedStrategy = false;
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = (0, _utils.createCoords)(1);
    if (includeScale) {
        if (offsetParent) {
            if ((0, _dom.isElement)(offsetParent)) scale = getScale(offsetParent);
        } else scale = getScale(element);
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0, _utils.createCoords)(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
        const win = (0, _dom.getWindow)(domElement);
        const offsetWin = offsetParent && (0, _dom.isElement)(offsetParent) ? (0, _dom.getWindow)(offsetParent) : offsetParent;
        let currentIFrame = win.frameElement;
        while(currentIFrame && offsetParent && offsetWin !== win){
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = (0, _dom.getComputedStyle)(currentIFrame);
            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentIFrame = (0, _dom.getWindow)(currentIFrame).frameElement;
        }
    }
    return (0, _core.rectToClientRect)({
        width,
        height,
        x,
        y
    });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { rect , offsetParent , strategy  } = _ref;
    const isOffsetParentAnElement = (0, _dom.isHTMLElement)(offsetParent);
    const documentElement = (0, _dom.getDocumentElement)(offsetParent);
    if (offsetParent === documentElement) return rect;
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    let scale = (0, _utils.createCoords)(1);
    const offsets = (0, _utils.createCoords)(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if ((0, _dom.getNodeName)(offsetParent) !== "body" || (0, _dom.isOverflowElement)(documentElement)) scroll = (0, _dom.getNodeScroll)(offsetParent);
        if ((0, _dom.isHTMLElement)(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        }
    }
    return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
}
function getClientRects(element) {
    return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    return getBoundingClientRect((0, _dom.getDocumentElement)(element)).left + (0, _dom.getNodeScroll)(element).scrollLeft;
}
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
    const html = (0, _dom.getDocumentElement)(element);
    const scroll = (0, _dom.getNodeScroll)(element);
    const body = element.ownerDocument.body;
    const width = (0, _utils.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = (0, _utils.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if ((0, _dom.getComputedStyle)(body).direction === "rtl") x += (0, _utils.max)(html.clientWidth, body.clientWidth) - width;
    return {
        width,
        height,
        x,
        y
    };
}
function getViewportRect(element, strategy) {
    const win = (0, _dom.getWindow)(element);
    const html = (0, _dom.getDocumentElement)(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = (0, _dom.isWebKit)();
        if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x,
        y
    };
}
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = (0, _dom.isHTMLElement)(element) ? getScale(element) : (0, _utils.createCoords)(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
        width,
        height,
        x,
        y
    };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") rect = getViewportRect(element, strategy);
    else if (clippingAncestor === "document") rect = getDocumentRect((0, _dom.getDocumentElement)(element));
    else if ((0, _dom.isElement)(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
            ...clippingAncestor,
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y
        };
    }
    return (0, _core.rectToClientRect)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = (0, _dom.getParentNode)(element);
    if (parentNode === stopNode || !(0, _dom.isElement)(parentNode) || (0, _dom.isLastTraversableNode)(parentNode)) return false;
    return (0, _dom.getComputedStyle)(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) return cachedResult;
    let result = (0, _dom.getOverflowAncestors)(element, [], false).filter((el)=>(0, _dom.isElement)(el) && (0, _dom.getNodeName)(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = (0, _dom.getComputedStyle)(element).position === "fixed";
    let currentNode = elementIsFixed ? (0, _dom.getParentNode)(element) : element;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while((0, _dom.isElement)(currentNode) && !(0, _dom.isLastTraversableNode)(currentNode)){
        const computedStyle = (0, _dom.getComputedStyle)(currentNode);
        const currentNodeIsContaining = (0, _dom.isContainingBlock)(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && [
            "absolute",
            "fixed"
        ].includes(currentContainingBlockComputedStyle.position) || (0, _dom.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) // Drop non-containing blocks.
        result = result.filter((ancestor)=>ancestor !== currentNode);
        else // Record last containing block for next iteration.
        currentContainingBlockComputedStyle = computedStyle;
        currentNode = (0, _dom.getParentNode)(currentNode);
    }
    cache.set(element, result);
    return result;
}
// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
    let { element , boundary , rootBoundary , strategy  } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [
        ...elementClippingAncestors,
        rootBoundary
    ];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = (0, _utils.max)(rect.top, accRect.top);
        accRect.right = (0, _utils.min)(rect.right, accRect.right);
        accRect.bottom = (0, _utils.min)(rect.bottom, accRect.bottom);
        accRect.left = (0, _utils.max)(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
function getDimensions(element) {
    const { width , height  } = getCssDimensions(element);
    return {
        width,
        height
    };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = (0, _dom.isHTMLElement)(offsetParent);
    const documentElement = (0, _dom.getDocumentElement)(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = (0, _utils.createCoords)(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, _dom.getNodeName)(offsetParent) !== "body" || (0, _dom.isOverflowElement)(documentElement)) scroll = (0, _dom.getNodeScroll)(offsetParent);
        if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
function getTrueOffsetParent(element, polyfill) {
    if (!(0, _dom.isHTMLElement)(element) || (0, _dom.getComputedStyle)(element).position === "fixed") return null;
    if (polyfill) return polyfill(element);
    return element.offsetParent;
}
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
    const window = (0, _dom.getWindow)(element);
    if (!(0, _dom.isHTMLElement)(element)) return window;
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while(offsetParent && (0, _dom.isTableElement)(offsetParent) && (0, _dom.getComputedStyle)(offsetParent).position === "static")offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    if (offsetParent && ((0, _dom.getNodeName)(offsetParent) === "html" || (0, _dom.getNodeName)(offsetParent) === "body" && (0, _dom.getComputedStyle)(offsetParent).position === "static" && !(0, _dom.isContainingBlock)(offsetParent))) return window;
    return offsetParent || (0, _dom.getContainingBlock)(element) || window;
}
const getElementRects = async function(_ref) {
    let { reference , floating , strategy  } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
        floating: {
            x: 0,
            y: 0,
            ...await getDimensionsFn(floating)
        }
    };
};
function isRTL(element) {
    return (0, _dom.getComputedStyle)(element).direction === "rtl";
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: (0, _dom.getDocumentElement),
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: (0, _dom.isElement),
    isRTL
};
// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = (0, _dom.getDocumentElement)(element);
    function cleanup() {
        clearTimeout(timeoutId);
        io && io.disconnect();
        io = null;
    }
    function refresh(skip, threshold) {
        if (skip === void 0) skip = false;
        if (threshold === void 0) threshold = 1;
        cleanup();
        const { left , top , width , height  } = element.getBoundingClientRect();
        if (!skip) onMove();
        if (!width || !height) return;
        const insetTop = (0, _utils.floor)(top);
        const insetRight = (0, _utils.floor)(root.clientWidth - (left + width));
        const insetBottom = (0, _utils.floor)(root.clientHeight - (top + height));
        const insetLeft = (0, _utils.floor)(left);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
            rootMargin,
            threshold: (0, _utils.max)(0, (0, _utils.min)(1, threshold)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
            const ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
                if (!isFirstUpdate) return refresh();
                if (!ratio) timeoutId = setTimeout(()=>{
                    refresh(false, 1e-7);
                }, 100);
                else refresh(false, ratio);
            }
            isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
            io = new IntersectionObserver(handleObserve, {
                ...options,
                // Handle <iframe>s
                root: root.ownerDocument
            });
        } catch (e) {
            io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
    }
    refresh(true);
    return cleanup;
}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) options = {};
    const { ancestorScroll =true , ancestorResize =true , elementResize =typeof ResizeObserver === "function" , layoutShift =typeof IntersectionObserver === "function" , animationFrame =false  } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [
        ...referenceEl ? (0, _dom.getOverflowAncestors)(referenceEl) : [],
        ...(0, _dom.getOverflowAncestors)(floating)
    ] : [];
    ancestors.forEach((ancestor)=>{
        ancestorScroll && ancestor.addEventListener("scroll", update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
        resizeObserver = new ResizeObserver((_ref)=>{
            let [firstEntry] = _ref;
            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(()=>{
                    resizeObserver && resizeObserver.observe(floating);
                });
            }
            update();
        });
        if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);
        resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) frameLoop();
    function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) update();
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return ()=>{
        ancestors.forEach((ancestor)=>{
            ancestorScroll && ancestor.removeEventListener("scroll", update);
            ancestorResize && ancestor.removeEventListener("resize", update);
        });
        cleanupIo && cleanupIo();
        resizeObserver && resizeObserver.disconnect();
        resizeObserver = null;
        if (animationFrame) cancelAnimationFrame(frameId);
    };
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = (0, _core.autoPlacement);
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = (0, _core.shift);
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = (0, _core.flip);
/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = (0, _core.size);
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = (0, _core.hide);
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (0, _core.arrow);
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = (0, _core.inline);
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = (0, _core.limitShift);
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */ const computePosition = (reference, floating, options)=>{
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
        platform,
        ...options
    };
    const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
    };
    return (0, _core.computePosition)(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
    });
};

},{"@floating-ui/core":"juO6B","@floating-ui/utils":"1NiOn","@floating-ui/utils/dom":"6AalP","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"juO6B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rectToClientRect", ()=>(0, _utils.rectToClientRect));
parcelHelpers.export(exports, "arrow", ()=>arrow);
parcelHelpers.export(exports, "autoPlacement", ()=>autoPlacement);
parcelHelpers.export(exports, "computePosition", ()=>computePosition);
parcelHelpers.export(exports, "detectOverflow", ()=>detectOverflow);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "hide", ()=>hide);
parcelHelpers.export(exports, "inline", ()=>inline);
parcelHelpers.export(exports, "limitShift", ()=>limitShift);
parcelHelpers.export(exports, "offset", ()=>offset);
parcelHelpers.export(exports, "shift", ()=>shift);
parcelHelpers.export(exports, "size", ()=>size);
var _utils = require("@floating-ui/utils");
function computeCoordsFromPlacement(_ref, placement, rtl) {
    let { reference , floating  } = _ref;
    const sideAxis = (0, _utils.getSideAxis)(placement);
    const alignmentAxis = (0, _utils.getAlignmentAxis)(placement);
    const alignLength = (0, _utils.getAxisLength)(alignmentAxis);
    const side = (0, _utils.getSide)(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch(side){
        case "top":
            coords = {
                x: commonX,
                y: reference.y - floating.height
            };
            break;
        case "bottom":
            coords = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case "right":
            coords = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case "left":
            coords = {
                x: reference.x - floating.width,
                y: commonY
            };
            break;
        default:
            coords = {
                x: reference.x,
                y: reference.y
            };
    }
    switch((0, _utils.getAlignment)(placement)){
        case "start":
            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        case "end":
            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
    }
    return coords;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */ const computePosition = async (reference, floating, config)=>{
    const { placement ="bottom" , strategy ="absolute" , middleware =[] , platform  } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    let rects = await platform.getElementRects({
        reference,
        floating,
        strategy
    });
    let { x , y  } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for(let i = 0; i < validMiddleware.length; i++){
        const { name , fn  } = validMiddleware[i];
        const { x: nextX , y: nextY , data , reset  } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
                reference,
                floating
            }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
            ...middlewareData,
            [name]: {
                ...middlewareData[name],
                ...data
            }
        };
        if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
                if (reset.placement) statefulPlacement = reset.placement;
                if (reset.rects) rects = reset.rects === true ? await platform.getElementRects({
                    reference,
                    floating,
                    strategy
                }) : reset.rects;
                ({ x , y  } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
            continue;
        }
    }
    return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
    };
};
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) options = {};
    const { x , y , platform , rects , elements , strategy  } = state;
    const { boundary ="clippingAncestors" , rootBoundary ="viewport" , elementContext ="floating" , altBoundary =false , padding =0  } = (0, _utils.evaluate)(options, state);
    const paddingObject = (0, _utils.getPaddingObject)(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = (0, _utils.rectToClientRect)(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
    }));
    const rect = elementContext === "floating" ? {
        ...rects.floating,
        x,
        y
    } : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    };
    const elementClientRect = (0, _utils.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect,
        offsetParent,
        strategy
    }) : rect);
    return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
}
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (options)=>({
        name: "arrow",
        options,
        async fn (state) {
            const { x , y , placement , rects , platform , elements , middlewareData  } = state;
            // Since `element` is required, we don't Partial<> the type.
            const { element , padding =0  } = (0, _utils.evaluate)(options, state) || {};
            if (element == null) return {};
            const paddingObject = (0, _utils.getPaddingObject)(padding);
            const coords = {
                x,
                y
            };
            const axis = (0, _utils.getAlignmentAxis)(placement);
            const length = (0, _utils.getAxisLength)(axis);
            const arrowDimensions = await platform.getDimensions(element);
            const isYAxis = axis === "y";
            const minProp = isYAxis ? "top" : "left";
            const maxProp = isYAxis ? "bottom" : "right";
            const clientProp = isYAxis ? "clientHeight" : "clientWidth";
            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
            const startDiff = coords[axis] - rects.reference[axis];
            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
            // DOM platform can return `window` as the `offsetParent`.
            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length];
            const centerToReference = endDiff / 2 - startDiff / 2;
            // If the padding is large enough that it causes the arrow to no longer be
            // centered, modify the padding so that it is centered.
            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
            const minPadding = (0, _utils.min)(paddingObject[minProp], largestPossiblePadding);
            const maxPadding = (0, _utils.min)(paddingObject[maxProp], largestPossiblePadding);
            // Make sure the arrow doesn't overflow the floating element if the center
            // point is outside the floating element's bounds.
            const min$1 = minPadding;
            const max = clientSize - arrowDimensions[length] - maxPadding;
            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
            const offset = (0, _utils.clamp)(min$1, center, max);
            // If the reference is small enough that the arrow's padding causes it to
            // to point to nothing for an aligned placement, adjust the offset of the
            // floating element itself. To ensure `shift()` continues to take action,
            // a single reset is performed when this is true.
            const shouldAddOffset = !middlewareData.arrow && (0, _utils.getAlignment)(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
            return {
                [axis]: coords[axis] + alignmentOffset,
                data: {
                    [axis]: offset,
                    centerOffset: center - offset - alignmentOffset,
                    ...shouldAddOffset && {
                        alignmentOffset
                    }
                },
                reset: shouldAddOffset
            };
        }
    });
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [
        ...allowedPlacements.filter((placement)=>(0, _utils.getAlignment)(placement) === alignment),
        ...allowedPlacements.filter((placement)=>(0, _utils.getAlignment)(placement) !== alignment)
    ] : allowedPlacements.filter((placement)=>(0, _utils.getSide)(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement)=>{
        if (alignment) return (0, _utils.getAlignment)(placement) === alignment || (autoAlignment ? (0, _utils.getOppositeAlignmentPlacement)(placement) !== placement : false);
        return true;
    });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = function(options) {
    if (options === void 0) options = {};
    return {
        name: "autoPlacement",
        options,
        async fn (state) {
            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
            const { rects , middlewareData , placement , platform , elements  } = state;
            const { crossAxis =false , alignment , allowedPlacements =(0, _utils.placements) , autoAlignment =true , ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            const placements$1 = alignment !== undefined || allowedPlacements === (0, _utils.placements) ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
            const currentPlacement = placements$1[currentIndex];
            if (currentPlacement == null) return {};
            const alignmentSides = (0, _utils.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
            // Make `computeCoords` start from the right place.
            if (placement !== currentPlacement) return {
                reset: {
                    placement: placements$1[0]
                }
            };
            const currentOverflows = [
                overflow[(0, _utils.getSide)(currentPlacement)],
                overflow[alignmentSides[0]],
                overflow[alignmentSides[1]]
            ];
            const allOverflows = [
                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],
                {
                    placement: currentPlacement,
                    overflows: currentOverflows
                }
            ];
            const nextPlacement = placements$1[currentIndex + 1];
            // There are more placements to check.
            if (nextPlacement) return {
                data: {
                    index: currentIndex + 1,
                    overflows: allOverflows
                },
                reset: {
                    placement: nextPlacement
                }
            };
            const placementsSortedByMostSpace = allOverflows.map((d)=>{
                const alignment = (0, _utils.getAlignment)(d.placement);
                return [
                    d.placement,
                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.
                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.
                    d.overflows[0],
                    d.overflows
                ];
            }).sort((a, b)=>a[1] - b[1]);
            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis
                // side.
                (0, _utils.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));
            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
            if (resetPlacement !== placement) return {
                data: {
                    index: currentIndex + 1,
                    overflows: allOverflows
                },
                reset: {
                    placement: resetPlacement
                }
            };
            return {};
        }
    };
};
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = function(options) {
    if (options === void 0) options = {};
    return {
        name: "flip",
        options,
        async fn (state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const { placement , middlewareData , rects , initialPlacement , platform , elements  } = state;
            const { mainAxis: checkMainAxis = true , crossAxis: checkCrossAxis = true , fallbackPlacements: specifiedFallbackPlacements , fallbackStrategy ="bestFit" , fallbackAxisSideDirection ="none" , flipAlignment =true , ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            // If a reset by the arrow was caused due to an alignment offset being
            // added, we should skip any logic now since `flip()` has already done its
            // work.
            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
            const side = (0, _utils.getSide)(placement);
            const isBasePlacement = (0, _utils.getSide)(initialPlacement) === initialPlacement;
            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [
                (0, _utils.getOppositePlacement)(initialPlacement)
            ] : (0, _utils.getExpandedPlacements)(initialPlacement));
            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") fallbackPlacements.push(...(0, _utils.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
            const placements = [
                initialPlacement,
                ...fallbackPlacements
            ];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) overflows.push(overflow[side]);
            if (checkCrossAxis) {
                const sides = (0, _utils.getAlignmentSides)(placement, rects, rtl);
                overflows.push(overflow[sides[0]], overflow[sides[1]]);
            }
            overflowsData = [
                ...overflowsData,
                {
                    placement,
                    overflows
                }
            ];
            // One or more sides is overflowing.
            if (!overflows.every((side)=>side <= 0)) {
                var _middlewareData$flip2, _overflowsData$filter;
                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
                const nextPlacement = placements[nextIndex];
                if (nextPlacement) // Try next placement and re-run the lifecycle.
                return {
                    data: {
                        index: nextIndex,
                        overflows: overflowsData
                    },
                    reset: {
                        placement: nextPlacement
                    }
                };
                // First, find the candidates that fit on the mainAxis side of overflow,
                // then find the placement that fits the best on the main crossAxis side.
                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
                // Otherwise fallback.
                if (!resetPlacement) switch(fallbackStrategy){
                    case "bestFit":
                        {
                            var _overflowsData$map$so;
                            const placement1 = (_overflowsData$map$so = overflowsData.map((d)=>[
                                    d.placement,
                                    d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)
                                ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                            if (placement1) resetPlacement = placement1;
                            break;
                        }
                    case "initialPlacement":
                        resetPlacement = initialPlacement;
                        break;
                }
                if (placement !== resetPlacement) return {
                    reset: {
                        placement: resetPlacement
                    }
                };
            }
            return {};
        }
    };
};
function getSideOffsets(overflow, rect) {
    return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width
    };
}
function isAnySideFullyClipped(overflow) {
    return (0, _utils.sides).some((side)=>overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = function(options) {
    if (options === void 0) options = {};
    return {
        name: "hide",
        options,
        async fn (state) {
            const { rects  } = state;
            const { strategy ="referenceHidden" , ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            switch(strategy){
                case "referenceHidden":
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            elementContext: "reference"
                        });
                        const offsets = getSideOffsets(overflow, rects.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: offsets,
                                referenceHidden: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                case "escaped":
                    {
                        const overflow1 = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            altBoundary: true
                        });
                        const offsets1 = getSideOffsets(overflow1, rects.floating);
                        return {
                            data: {
                                escapedOffsets: offsets1,
                                escaped: isAnySideFullyClipped(offsets1)
                            }
                        };
                    }
                default:
                    return {};
            }
        }
    };
};
function getBoundingRect(rects) {
    const minX = (0, _utils.min)(...rects.map((rect)=>rect.left));
    const minY = (0, _utils.min)(...rects.map((rect)=>rect.top));
    const maxX = (0, _utils.max)(...rects.map((rect)=>rect.right));
    const maxY = (0, _utils.max)(...rects.map((rect)=>rect.bottom));
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}
function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);
    const groups = [];
    let prevRect = null;
    for(let i = 0; i < sortedRects.length; i++){
        const rect = sortedRects[i];
        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) groups.push([
            rect
        ]);
        else groups[groups.length - 1].push(rect);
        prevRect = rect;
    }
    return groups.map((rect)=>(0, _utils.rectToClientRect)(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = function(options) {
    if (options === void 0) options = {};
    return {
        name: "inline",
        options,
        async fn (state) {
            const { placement , elements , rects , platform , strategy  } = state;
            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
            // ClientRect's bounds, despite the event listener being triggered. A
            // padding of 2 seems to handle this issue.
            const { padding =2 , x , y  } = (0, _utils.evaluate)(options, state);
            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);
            const clientRects = getRectsByLine(nativeClientRects);
            const fallback = (0, _utils.rectToClientRect)(getBoundingRect(nativeClientRects));
            const paddingObject = (0, _utils.getPaddingObject)(padding);
            function getBoundingClientRect() {
                // There are two rects and they are disjoined.
                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) // Find the first rect in which the point is fully inside.
                return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
                // There are 2 or more connected rects.
                if (clientRects.length >= 2) {
                    if ((0, _utils.getSideAxis)(placement) === "y") {
                        const firstRect = clientRects[0];
                        const lastRect = clientRects[clientRects.length - 1];
                        const isTop = (0, _utils.getSide)(placement) === "top";
                        const top = firstRect.top;
                        const bottom = lastRect.bottom;
                        const left = isTop ? firstRect.left : lastRect.left;
                        const right = isTop ? firstRect.right : lastRect.right;
                        const width = right - left;
                        const height = bottom - top;
                        return {
                            top,
                            bottom,
                            left,
                            right,
                            width,
                            height,
                            x: left,
                            y: top
                        };
                    }
                    const isLeftSide = (0, _utils.getSide)(placement) === "left";
                    const maxRight = (0, _utils.max)(...clientRects.map((rect)=>rect.right));
                    const minLeft = (0, _utils.min)(...clientRects.map((rect)=>rect.left));
                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                    const top1 = measureRects[0].top;
                    const bottom1 = measureRects[measureRects.length - 1].bottom;
                    const left1 = minLeft;
                    const right1 = maxRight;
                    const width1 = right1 - left1;
                    const height1 = bottom1 - top1;
                    return {
                        top: top1,
                        bottom: bottom1,
                        left: left1,
                        right: right1,
                        width: width1,
                        height: height1,
                        x: left1,
                        y: top1
                    };
                }
                return fallback;
            }
            const resetRects = await platform.getElementRects({
                reference: {
                    getBoundingClientRect
                },
                floating: elements.floating,
                strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) return {
                reset: {
                    rects: resetRects
                }
            };
            return {};
        }
    };
};
// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.
async function convertValueToCoords(state, options) {
    const { placement , platform , elements  } = state;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = (0, _utils.getSide)(placement);
    const alignment = (0, _utils.getAlignment)(placement);
    const isVertical = (0, _utils.getSideAxis)(placement) === "y";
    const mainAxisMulti = [
        "left",
        "top"
    ].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = (0, _utils.evaluate)(options, state);
    // eslint-disable-next-line prefer-const
    let { mainAxis , crossAxis , alignmentAxis  } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
    };
    if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
    } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
    };
}
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = function(options) {
    if (options === void 0) options = 0;
    return {
        name: "offset",
        options,
        async fn (state) {
            var _middlewareData$offse, _middlewareData$arrow;
            const { x , y , placement , middlewareData  } = state;
            const diffCoords = await convertValueToCoords(state, options);
            // If the placement is the same and the arrow caused an alignment offset
            // then we don't need to change the positioning coordinates.
            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
            return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: {
                    ...diffCoords,
                    placement
                }
            };
        }
    };
};
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = function(options) {
    if (options === void 0) options = {};
    return {
        name: "shift",
        options,
        async fn (state) {
            const { x , y , placement  } = state;
            const { mainAxis: checkMainAxis = true , crossAxis: checkCrossAxis = false , limiter ={
                fn: (_ref)=>{
                    let { x , y  } = _ref;
                    return {
                        x,
                        y
                    };
                }
            } , ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            const coords = {
                x,
                y
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = (0, _utils.getSideAxis)((0, _utils.getSide)(placement));
            const mainAxis = (0, _utils.getOppositeAxis)(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
                const minSide = mainAxis === "y" ? "top" : "left";
                const maxSide = mainAxis === "y" ? "bottom" : "right";
                const min = mainAxisCoord + overflow[minSide];
                const max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = (0, _utils.clamp)(min, mainAxisCoord, max);
            }
            if (checkCrossAxis) {
                const minSide1 = crossAxis === "y" ? "top" : "left";
                const maxSide1 = crossAxis === "y" ? "bottom" : "right";
                const min1 = crossAxisCoord + overflow[minSide1];
                const max1 = crossAxisCoord - overflow[maxSide1];
                crossAxisCoord = (0, _utils.clamp)(min1, crossAxisCoord, max1);
            }
            const limitedCoords = limiter.fn({
                ...state,
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            });
            return {
                ...limitedCoords,
                data: {
                    x: limitedCoords.x - x,
                    y: limitedCoords.y - y
                }
            };
        }
    };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = function(options) {
    if (options === void 0) options = {};
    return {
        options,
        fn (state) {
            const { x , y , placement , rects , middlewareData  } = state;
            const { offset =0 , mainAxis: checkMainAxis = true , crossAxis: checkCrossAxis = true  } = (0, _utils.evaluate)(options, state);
            const coords = {
                x,
                y
            };
            const crossAxis = (0, _utils.getSideAxis)(placement);
            const mainAxis = (0, _utils.getOppositeAxis)(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = (0, _utils.evaluate)(offset, state);
            const computedOffset = typeof rawOffset === "number" ? {
                mainAxis: rawOffset,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset
            };
            if (checkMainAxis) {
                const len = mainAxis === "y" ? "height" : "width";
                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
                if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;
                else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;
            }
            if (checkCrossAxis) {
                var _middlewareData$offse, _middlewareData$offse2;
                const len1 = mainAxis === "y" ? "width" : "height";
                const isOriginSide = [
                    "top",
                    "left"
                ].includes((0, _utils.getSide)(placement));
                const limitMin1 = rects.reference[crossAxis] - rects.floating[len1] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
                const limitMax1 = rects.reference[crossAxis] + rects.reference[len1] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
                if (crossAxisCoord < limitMin1) crossAxisCoord = limitMin1;
                else if (crossAxisCoord > limitMax1) crossAxisCoord = limitMax1;
            }
            return {
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            };
        }
    };
};
/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = function(options) {
    if (options === void 0) options = {};
    return {
        name: "size",
        options,
        async fn (state) {
            const { placement , rects , platform , elements  } = state;
            const { apply =()=>{} , ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const side = (0, _utils.getSide)(placement);
            const alignment = (0, _utils.getAlignment)(placement);
            const isYAxis = (0, _utils.getSideAxis)(placement) === "y";
            const { width , height  } = rects.floating;
            let heightSide;
            let widthSide;
            if (side === "top" || side === "bottom") {
                heightSide = side;
                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
            } else {
                widthSide = side;
                heightSide = alignment === "end" ? "top" : "bottom";
            }
            const overflowAvailableHeight = height - overflow[heightSide];
            const overflowAvailableWidth = width - overflow[widthSide];
            const noShift = !state.middlewareData.shift;
            let availableHeight = overflowAvailableHeight;
            let availableWidth = overflowAvailableWidth;
            if (isYAxis) {
                const maximumClippingWidth = width - overflow.left - overflow.right;
                availableWidth = alignment || noShift ? (0, _utils.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
            } else {
                const maximumClippingHeight = height - overflow.top - overflow.bottom;
                availableHeight = alignment || noShift ? (0, _utils.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
            }
            if (noShift && !alignment) {
                const xMin = (0, _utils.max)(overflow.left, 0);
                const xMax = (0, _utils.max)(overflow.right, 0);
                const yMin = (0, _utils.max)(overflow.top, 0);
                const yMax = (0, _utils.max)(overflow.bottom, 0);
                if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0, _utils.max)(overflow.left, overflow.right));
                else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0, _utils.max)(overflow.top, overflow.bottom));
            }
            await apply({
                ...state,
                availableWidth,
                availableHeight
            });
            const nextDimensions = await platform.getDimensions(elements.floating);
            if (width !== nextDimensions.width || height !== nextDimensions.height) return {
                reset: {
                    rects: true
                }
            };
            return {};
        }
    };
};

},{"@floating-ui/utils":"1NiOn","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1NiOn":[function(require,module,exports) {
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alignments", ()=>alignments);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "createCoords", ()=>createCoords);
parcelHelpers.export(exports, "evaluate", ()=>evaluate);
parcelHelpers.export(exports, "expandPaddingObject", ()=>expandPaddingObject);
parcelHelpers.export(exports, "floor", ()=>floor);
parcelHelpers.export(exports, "getAlignment", ()=>getAlignment);
parcelHelpers.export(exports, "getAlignmentAxis", ()=>getAlignmentAxis);
parcelHelpers.export(exports, "getAlignmentSides", ()=>getAlignmentSides);
parcelHelpers.export(exports, "getAxisLength", ()=>getAxisLength);
parcelHelpers.export(exports, "getExpandedPlacements", ()=>getExpandedPlacements);
parcelHelpers.export(exports, "getOppositeAlignmentPlacement", ()=>getOppositeAlignmentPlacement);
parcelHelpers.export(exports, "getOppositeAxis", ()=>getOppositeAxis);
parcelHelpers.export(exports, "getOppositeAxisPlacements", ()=>getOppositeAxisPlacements);
parcelHelpers.export(exports, "getOppositePlacement", ()=>getOppositePlacement);
parcelHelpers.export(exports, "getPaddingObject", ()=>getPaddingObject);
parcelHelpers.export(exports, "getSide", ()=>getSide);
parcelHelpers.export(exports, "getSideAxis", ()=>getSideAxis);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "placements", ()=>placements);
parcelHelpers.export(exports, "rectToClientRect", ()=>rectToClientRect);
parcelHelpers.export(exports, "round", ()=>round);
parcelHelpers.export(exports, "sides", ()=>sides);
const sides = [
    "top",
    "right",
    "bottom",
    "left"
];
const alignments = [
    "start",
    "end"
];
const placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v)=>({
        x: v,
        y: v
    });
const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
const oppositeAlignmentMap = {
    start: "end",
    end: "start"
};
function clamp(start, value, end) {
    return max(start, min(value, end));
}
function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
    return placement.split("-")[0];
}
function getAlignment(placement) {
    return placement.split("-")[1];
}
function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
    return [
        "top",
        "bottom"
    ].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) rtl = false;
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    return [
        mainAlignmentSide,
        getOppositePlacement(mainAlignmentSide)
    ];
}
function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeAlignmentPlacement(placement),
        oppositePlacement,
        getOppositeAlignmentPlacement(oppositePlacement)
    ];
}
function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
    const lr = [
        "left",
        "right"
    ];
    const rl = [
        "right",
        "left"
    ];
    const tb = [
        "top",
        "bottom"
    ];
    const bt = [
        "bottom",
        "top"
    ];
    switch(side){
        case "top":
        case "bottom":
            if (rtl) return isStart ? rl : lr;
            return isStart ? lr : rl;
        case "left":
        case "right":
            return isStart ? tb : bt;
        default:
            return [];
    }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
        list = list.map((side)=>side + "-" + alignment);
        if (flipAlignment) list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
    return list;
}
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
    };
}
function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
    };
}
function rectToClientRect(rect) {
    return {
        ...rect,
        top: rect.y,
        left: rect.x,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6AalP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getComputedStyle", ()=>getComputedStyle);
parcelHelpers.export(exports, "getContainingBlock", ()=>getContainingBlock);
parcelHelpers.export(exports, "getDocumentElement", ()=>getDocumentElement);
parcelHelpers.export(exports, "getNearestOverflowAncestor", ()=>getNearestOverflowAncestor);
parcelHelpers.export(exports, "getNodeName", ()=>getNodeName);
parcelHelpers.export(exports, "getNodeScroll", ()=>getNodeScroll);
parcelHelpers.export(exports, "getOverflowAncestors", ()=>getOverflowAncestors);
parcelHelpers.export(exports, "getParentNode", ()=>getParentNode);
parcelHelpers.export(exports, "getWindow", ()=>getWindow);
parcelHelpers.export(exports, "isContainingBlock", ()=>isContainingBlock);
parcelHelpers.export(exports, "isElement", ()=>isElement);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement);
parcelHelpers.export(exports, "isLastTraversableNode", ()=>isLastTraversableNode);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isOverflowElement", ()=>isOverflowElement);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot);
parcelHelpers.export(exports, "isTableElement", ()=>isTableElement);
parcelHelpers.export(exports, "isWebKit", ()=>isWebKit);
function getNodeName(node) {
    if (isNode(node)) return (node.nodeName || "").toLowerCase();
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return "#document";
}
function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
    return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
    return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
    // Browsers without `ShadowRoot` support.
    if (typeof ShadowRoot === "undefined") return false;
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
    const { overflow , overflowX , overflowY , display  } = getComputedStyle(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
        "inline",
        "contents"
    ].includes(display);
}
function isTableElement(element) {
    return [
        "table",
        "td",
        "th"
    ].includes(getNodeName(element));
}
function isContainingBlock(element) {
    const webkit = isWebKit();
    const css = getComputedStyle(element);
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || [
        "transform",
        "perspective",
        "filter"
    ].some((value)=>(css.willChange || "").includes(value)) || [
        "paint",
        "layout",
        "strict",
        "content"
    ].some((value)=>(css.contain || "").includes(value));
}
function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){
        if (isContainingBlock(currentNode)) return currentNode;
        else currentNode = getParentNode(currentNode);
    }
    return null;
}
function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
    return [
        "html",
        "body",
        "#document"
    ].includes(getNodeName(node));
}
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
    if (isElement(element)) return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
    return {
        scrollLeft: element.pageXOffset,
        scrollTop: element.pageYOffset
    };
}
function getParentNode(node) {
    if (getNodeName(node) === "html") return node;
    const result = // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) list = [];
    if (traverseIframes === void 0) traverseIframes = true;
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jVksD":[function(require,module,exports) {
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NumberFormatter", ()=>$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5);
parcelHelpers.export(exports, "NumberParser", ()=>$6c7bd7858deea686$export$cd11ab140839f11d);
let $488c6ddbf4ef74c2$var$formatterCache = new Map();
let $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
    // @ts-ignore
    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
        signDisplay: "exceptZero"
    }).resolvedOptions().signDisplay === "exceptZero";
// eslint-disable-next-line no-empty
} catch (e) {}
let $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
    // @ts-ignore
    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
        style: "unit",
        unit: "degree"
    }).resolvedOptions().style === "unit";
// eslint-disable-next-line no-empty
} catch (e1) {}
// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.
// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.
// Values were determined by switching to each locale manually in Chrome.
const $488c6ddbf4ef74c2$var$UNITS = {
    degree: {
        narrow: {
            default: "\xb0",
            "ja-JP": " 度",
            "zh-TW": "度",
            "sl-SI": " \xb0"
        }
    }
};
class $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {
    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {
        let res = "";
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
        else res = this.numberFormatter.format(value);
        if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
            var _UNITS_unit;
            let { unit: unit , unitDisplay: unitDisplay = "short" , locale: locale  } = this.resolvedOptions();
            if (!unit) return res;
            let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
            res += values[locale] || values.default;
        }
        return res;
    }
    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {
        // TODO: implement signDisplay for formatToParts
        // @ts-ignore
        return this.numberFormatter.formatToParts(value);
    }
    /** Formats a number range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        // Very basic fallback for old browsers.
        return `${this.format(start)} \u{2013} ${this.format(end)}`;
    }
    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        let startParts = this.numberFormatter.formatToParts(start);
        let endParts = this.numberFormatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: "startRange"
                })),
            {
                type: "literal",
                value: " – ",
                source: "shared"
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: "endRange"
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let options = this.numberFormatter.resolvedOptions();
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
            ...options,
            signDisplay: this.options.signDisplay
        };
        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
            ...options,
            style: "unit",
            unit: this.options.unit,
            unitDisplay: this.options.unitDisplay
        };
        return options;
    }
    constructor(locale, options = {}){
        this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
        this.options = options;
    }
}
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
    let { numberingSystem: numberingSystem  } = options;
    if (numberingSystem && locale.includes("-nu-")) {
        if (!locale.includes("-u-")) locale += "-u-";
        locale += `-nu-${numberingSystem}`;
    }
    if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
        var _UNITS_unit;
        let { unit: unit , unitDisplay: unitDisplay = "short"  } = options;
        if (!unit) throw new Error('unit option must be provided with style: "unit"');
        if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
        options = {
            ...options,
            style: "decimal"
        };
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.NumberFormat(locale, options);
    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
    if (signDisplay === "auto") return numberFormat.format(num);
    else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
    else {
        let needsPositiveSign = false;
        if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
        else if (signDisplay === "exceptZero") {
            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
            else needsPositiveSign = num > 0;
        }
        if (needsPositiveSign) {
            let negative = numberFormat.format(-num);
            let noSign = numberFormat.format(num);
            // ignore RTL/LTR marker character
            let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
            if ([
                ...minus
            ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
            let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
            return positive;
        } else return numberFormat.format(num);
    }
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
    "latn",
    "arab",
    "hanidec"
];
class $6c7bd7858deea686$export$cd11ab140839f11d {
    /**
   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
   */ parse(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
    }
    /**
   * Returns whether the given string could potentially be a valid number. This should be used to
   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
   * of the minus/plus sign characters can be checked.
   */ isValidPartialNumber(value, minValue, maxValue) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
    }
    /**
   * Returns a numbering system for which the given string is valid in the current locale.
   * If no numbering system could be detected, the default numbering system for the current
   * locale is returned.
   */ getNumberingSystem(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.options = options;
    }
}
const $6c7bd7858deea686$var$numberParserCache = new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
    // First try the default numbering system for the provided locale
    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
    // If that doesn't match, and the locale doesn't include a hard coded numbering system,
    // try each of the other supported numbering systems until we find one that matches.
    if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {
            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
            if (parser.isValidPartialNumber(value)) return parser;
        }
    }
    return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
    if (!parser) {
        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
    }
    return parser;
}
// The actual number parser implementation. Instances of this class are cached
// based on the locale, options, and detected numbering system.
class $6c7bd7858deea686$var$NumberParserImpl {
    parse(value) {
        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'
        let fullySanitizedValue = this.sanitize(value);
        if (this.symbols.group) fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
        if (this.options.style === "percent") {
            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing
            let isNegative = fullySanitizedValue.indexOf("-");
            fullySanitizedValue = fullySanitizedValue.replace("-", "");
            let index = fullySanitizedValue.indexOf(".");
            if (index === -1) index = fullySanitizedValue.length;
            fullySanitizedValue = fullySanitizedValue.replace(".", "");
            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
            else if (index - 2 === -2) fullySanitizedValue = "0.00";
            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
        }
        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
        if (isNaN(newValue)) return NaN;
        if (this.options.style === "percent") {
            // extra step for rounding percents to what our formatter would output
            let options = {
                ...this.options,
                style: "decimal",
                minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),
                maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)
            };
            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(this.locale, options).format(newValue));
        }
        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again
        if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
        return newValue;
    }
    sanitize(value) {
        // Remove literals and whitespace, which are allowed anywhere in the string
        value = value.replace(this.symbols.literals, "");
        // Replace the ASCII minus sign with the minus sign used in the current locale
        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.
        if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that
        // instead they use the , (44) character or apparently the (1548) character.
        if (this.options.numberingSystem === "arab") {
            if (this.symbols.decimal) {
                value = value.replace(",", this.symbols.decimal);
                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
            }
            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
        }
        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,
        // so allow 'period' as a group char and replace it with a space
        if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
        return value;
    }
    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
        value = this.sanitize(value);
        // Remove minus or plus sign, which must be at the start of the string.
        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
        // Numbers cannot start with a group separator
        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
        // Numbers that can't have any decimal values fail if a decimal character is typed
        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
        // Remove numerals, groups, and decimals
        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
        value = value.replace(this.symbols.numeral, "");
        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
        // The number is valid if there are no remaining characters
        return value.length === 0;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.formatter = new Intl.NumberFormat(locale, options);
        this.options = this.formatter.resolvedOptions();
        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
        if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
    }
}
const $6c7bd7858deea686$var$nonLiteralParts = new Set([
    "decimal",
    "fraction",
    "integer",
    "minusSign",
    "plusSign",
    "group"
]);
// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes
// all unique numbers which we need to check in order to determine all the plural forms for a given locale.
// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script
const $6c7bd7858deea686$var$pluralNumbers = [
    0,
    4,
    2,
    1,
    11,
    20,
    3,
    7,
    100,
    21,
    0.1,
    1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set
    let symbolFormatter = new Intl.NumberFormat(locale, {
        ...intlOptions,
        minimumSignificantDigits: 1,
        maximumSignificantDigits: 21
    });
    // Note: some locale's don't add a group symbol until there is a ten thousands place
    let allParts = symbolFormatter.formatToParts(-10000.111);
    let posAllParts = symbolFormatter.formatToParts(10000.111);
    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));
    var _allParts_find_value;
    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
    // Safari does not support the signDisplay option, but our number parser polyfills it.
    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.
    // @ts-ignore
    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters
    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal
    let decimalParts = new Intl.NumberFormat(locale, {
        ...intlOptions,
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).formatToParts(0.001);
    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
    let group = (_allParts_find1 = allParts.find((p)=>p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that
    // don't contribute to the numerical value
    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));
    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));
    let sortedLiterals = [
        ...new Set([
            ...allPartsLiterals,
            ...pluralPartsLiterals
        ])
    ].sort((a, b)=>b.length - a.length);
    let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
    // These are for replacing non-latn characters with the latn equivalent
    let numerals = [
        ...new Intl.NumberFormat(intlOptions.locale, {
            useGrouping: false
        }).format(9876543210)
    ].reverse();
    let indexes = new Map(numerals.map((d, i)=>[
            d,
            i
        ]));
    let numeral = new RegExp(`[${numerals.join("")}]`, "g");
    let index = (d)=>String(indexes.get(d));
    return {
        minusSign: minusSign,
        plusSign: plusSign,
        decimal: decimal,
        group: group,
        literals: literals,
        numeral: numeral,
        index: index
    };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
    // @ts-ignore
    if (str.replaceAll) return str.replaceAll(find, replace);
    return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"aHTGG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _web = require("solid-js/web");
var _solidJs = require("solid-js");
var _button = require("./components/ui/button");
var _input = require("./components/ui/input");
var _tmpl$ = /*#__PURE__*/ (0, _web.template)(`<div class="flex flex-col gap-2"><h1>Instructions:</h1><ol class="pl-8 list-decimal list-inside space-y-1 flex flex-col"><li>Browse to <a href=https://www.humblebundle.com/ target=_blank>https://www.humblebundle.com/</a> and login.</li><li>Find the value of the cookie _simpleauth_sess.<div class=pl-8><p>Firefox: Open the <a href=https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector target=_blank>Storage Inspector</a></p><p>Chrome: Open the <a href=https://developer.chrome.com/devtools/docs/resource-panel#cookies target=_blank>Resource Panel</a></p><p>Safari: Open the Storage Tab of the <a href=https://developer.apple.com/safari/tools/ target=_blank>Web Inspector</a> (Context menu on the page, click Inspect page) click the Storage tab, select Cookies on the sidebar</p></div></li><li>Paste into _simpleauth_sess Cookie text field and click Save</li><li>Install the <a target=_blank href=https://github.com/InfoGata/infogata-extension>InfoGata Extension`), _tmpl$2 = /*#__PURE__*/ (0, _web.template)(`<li>You should now be able to browse yours books in Library`);
const sendUiMessage = (message)=>{
    parent.postMessage(message, "*");
};
const App = ()=>{
    const [extensionInstalled, setExtensionInstalled] = (0, _solidJs.createSignal)(true);
    const [simpleAuth, setSimpleAuth] = (0, _solidJs.createSignal)("");
    (0, _solidJs.createEffect)(()=>{
        const onMessage = (event)=>{
            switch(event.data.type){
                case "info":
                    setExtensionInstalled(event.data.extensionedInstalled);
                    setSimpleAuth(event.data.simpleAuth);
                    break;
                default:
                    const _exhaustive = event.data.type;
                    break;
            }
        };
        window.addEventListener("message", onMessage);
        sendUiMessage({
            type: "check-login"
        });
        return ()=>window.removeEventListener("message", onMessage);
    });
    const saveCookie = ()=>{
        sendUiMessage({
            type: "save",
            simpleAuth: simpleAuth()
        });
    };
    return (()=>{
        var _el$ = _tmpl$(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling;
        (0, _web.insert)(_el$3, (()=>{
            var _c$ = (0, _web.memo)(()=>!!extensionInstalled());
            return ()=>_c$() && _tmpl$2();
        })(), null);
        (0, _web.insert)(_el$, (0, _web.createComponent)((0, _input.Input), {
            placeholder: "_simpleauth_sess Cookie",
            get value () {
                return simpleAuth();
            },
            onChange: (e)=>{
                const value = e.currentTarget.value;
                setSimpleAuth(value);
            }
        }), null);
        (0, _web.insert)(_el$, (0, _web.createComponent)((0, _button.Button), {
            onClick: saveCookie,
            children: "Save"
        }), null);
        return _el$;
    })();
};
exports.default = App;

},{"solid-js/web":"eGRlU","solid-js":"f1z31","./components/ui/button":"2jCEc","./components/ui/input":"2kxMM","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2jCEc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Button", ()=>Button);
parcelHelpers.export(exports, "buttonVariants", ()=>buttonVariants);
var _web = require("solid-js/web");
var _solidJs = require("solid-js");
var _classVarianceAuthority = require("class-variance-authority");
var _utils = require("~/lib/utils");
var _tmpl$ = /*#__PURE__*/ (0, _web.template)(`<button>`);
const buttonVariants = (0, _classVarianceAuthority.cva)("ring-offset-background focus-visible:ring-ring inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline: "border-input hover:bg-accent hover:text-accent-foreground border",
            secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
});
const Button = (props)=>{
    const [, rest] = (0, _solidJs.splitProps)(props, [
        "variant",
        "size",
        "class"
    ]);
    return (()=>{
        var _el$ = _tmpl$();
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get ["class"] () {
                return (0, _utils.cn)(buttonVariants({
                    variant: props.variant,
                    size: props.size
                }), props.class);
            }
        }, rest), false, false);
        return _el$;
    })();
};

},{"solid-js/web":"eGRlU","solid-js":"f1z31","class-variance-authority":"gnEun","~/lib/utils":"duS4E","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gnEun":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cx", ()=>cx);
parcelHelpers.export(exports, "cva", ()=>cva);
var _clsx = require("clsx");
const falsyToString = (value)=>typeof value === "boolean" ? "".concat(value) : value === 0 ? "0" : value;
const cx = (0, _clsx.clsx);
const cva = (base, config)=>{
    return (props)=>{
        var ref;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants , defaultVariants  } = config;
        const getVariantClassNames = Object.keys(variants).map((variant)=>{
            const variantProp = props === null || props === void 0 ? void 0 : props[variant];
            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
            if (variantProp === null) return null;
            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
            return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{
            let [key, value] = param;
            if (value === undefined) return acc;
            acc[key] = value;
            return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (ref = config.compoundVariants) === null || ref === void 0 ? void 0 : ref.reduce((acc, param1)=>{
            let { class: cvClass , className: cvClassName , ...compoundVariantOptions } = param1;
            return Object.entries(compoundVariantOptions).every((param)=>{
                let [key, value] = param;
                return Array.isArray(value) ? value.includes({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                }[key]) : ({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                })[key] === value;
            }) ? [
                ...acc,
                cvClass,
                cvClassName
            ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
};

},{"clsx":"iJNKq","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"iJNKq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clsx", ()=>clsx);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) {
        if (Array.isArray(e)) for(t = 0; t < e.length; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
        else for(t in e)e[t] && (n && (n += " "), n += t);
    }
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = ""; f < arguments.length;)(e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
exports.default = clsx;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"duS4E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cn", ()=>cn);
var _clsx = require("clsx");
var _tailwindMerge = require("tailwind-merge");
function cn(...inputs) {
    return (0, _tailwindMerge.twMerge)((0, _clsx.clsx)(inputs));
}

},{"clsx":"cECVi","tailwind-merge":"e3EU8","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cECVi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clsx", ()=>clsx);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) {
        if (Array.isArray(e)) {
            var o = e.length;
            for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
        } else for(f in e)e[f] && (n && (n += " "), n += f);
    }
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
exports.default = clsx;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"e3EU8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const CLASS_PART_SEPARATOR = "-";
function createClassUtils(config) {
    const classMap = createClassMap(config);
    const { conflictingClassGroups , conflictingClassGroupModifiers  } = config;
    function getClassGroupId(className) {
        const classParts = className.split(CLASS_PART_SEPARATOR);
        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
        if (classParts[0] === "" && classParts.length !== 1) classParts.shift();
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    }
    function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
        const conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) return [
            ...conflicts,
            ...conflictingClassGroupModifiers[classGroupId]
        ];
        return conflicts;
    }
    return {
        getClassGroupId,
        getConflictingClassGroupIds
    };
}
function getGroupRecursive(classParts, classPartObject) {
    if (classParts.length === 0) return classPartObject.classGroupId;
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
    if (classGroupFromNextClassPart) return classGroupFromNextClassPart;
    if (classPartObject.validators.length === 0) return undefined;
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({ validator  })=>validator(classRest))?.classGroupId;
}
const arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
    if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
        if (property) // I use two dots here because one dot is used as prefix for class groups in plugins
        return "arbitrary.." + property;
    }
}
/**
 * Exported for testing only
 */ function createClassMap(config) {
    const { theme , prefix  } = config;
    const classMap = {
        nextPart: new Map(),
        validators: []
    };
    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
    prefixedClassGroupEntries.forEach(([classGroupId, classGroup])=>{
        processClassesRecursively(classGroup, classMap, classGroupId, theme);
    });
    return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
    classGroup.forEach((classDefinition)=>{
        if (typeof classDefinition === "string") {
            const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
            classPartObjectToEdit.classGroupId = classGroupId;
            return;
        }
        if (typeof classDefinition === "function") {
            if (isThemeGetter(classDefinition)) {
                processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
                return;
            }
            classPartObject.validators.push({
                validator: classDefinition,
                classGroupId
            });
            return;
        }
        Object.entries(classDefinition).forEach(([key, classGroup])=>{
            processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
        });
    });
}
function getPart(classPartObject, path) {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart)=>{
        if (!currentClassPartObject.nextPart.has(pathPart)) currentClassPartObject.nextPart.set(pathPart, {
            nextPart: new Map(),
            validators: []
        });
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
}
function isThemeGetter(func) {
    return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
    if (!prefix) return classGroupEntries;
    return classGroupEntries.map(([classGroupId, classGroup])=>{
        const prefixedClassGroup = classGroup.map((classDefinition)=>{
            if (typeof classDefinition === "string") return prefix + classDefinition;
            if (typeof classDefinition === "object") return Object.fromEntries(Object.entries(classDefinition).map(([key, value])=>[
                    prefix + key,
                    value
                ]));
            return classDefinition;
        });
        return [
            classGroupId,
            prefixedClassGroup
        ];
    });
}
// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
function createLruCache(maxCacheSize) {
    if (maxCacheSize < 1) return {
        get: ()=>undefined,
        set: ()=>{}
    };
    let cacheSize = 0;
    let cache = new Map();
    let previousCache = new Map();
    function update(key, value) {
        cache.set(key, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
            cacheSize = 0;
            previousCache = cache;
            cache = new Map();
        }
    }
    return {
        get (key) {
            let value = cache.get(key);
            if (value !== undefined) return value;
            if ((value = previousCache.get(key)) !== undefined) {
                update(key, value);
                return value;
            }
        },
        set (key, value) {
            if (cache.has(key)) cache.set(key, value);
            else update(key, value);
        }
    };
}
const IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config) {
    const separator = config.separator;
    const isSeparatorSingleCharacter = separator.length === 1;
    const firstSeparatorCharacter = separator[0];
    const separatorLength = separator.length;
    // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
    return function splitModifiers(className) {
        const modifiers = [];
        let bracketDepth = 0;
        let modifierStart = 0;
        let postfixModifierPosition;
        for(let index = 0; index < className.length; index++){
            let currentCharacter = className[index];
            if (bracketDepth === 0) {
                if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
                    modifiers.push(className.slice(modifierStart, index));
                    modifierStart = index + separatorLength;
                    continue;
                }
                if (currentCharacter === "/") {
                    postfixModifierPosition = index;
                    continue;
                }
            }
            if (currentCharacter === "[") bracketDepth++;
            else if (currentCharacter === "]") bracketDepth--;
        }
        const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
        const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
        const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
        return {
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition
        };
    };
}
/**
 * Sorts modifiers according to following schema:
 * - Predefined modifiers are sorted alphabetically
 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
 */ function sortModifiers(modifiers) {
    if (modifiers.length <= 1) return modifiers;
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier)=>{
        const isArbitraryVariant = modifier[0] === "[";
        if (isArbitraryVariant) {
            sortedModifiers.push(...unsortedModifiers.sort(), modifier);
            unsortedModifiers = [];
        } else unsortedModifiers.push(modifier);
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
}
function createConfigUtils(config) {
    return {
        cache: createLruCache(config.cacheSize),
        splitModifiers: createSplitModifiers(config),
        ...createClassUtils(config)
    };
}
const SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
    const { splitModifiers , getClassGroupId , getConflictingClassGroupIds  } = configUtils;
    /**
   * Set of classGroupIds in following format:
   * `{importantModifier}{variantModifiers}{classGroupId}`
   * @example 'float'
   * @example 'hover:focus:bg-color'
   * @example 'md:!pr'
   */ const classGroupsInConflict = new Set();
    return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName)=>{
        const { modifiers , hasImportantModifier , baseClassName , maybePostfixModifierPosition  } = splitModifiers(originalClassName);
        let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
        if (!classGroupId) {
            if (!maybePostfixModifierPosition) return {
                isTailwindClass: false,
                originalClassName
            };
            classGroupId = getClassGroupId(baseClassName);
            if (!classGroupId) return {
                isTailwindClass: false,
                originalClassName
            };
            hasPostfixModifier = false;
        }
        const variantModifier = sortModifiers(modifiers).join(":");
        const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        return {
            isTailwindClass: true,
            modifierId,
            classGroupId,
            originalClassName,
            hasPostfixModifier
        };
    }).reverse()// Last class in conflict wins, so we need to filter conflicting classes in reverse order.
    .filter((parsed)=>{
        if (!parsed.isTailwindClass) return true;
        const { modifierId , classGroupId , hasPostfixModifier  } = parsed;
        const classId = modifierId + classGroupId;
        if (classGroupsInConflict.has(classId)) return false;
        classGroupsInConflict.add(classId);
        getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group)=>classGroupsInConflict.add(modifierId + group));
        return true;
    }).reverse().map((parsed)=>parsed.originalClassName).join(" ");
}
/**
 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
 *
 * Specifically:
 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
 *
 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
 */ function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = "";
    while(index < arguments.length){
        if (argument = arguments[index++]) {
            if (resolvedValue = toValue(argument)) {
                string && (string += " ");
                string += resolvedValue;
            }
        }
    }
    return string;
}
function toValue(mix) {
    if (typeof mix === "string") return mix;
    let resolvedValue;
    let string = "";
    for(let k = 0; k < mix.length; k++){
        if (mix[k]) {
            if (resolvedValue = toValue(mix[k])) {
                string && (string += " ");
                string += resolvedValue;
            }
        }
    }
    return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
        const config = createConfigRest.reduce((previousConfig, createConfigCurrent)=>createConfigCurrent(previousConfig), createConfigFirst());
        configUtils = createConfigUtils(config);
        cacheGet = configUtils.cache.get;
        cacheSet = configUtils.cache.set;
        functionToCall = tailwindMerge;
        return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
        const cachedResult = cacheGet(classList);
        if (cachedResult) return cachedResult;
        const result = mergeClassList(classList, configUtils);
        cacheSet(classList, result);
        return result;
    }
    return function callTailwindMerge() {
        return functionToCall(twJoin.apply(null, arguments));
    };
}
function fromTheme(key) {
    const themeGetter = (theme)=>theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
}
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /*#__PURE__*/ new Set([
    "px",
    "full",
    "screen"
]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
// Shadow always begins with x and y offset separated by underscore
const shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function isLength(value) {
    return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
    return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
    return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
    return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger(value) {
    return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
    return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
    return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
    return tshirtUnitRegex.test(value);
}
const sizeLabels = /*#__PURE__*/ new Set([
    "length",
    "size",
    "percentage"
]);
function isArbitrarySize(value) {
    return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
    return getIsArbitraryValue(value, "position", isNever);
}
const imageLabels = /*#__PURE__*/ new Set([
    "image",
    "url"
]);
function isArbitraryImage(value) {
    return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
    return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
    return true;
}
function getIsArbitraryValue(value, label, testValue) {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
        if (result[1]) return typeof label === "string" ? result[1] === label : label.has(result[1]);
        return testValue(result[2]);
    }
    return false;
}
function isLengthOnly(value) {
    return lengthUnitRegex.test(value);
}
function isNever() {
    return false;
}
function isShadow(value) {
    return shadowRegex.test(value);
}
function isImage(value) {
    return imageRegex.test(value);
}
const validators = /*#__PURE__*/ Object.defineProperty({
    __proto__: null,
    isAny,
    isArbitraryImage,
    isArbitraryLength,
    isArbitraryNumber,
    isArbitraryPosition,
    isArbitraryShadow,
    isArbitrarySize,
    isArbitraryValue,
    isInteger,
    isLength,
    isNumber,
    isPercent,
    isTshirtSize
}, Symbol.toStringTag, {
    value: "Module"
});
function getDefaultConfig() {
    const colors = fromTheme("colors");
    const spacing = fromTheme("spacing");
    const blur = fromTheme("blur");
    const brightness = fromTheme("brightness");
    const borderColor = fromTheme("borderColor");
    const borderRadius = fromTheme("borderRadius");
    const borderSpacing = fromTheme("borderSpacing");
    const borderWidth = fromTheme("borderWidth");
    const contrast = fromTheme("contrast");
    const grayscale = fromTheme("grayscale");
    const hueRotate = fromTheme("hueRotate");
    const invert = fromTheme("invert");
    const gap = fromTheme("gap");
    const gradientColorStops = fromTheme("gradientColorStops");
    const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
    const inset = fromTheme("inset");
    const margin = fromTheme("margin");
    const opacity = fromTheme("opacity");
    const padding = fromTheme("padding");
    const saturate = fromTheme("saturate");
    const scale = fromTheme("scale");
    const sepia = fromTheme("sepia");
    const skew = fromTheme("skew");
    const space = fromTheme("space");
    const translate = fromTheme("translate");
    const getOverscroll = ()=>[
            "auto",
            "contain",
            "none"
        ];
    const getOverflow = ()=>[
            "auto",
            "hidden",
            "clip",
            "visible",
            "scroll"
        ];
    const getSpacingWithAutoAndArbitrary = ()=>[
            "auto",
            isArbitraryValue,
            spacing
        ];
    const getSpacingWithArbitrary = ()=>[
            isArbitraryValue,
            spacing
        ];
    const getLengthWithEmptyAndArbitrary = ()=>[
            "",
            isLength,
            isArbitraryLength
        ];
    const getNumberWithAutoAndArbitrary = ()=>[
            "auto",
            isNumber,
            isArbitraryValue
        ];
    const getPositions = ()=>[
            "bottom",
            "center",
            "left",
            "left-bottom",
            "left-top",
            "right",
            "right-bottom",
            "right-top",
            "top"
        ];
    const getLineStyles = ()=>[
            "solid",
            "dashed",
            "dotted",
            "double",
            "none"
        ];
    const getBlendModes = ()=>[
            "normal",
            "multiply",
            "screen",
            "overlay",
            "darken",
            "lighten",
            "color-dodge",
            "color-burn",
            "hard-light",
            "soft-light",
            "difference",
            "exclusion",
            "hue",
            "saturation",
            "color",
            "luminosity",
            "plus-lighter"
        ];
    const getAlign = ()=>[
            "start",
            "end",
            "center",
            "between",
            "around",
            "evenly",
            "stretch"
        ];
    const getZeroAndEmpty = ()=>[
            "",
            "0",
            isArbitraryValue
        ];
    const getBreaks = ()=>[
            "auto",
            "avoid",
            "all",
            "avoid-page",
            "page",
            "left",
            "right",
            "column"
        ];
    const getNumber = ()=>[
            isNumber,
            isArbitraryNumber
        ];
    const getNumberAndArbitrary = ()=>[
            isNumber,
            isArbitraryValue
        ];
    return {
        cacheSize: 500,
        separator: ":",
        theme: {
            colors: [
                isAny
            ],
            spacing: [
                isLength,
                isArbitraryLength
            ],
            blur: [
                "none",
                "",
                isTshirtSize,
                isArbitraryValue
            ],
            brightness: getNumber(),
            borderColor: [
                colors
            ],
            borderRadius: [
                "none",
                "",
                "full",
                isTshirtSize,
                isArbitraryValue
            ],
            borderSpacing: getSpacingWithArbitrary(),
            borderWidth: getLengthWithEmptyAndArbitrary(),
            contrast: getNumber(),
            grayscale: getZeroAndEmpty(),
            hueRotate: getNumberAndArbitrary(),
            invert: getZeroAndEmpty(),
            gap: getSpacingWithArbitrary(),
            gradientColorStops: [
                colors
            ],
            gradientColorStopPositions: [
                isPercent,
                isArbitraryLength
            ],
            inset: getSpacingWithAutoAndArbitrary(),
            margin: getSpacingWithAutoAndArbitrary(),
            opacity: getNumber(),
            padding: getSpacingWithArbitrary(),
            saturate: getNumber(),
            scale: getNumber(),
            sepia: getZeroAndEmpty(),
            skew: getNumberAndArbitrary(),
            space: getSpacingWithArbitrary(),
            translate: getSpacingWithArbitrary()
        },
        classGroups: {
            // Layout
            /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */ aspect: [
                {
                    aspect: [
                        "auto",
                        "square",
                        "video",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */ container: [
                "container"
            ],
            /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */ columns: [
                {
                    columns: [
                        isTshirtSize
                    ]
                }
            ],
            /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */ "break-after": [
                {
                    "break-after": getBreaks()
                }
            ],
            /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */ "break-before": [
                {
                    "break-before": getBreaks()
                }
            ],
            /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */ "break-inside": [
                {
                    "break-inside": [
                        "auto",
                        "avoid",
                        "avoid-page",
                        "avoid-column"
                    ]
                }
            ],
            /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */ "box-decoration": [
                {
                    "box-decoration": [
                        "slice",
                        "clone"
                    ]
                }
            ],
            /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */ box: [
                {
                    box: [
                        "border",
                        "content"
                    ]
                }
            ],
            /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */ display: [
                "block",
                "inline-block",
                "inline",
                "flex",
                "inline-flex",
                "table",
                "inline-table",
                "table-caption",
                "table-cell",
                "table-column",
                "table-column-group",
                "table-footer-group",
                "table-header-group",
                "table-row-group",
                "table-row",
                "flow-root",
                "grid",
                "inline-grid",
                "contents",
                "list-item",
                "hidden"
            ],
            /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */ float: [
                {
                    float: [
                        "right",
                        "left",
                        "none",
                        "start",
                        "end"
                    ]
                }
            ],
            /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */ clear: [
                {
                    clear: [
                        "left",
                        "right",
                        "both",
                        "none",
                        "start",
                        "end"
                    ]
                }
            ],
            /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */ isolation: [
                "isolate",
                "isolation-auto"
            ],
            /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */ "object-fit": [
                {
                    object: [
                        "contain",
                        "cover",
                        "fill",
                        "none",
                        "scale-down"
                    ]
                }
            ],
            /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */ "object-position": [
                {
                    object: [
                        ...getPositions(),
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */ overflow: [
                {
                    overflow: getOverflow()
                }
            ],
            /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */ "overflow-x": [
                {
                    "overflow-x": getOverflow()
                }
            ],
            /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */ "overflow-y": [
                {
                    "overflow-y": getOverflow()
                }
            ],
            /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ overscroll: [
                {
                    overscroll: getOverscroll()
                }
            ],
            /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ "overscroll-x": [
                {
                    "overscroll-x": getOverscroll()
                }
            ],
            /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ "overscroll-y": [
                {
                    "overscroll-y": getOverscroll()
                }
            ],
            /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */ position: [
                "static",
                "fixed",
                "absolute",
                "relative",
                "sticky"
            ],
            /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ inset: [
                {
                    inset: [
                        inset
                    ]
                }
            ],
            /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ "inset-x": [
                {
                    "inset-x": [
                        inset
                    ]
                }
            ],
            /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ "inset-y": [
                {
                    "inset-y": [
                        inset
                    ]
                }
            ],
            /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ start: [
                {
                    start: [
                        inset
                    ]
                }
            ],
            /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ end: [
                {
                    end: [
                        inset
                    ]
                }
            ],
            /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ top: [
                {
                    top: [
                        inset
                    ]
                }
            ],
            /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ right: [
                {
                    right: [
                        inset
                    ]
                }
            ],
            /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ bottom: [
                {
                    bottom: [
                        inset
                    ]
                }
            ],
            /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ left: [
                {
                    left: [
                        inset
                    ]
                }
            ],
            /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */ visibility: [
                "visible",
                "invisible",
                "collapse"
            ],
            /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */ z: [
                {
                    z: [
                        "auto",
                        isInteger,
                        isArbitraryValue
                    ]
                }
            ],
            // Flexbox and Grid
            /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */ basis: [
                {
                    basis: getSpacingWithAutoAndArbitrary()
                }
            ],
            /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */ "flex-direction": [
                {
                    flex: [
                        "row",
                        "row-reverse",
                        "col",
                        "col-reverse"
                    ]
                }
            ],
            /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */ "flex-wrap": [
                {
                    flex: [
                        "wrap",
                        "wrap-reverse",
                        "nowrap"
                    ]
                }
            ],
            /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */ flex: [
                {
                    flex: [
                        "1",
                        "auto",
                        "initial",
                        "none",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */ grow: [
                {
                    grow: getZeroAndEmpty()
                }
            ],
            /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */ shrink: [
                {
                    shrink: getZeroAndEmpty()
                }
            ],
            /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */ order: [
                {
                    order: [
                        "first",
                        "last",
                        "none",
                        isInteger,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */ "grid-cols": [
                {
                    "grid-cols": [
                        isAny
                    ]
                }
            ],
            /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */ "col-start-end": [
                {
                    col: [
                        "auto",
                        {
                            span: [
                                "full",
                                isInteger,
                                isArbitraryValue
                            ]
                        },
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */ "col-start": [
                {
                    "col-start": getNumberWithAutoAndArbitrary()
                }
            ],
            /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */ "col-end": [
                {
                    "col-end": getNumberWithAutoAndArbitrary()
                }
            ],
            /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */ "grid-rows": [
                {
                    "grid-rows": [
                        isAny
                    ]
                }
            ],
            /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */ "row-start-end": [
                {
                    row: [
                        "auto",
                        {
                            span: [
                                isInteger,
                                isArbitraryValue
                            ]
                        },
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */ "row-start": [
                {
                    "row-start": getNumberWithAutoAndArbitrary()
                }
            ],
            /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */ "row-end": [
                {
                    "row-end": getNumberWithAutoAndArbitrary()
                }
            ],
            /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */ "grid-flow": [
                {
                    "grid-flow": [
                        "row",
                        "col",
                        "dense",
                        "row-dense",
                        "col-dense"
                    ]
                }
            ],
            /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */ "auto-cols": [
                {
                    "auto-cols": [
                        "auto",
                        "min",
                        "max",
                        "fr",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */ "auto-rows": [
                {
                    "auto-rows": [
                        "auto",
                        "min",
                        "max",
                        "fr",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */ gap: [
                {
                    gap: [
                        gap
                    ]
                }
            ],
            /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */ "gap-x": [
                {
                    "gap-x": [
                        gap
                    ]
                }
            ],
            /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */ "gap-y": [
                {
                    "gap-y": [
                        gap
                    ]
                }
            ],
            /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */ "justify-content": [
                {
                    justify: [
                        "normal",
                        ...getAlign()
                    ]
                }
            ],
            /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */ "justify-items": [
                {
                    "justify-items": [
                        "start",
                        "end",
                        "center",
                        "stretch"
                    ]
                }
            ],
            /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */ "justify-self": [
                {
                    "justify-self": [
                        "auto",
                        "start",
                        "end",
                        "center",
                        "stretch"
                    ]
                }
            ],
            /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */ "align-content": [
                {
                    content: [
                        "normal",
                        ...getAlign(),
                        "baseline"
                    ]
                }
            ],
            /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */ "align-items": [
                {
                    items: [
                        "start",
                        "end",
                        "center",
                        "baseline",
                        "stretch"
                    ]
                }
            ],
            /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */ "align-self": [
                {
                    self: [
                        "auto",
                        "start",
                        "end",
                        "center",
                        "stretch",
                        "baseline"
                    ]
                }
            ],
            /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */ "place-content": [
                {
                    "place-content": [
                        ...getAlign(),
                        "baseline"
                    ]
                }
            ],
            /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */ "place-items": [
                {
                    "place-items": [
                        "start",
                        "end",
                        "center",
                        "baseline",
                        "stretch"
                    ]
                }
            ],
            /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */ "place-self": [
                {
                    "place-self": [
                        "auto",
                        "start",
                        "end",
                        "center",
                        "stretch"
                    ]
                }
            ],
            // Spacing
            /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */ p: [
                {
                    p: [
                        padding
                    ]
                }
            ],
            /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */ px: [
                {
                    px: [
                        padding
                    ]
                }
            ],
            /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */ py: [
                {
                    py: [
                        padding
                    ]
                }
            ],
            /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */ ps: [
                {
                    ps: [
                        padding
                    ]
                }
            ],
            /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */ pe: [
                {
                    pe: [
                        padding
                    ]
                }
            ],
            /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */ pt: [
                {
                    pt: [
                        padding
                    ]
                }
            ],
            /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */ pr: [
                {
                    pr: [
                        padding
                    ]
                }
            ],
            /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */ pb: [
                {
                    pb: [
                        padding
                    ]
                }
            ],
            /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */ pl: [
                {
                    pl: [
                        padding
                    ]
                }
            ],
            /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */ m: [
                {
                    m: [
                        margin
                    ]
                }
            ],
            /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */ mx: [
                {
                    mx: [
                        margin
                    ]
                }
            ],
            /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */ my: [
                {
                    my: [
                        margin
                    ]
                }
            ],
            /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */ ms: [
                {
                    ms: [
                        margin
                    ]
                }
            ],
            /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */ me: [
                {
                    me: [
                        margin
                    ]
                }
            ],
            /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */ mt: [
                {
                    mt: [
                        margin
                    ]
                }
            ],
            /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */ mr: [
                {
                    mr: [
                        margin
                    ]
                }
            ],
            /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */ mb: [
                {
                    mb: [
                        margin
                    ]
                }
            ],
            /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */ ml: [
                {
                    ml: [
                        margin
                    ]
                }
            ],
            /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */ "space-x": [
                {
                    "space-x": [
                        space
                    ]
                }
            ],
            /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */ "space-x-reverse": [
                "space-x-reverse"
            ],
            /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */ "space-y": [
                {
                    "space-y": [
                        space
                    ]
                }
            ],
            /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */ "space-y-reverse": [
                "space-y-reverse"
            ],
            // Sizing
            /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */ w: [
                {
                    w: [
                        "auto",
                        "min",
                        "max",
                        "fit",
                        "svw",
                        "lvw",
                        "dvw",
                        isArbitraryValue,
                        spacing
                    ]
                }
            ],
            /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */ "min-w": [
                {
                    "min-w": [
                        isArbitraryValue,
                        spacing,
                        "min",
                        "max",
                        "fit"
                    ]
                }
            ],
            /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */ "max-w": [
                {
                    "max-w": [
                        isArbitraryValue,
                        spacing,
                        "none",
                        "full",
                        "min",
                        "max",
                        "fit",
                        "prose",
                        {
                            screen: [
                                isTshirtSize
                            ]
                        },
                        isTshirtSize
                    ]
                }
            ],
            /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */ h: [
                {
                    h: [
                        isArbitraryValue,
                        spacing,
                        "auto",
                        "min",
                        "max",
                        "fit",
                        "svh",
                        "lvh",
                        "dvh"
                    ]
                }
            ],
            /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */ "min-h": [
                {
                    "min-h": [
                        isArbitraryValue,
                        spacing,
                        "min",
                        "max",
                        "fit",
                        "svh",
                        "lvh",
                        "dvh"
                    ]
                }
            ],
            /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */ "max-h": [
                {
                    "max-h": [
                        isArbitraryValue,
                        spacing,
                        "min",
                        "max",
                        "fit",
                        "svh",
                        "lvh",
                        "dvh"
                    ]
                }
            ],
            /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */ size: [
                {
                    size: [
                        isArbitraryValue,
                        spacing,
                        "auto",
                        "min",
                        "max",
                        "fit"
                    ]
                }
            ],
            // Typography
            /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */ "font-size": [
                {
                    text: [
                        "base",
                        isTshirtSize,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */ "font-smoothing": [
                "antialiased",
                "subpixel-antialiased"
            ],
            /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */ "font-style": [
                "italic",
                "not-italic"
            ],
            /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */ "font-weight": [
                {
                    font: [
                        "thin",
                        "extralight",
                        "light",
                        "normal",
                        "medium",
                        "semibold",
                        "bold",
                        "extrabold",
                        "black",
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */ "font-family": [
                {
                    font: [
                        isAny
                    ]
                }
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ "fvn-normal": [
                "normal-nums"
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ "fvn-ordinal": [
                "ordinal"
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ "fvn-slashed-zero": [
                "slashed-zero"
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ "fvn-figure": [
                "lining-nums",
                "oldstyle-nums"
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ "fvn-spacing": [
                "proportional-nums",
                "tabular-nums"
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ "fvn-fraction": [
                "diagonal-fractions",
                "stacked-fractons"
            ],
            /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */ tracking: [
                {
                    tracking: [
                        "tighter",
                        "tight",
                        "normal",
                        "wide",
                        "wider",
                        "widest",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */ "line-clamp": [
                {
                    "line-clamp": [
                        "none",
                        isNumber,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */ leading: [
                {
                    leading: [
                        "none",
                        "tight",
                        "snug",
                        "normal",
                        "relaxed",
                        "loose",
                        isLength,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */ "list-image": [
                {
                    "list-image": [
                        "none",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */ "list-style-type": [
                {
                    list: [
                        "none",
                        "disc",
                        "decimal",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */ "list-style-position": [
                {
                    list: [
                        "inside",
                        "outside"
                    ]
                }
            ],
            /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */ "placeholder-color": [
                {
                    placeholder: [
                        colors
                    ]
                }
            ],
            /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */ "placeholder-opacity": [
                {
                    "placeholder-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */ "text-alignment": [
                {
                    text: [
                        "left",
                        "center",
                        "right",
                        "justify",
                        "start",
                        "end"
                    ]
                }
            ],
            /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */ "text-color": [
                {
                    text: [
                        colors
                    ]
                }
            ],
            /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */ "text-opacity": [
                {
                    "text-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */ "text-decoration": [
                "underline",
                "overline",
                "line-through",
                "no-underline"
            ],
            /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */ "text-decoration-style": [
                {
                    decoration: [
                        ...getLineStyles(),
                        "wavy"
                    ]
                }
            ],
            /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */ "text-decoration-thickness": [
                {
                    decoration: [
                        "auto",
                        "from-font",
                        isLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */ "underline-offset": [
                {
                    "underline-offset": [
                        "auto",
                        isLength,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */ "text-decoration-color": [
                {
                    decoration: [
                        colors
                    ]
                }
            ],
            /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */ "text-transform": [
                "uppercase",
                "lowercase",
                "capitalize",
                "normal-case"
            ],
            /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */ "text-overflow": [
                "truncate",
                "text-ellipsis",
                "text-clip"
            ],
            /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */ "text-wrap": [
                {
                    text: [
                        "wrap",
                        "nowrap",
                        "balance",
                        "pretty"
                    ]
                }
            ],
            /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */ indent: [
                {
                    indent: getSpacingWithArbitrary()
                }
            ],
            /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */ "vertical-align": [
                {
                    align: [
                        "baseline",
                        "top",
                        "middle",
                        "bottom",
                        "text-top",
                        "text-bottom",
                        "sub",
                        "super",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */ whitespace: [
                {
                    whitespace: [
                        "normal",
                        "nowrap",
                        "pre",
                        "pre-line",
                        "pre-wrap",
                        "break-spaces"
                    ]
                }
            ],
            /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */ break: [
                {
                    break: [
                        "normal",
                        "words",
                        "all",
                        "keep"
                    ]
                }
            ],
            /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */ hyphens: [
                {
                    hyphens: [
                        "none",
                        "manual",
                        "auto"
                    ]
                }
            ],
            /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */ content: [
                {
                    content: [
                        "none",
                        isArbitraryValue
                    ]
                }
            ],
            // Backgrounds
            /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */ "bg-attachment": [
                {
                    bg: [
                        "fixed",
                        "local",
                        "scroll"
                    ]
                }
            ],
            /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */ "bg-clip": [
                {
                    "bg-clip": [
                        "border",
                        "padding",
                        "content",
                        "text"
                    ]
                }
            ],
            /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */ "bg-opacity": [
                {
                    "bg-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */ "bg-origin": [
                {
                    "bg-origin": [
                        "border",
                        "padding",
                        "content"
                    ]
                }
            ],
            /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */ "bg-position": [
                {
                    bg: [
                        ...getPositions(),
                        isArbitraryPosition
                    ]
                }
            ],
            /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */ "bg-repeat": [
                {
                    bg: [
                        "no-repeat",
                        {
                            repeat: [
                                "",
                                "x",
                                "y",
                                "round",
                                "space"
                            ]
                        }
                    ]
                }
            ],
            /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */ "bg-size": [
                {
                    bg: [
                        "auto",
                        "cover",
                        "contain",
                        isArbitrarySize
                    ]
                }
            ],
            /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */ "bg-image": [
                {
                    bg: [
                        "none",
                        {
                            "gradient-to": [
                                "t",
                                "tr",
                                "r",
                                "br",
                                "b",
                                "bl",
                                "l",
                                "tl"
                            ]
                        },
                        isArbitraryImage
                    ]
                }
            ],
            /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */ "bg-color": [
                {
                    bg: [
                        colors
                    ]
                }
            ],
            /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ "gradient-from-pos": [
                {
                    from: [
                        gradientColorStopPositions
                    ]
                }
            ],
            /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ "gradient-via-pos": [
                {
                    via: [
                        gradientColorStopPositions
                    ]
                }
            ],
            /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ "gradient-to-pos": [
                {
                    to: [
                        gradientColorStopPositions
                    ]
                }
            ],
            /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ "gradient-from": [
                {
                    from: [
                        gradientColorStops
                    ]
                }
            ],
            /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ "gradient-via": [
                {
                    via: [
                        gradientColorStops
                    ]
                }
            ],
            /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ "gradient-to": [
                {
                    to: [
                        gradientColorStops
                    ]
                }
            ],
            // Borders
            /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */ rounded: [
                {
                    rounded: [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-s": [
                {
                    "rounded-s": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-e": [
                {
                    "rounded-e": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-t": [
                {
                    "rounded-t": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-r": [
                {
                    "rounded-r": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-b": [
                {
                    "rounded-b": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-l": [
                {
                    "rounded-l": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-ss": [
                {
                    "rounded-ss": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-se": [
                {
                    "rounded-se": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-ee": [
                {
                    "rounded-ee": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-es": [
                {
                    "rounded-es": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-tl": [
                {
                    "rounded-tl": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-tr": [
                {
                    "rounded-tr": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-br": [
                {
                    "rounded-br": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */ "rounded-bl": [
                {
                    "rounded-bl": [
                        borderRadius
                    ]
                }
            ],
            /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w": [
                {
                    border: [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-x": [
                {
                    "border-x": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-y": [
                {
                    "border-y": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-s": [
                {
                    "border-s": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-e": [
                {
                    "border-e": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-t": [
                {
                    "border-t": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-r": [
                {
                    "border-r": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-b": [
                {
                    "border-b": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */ "border-w-l": [
                {
                    "border-l": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */ "border-opacity": [
                {
                    "border-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */ "border-style": [
                {
                    border: [
                        ...getLineStyles(),
                        "hidden"
                    ]
                }
            ],
            /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */ "divide-x": [
                {
                    "divide-x": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */ "divide-x-reverse": [
                "divide-x-reverse"
            ],
            /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */ "divide-y": [
                {
                    "divide-y": [
                        borderWidth
                    ]
                }
            ],
            /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */ "divide-y-reverse": [
                "divide-y-reverse"
            ],
            /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */ "divide-opacity": [
                {
                    "divide-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */ "divide-style": [
                {
                    divide: getLineStyles()
                }
            ],
            /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color": [
                {
                    border: [
                        borderColor
                    ]
                }
            ],
            /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color-x": [
                {
                    "border-x": [
                        borderColor
                    ]
                }
            ],
            /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color-y": [
                {
                    "border-y": [
                        borderColor
                    ]
                }
            ],
            /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color-t": [
                {
                    "border-t": [
                        borderColor
                    ]
                }
            ],
            /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color-r": [
                {
                    "border-r": [
                        borderColor
                    ]
                }
            ],
            /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color-b": [
                {
                    "border-b": [
                        borderColor
                    ]
                }
            ],
            /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */ "border-color-l": [
                {
                    "border-l": [
                        borderColor
                    ]
                }
            ],
            /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */ "divide-color": [
                {
                    divide: [
                        borderColor
                    ]
                }
            ],
            /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */ "outline-style": [
                {
                    outline: [
                        "",
                        ...getLineStyles()
                    ]
                }
            ],
            /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */ "outline-offset": [
                {
                    "outline-offset": [
                        isLength,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */ "outline-w": [
                {
                    outline: [
                        isLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */ "outline-color": [
                {
                    outline: [
                        colors
                    ]
                }
            ],
            /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */ "ring-w": [
                {
                    ring: getLengthWithEmptyAndArbitrary()
                }
            ],
            /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */ "ring-w-inset": [
                "ring-inset"
            ],
            /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */ "ring-color": [
                {
                    ring: [
                        colors
                    ]
                }
            ],
            /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */ "ring-opacity": [
                {
                    "ring-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */ "ring-offset-w": [
                {
                    "ring-offset": [
                        isLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */ "ring-offset-color": [
                {
                    "ring-offset": [
                        colors
                    ]
                }
            ],
            // Effects
            /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */ shadow: [
                {
                    shadow: [
                        "",
                        "inner",
                        "none",
                        isTshirtSize,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */ "shadow-color": [
                {
                    shadow: [
                        isAny
                    ]
                }
            ],
            /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */ opacity: [
                {
                    opacity: [
                        opacity
                    ]
                }
            ],
            /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */ "mix-blend": [
                {
                    "mix-blend": getBlendModes()
                }
            ],
            /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */ "bg-blend": [
                {
                    "bg-blend": getBlendModes()
                }
            ],
            // Filters
            /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */ filter: [
                {
                    filter: [
                        "",
                        "none"
                    ]
                }
            ],
            /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */ blur: [
                {
                    blur: [
                        blur
                    ]
                }
            ],
            /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */ brightness: [
                {
                    brightness: [
                        brightness
                    ]
                }
            ],
            /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */ contrast: [
                {
                    contrast: [
                        contrast
                    ]
                }
            ],
            /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */ "drop-shadow": [
                {
                    "drop-shadow": [
                        "",
                        "none",
                        isTshirtSize,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */ grayscale: [
                {
                    grayscale: [
                        grayscale
                    ]
                }
            ],
            /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */ "hue-rotate": [
                {
                    "hue-rotate": [
                        hueRotate
                    ]
                }
            ],
            /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */ invert: [
                {
                    invert: [
                        invert
                    ]
                }
            ],
            /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */ saturate: [
                {
                    saturate: [
                        saturate
                    ]
                }
            ],
            /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */ sepia: [
                {
                    sepia: [
                        sepia
                    ]
                }
            ],
            /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */ "backdrop-filter": [
                {
                    "backdrop-filter": [
                        "",
                        "none"
                    ]
                }
            ],
            /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */ "backdrop-blur": [
                {
                    "backdrop-blur": [
                        blur
                    ]
                }
            ],
            /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */ "backdrop-brightness": [
                {
                    "backdrop-brightness": [
                        brightness
                    ]
                }
            ],
            /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */ "backdrop-contrast": [
                {
                    "backdrop-contrast": [
                        contrast
                    ]
                }
            ],
            /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */ "backdrop-grayscale": [
                {
                    "backdrop-grayscale": [
                        grayscale
                    ]
                }
            ],
            /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */ "backdrop-hue-rotate": [
                {
                    "backdrop-hue-rotate": [
                        hueRotate
                    ]
                }
            ],
            /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */ "backdrop-invert": [
                {
                    "backdrop-invert": [
                        invert
                    ]
                }
            ],
            /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */ "backdrop-opacity": [
                {
                    "backdrop-opacity": [
                        opacity
                    ]
                }
            ],
            /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */ "backdrop-saturate": [
                {
                    "backdrop-saturate": [
                        saturate
                    ]
                }
            ],
            /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */ "backdrop-sepia": [
                {
                    "backdrop-sepia": [
                        sepia
                    ]
                }
            ],
            // Tables
            /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */ "border-collapse": [
                {
                    border: [
                        "collapse",
                        "separate"
                    ]
                }
            ],
            /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */ "border-spacing": [
                {
                    "border-spacing": [
                        borderSpacing
                    ]
                }
            ],
            /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */ "border-spacing-x": [
                {
                    "border-spacing-x": [
                        borderSpacing
                    ]
                }
            ],
            /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */ "border-spacing-y": [
                {
                    "border-spacing-y": [
                        borderSpacing
                    ]
                }
            ],
            /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */ "table-layout": [
                {
                    table: [
                        "auto",
                        "fixed"
                    ]
                }
            ],
            /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */ caption: [
                {
                    caption: [
                        "top",
                        "bottom"
                    ]
                }
            ],
            // Transitions and Animation
            /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */ transition: [
                {
                    transition: [
                        "none",
                        "all",
                        "",
                        "colors",
                        "opacity",
                        "shadow",
                        "transform",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */ duration: [
                {
                    duration: getNumberAndArbitrary()
                }
            ],
            /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */ ease: [
                {
                    ease: [
                        "linear",
                        "in",
                        "out",
                        "in-out",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */ delay: [
                {
                    delay: getNumberAndArbitrary()
                }
            ],
            /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */ animate: [
                {
                    animate: [
                        "none",
                        "spin",
                        "ping",
                        "pulse",
                        "bounce",
                        isArbitraryValue
                    ]
                }
            ],
            // Transforms
            /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */ transform: [
                {
                    transform: [
                        "",
                        "gpu",
                        "none"
                    ]
                }
            ],
            /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */ scale: [
                {
                    scale: [
                        scale
                    ]
                }
            ],
            /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */ "scale-x": [
                {
                    "scale-x": [
                        scale
                    ]
                }
            ],
            /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */ "scale-y": [
                {
                    "scale-y": [
                        scale
                    ]
                }
            ],
            /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */ rotate: [
                {
                    rotate: [
                        isInteger,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */ "translate-x": [
                {
                    "translate-x": [
                        translate
                    ]
                }
            ],
            /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */ "translate-y": [
                {
                    "translate-y": [
                        translate
                    ]
                }
            ],
            /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */ "skew-x": [
                {
                    "skew-x": [
                        skew
                    ]
                }
            ],
            /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */ "skew-y": [
                {
                    "skew-y": [
                        skew
                    ]
                }
            ],
            /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */ "transform-origin": [
                {
                    origin: [
                        "center",
                        "top",
                        "top-right",
                        "right",
                        "bottom-right",
                        "bottom",
                        "bottom-left",
                        "left",
                        "top-left",
                        isArbitraryValue
                    ]
                }
            ],
            // Interactivity
            /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */ accent: [
                {
                    accent: [
                        "auto",
                        colors
                    ]
                }
            ],
            /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */ appearance: [
                {
                    appearance: [
                        "none",
                        "auto"
                    ]
                }
            ],
            /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */ cursor: [
                {
                    cursor: [
                        "auto",
                        "default",
                        "pointer",
                        "wait",
                        "text",
                        "move",
                        "help",
                        "not-allowed",
                        "none",
                        "context-menu",
                        "progress",
                        "cell",
                        "crosshair",
                        "vertical-text",
                        "alias",
                        "copy",
                        "no-drop",
                        "grab",
                        "grabbing",
                        "all-scroll",
                        "col-resize",
                        "row-resize",
                        "n-resize",
                        "e-resize",
                        "s-resize",
                        "w-resize",
                        "ne-resize",
                        "nw-resize",
                        "se-resize",
                        "sw-resize",
                        "ew-resize",
                        "ns-resize",
                        "nesw-resize",
                        "nwse-resize",
                        "zoom-in",
                        "zoom-out",
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */ "caret-color": [
                {
                    caret: [
                        colors
                    ]
                }
            ],
            /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */ "pointer-events": [
                {
                    "pointer-events": [
                        "none",
                        "auto"
                    ]
                }
            ],
            /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */ resize: [
                {
                    resize: [
                        "none",
                        "y",
                        "x",
                        ""
                    ]
                }
            ],
            /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */ "scroll-behavior": [
                {
                    scroll: [
                        "auto",
                        "smooth"
                    ]
                }
            ],
            /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-m": [
                {
                    "scroll-m": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-mx": [
                {
                    "scroll-mx": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-my": [
                {
                    "scroll-my": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-ms": [
                {
                    "scroll-ms": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-me": [
                {
                    "scroll-me": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-mt": [
                {
                    "scroll-mt": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-mr": [
                {
                    "scroll-mr": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-mb": [
                {
                    "scroll-mb": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */ "scroll-ml": [
                {
                    "scroll-ml": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-p": [
                {
                    "scroll-p": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-px": [
                {
                    "scroll-px": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-py": [
                {
                    "scroll-py": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-ps": [
                {
                    "scroll-ps": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-pe": [
                {
                    "scroll-pe": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-pt": [
                {
                    "scroll-pt": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-pr": [
                {
                    "scroll-pr": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-pb": [
                {
                    "scroll-pb": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */ "scroll-pl": [
                {
                    "scroll-pl": getSpacingWithArbitrary()
                }
            ],
            /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */ "snap-align": [
                {
                    snap: [
                        "start",
                        "end",
                        "center",
                        "align-none"
                    ]
                }
            ],
            /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */ "snap-stop": [
                {
                    snap: [
                        "normal",
                        "always"
                    ]
                }
            ],
            /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ "snap-type": [
                {
                    snap: [
                        "none",
                        "x",
                        "y",
                        "both"
                    ]
                }
            ],
            /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ "snap-strictness": [
                {
                    snap: [
                        "mandatory",
                        "proximity"
                    ]
                }
            ],
            /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */ touch: [
                {
                    touch: [
                        "auto",
                        "none",
                        "manipulation"
                    ]
                }
            ],
            /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */ "touch-x": [
                {
                    "touch-pan": [
                        "x",
                        "left",
                        "right"
                    ]
                }
            ],
            /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */ "touch-y": [
                {
                    "touch-pan": [
                        "y",
                        "up",
                        "down"
                    ]
                }
            ],
            /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */ "touch-pz": [
                "touch-pinch-zoom"
            ],
            /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */ select: [
                {
                    select: [
                        "none",
                        "text",
                        "all",
                        "auto"
                    ]
                }
            ],
            /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */ "will-change": [
                {
                    "will-change": [
                        "auto",
                        "scroll",
                        "contents",
                        "transform",
                        isArbitraryValue
                    ]
                }
            ],
            // SVG
            /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */ fill: [
                {
                    fill: [
                        colors,
                        "none"
                    ]
                }
            ],
            /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */ "stroke-w": [
                {
                    stroke: [
                        isLength,
                        isArbitraryLength,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */ stroke: [
                {
                    stroke: [
                        colors,
                        "none"
                    ]
                }
            ],
            // Accessibility
            /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */ sr: [
                "sr-only",
                "not-sr-only"
            ],
            /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */ "forced-color-adjust": [
                {
                    "forced-color-adjust": [
                        "auto",
                        "none"
                    ]
                }
            ]
        },
        conflictingClassGroups: {
            overflow: [
                "overflow-x",
                "overflow-y"
            ],
            overscroll: [
                "overscroll-x",
                "overscroll-y"
            ],
            inset: [
                "inset-x",
                "inset-y",
                "start",
                "end",
                "top",
                "right",
                "bottom",
                "left"
            ],
            "inset-x": [
                "right",
                "left"
            ],
            "inset-y": [
                "top",
                "bottom"
            ],
            flex: [
                "basis",
                "grow",
                "shrink"
            ],
            gap: [
                "gap-x",
                "gap-y"
            ],
            p: [
                "px",
                "py",
                "ps",
                "pe",
                "pt",
                "pr",
                "pb",
                "pl"
            ],
            px: [
                "pr",
                "pl"
            ],
            py: [
                "pt",
                "pb"
            ],
            m: [
                "mx",
                "my",
                "ms",
                "me",
                "mt",
                "mr",
                "mb",
                "ml"
            ],
            mx: [
                "mr",
                "ml"
            ],
            my: [
                "mt",
                "mb"
            ],
            size: [
                "w",
                "h"
            ],
            "font-size": [
                "leading"
            ],
            "fvn-normal": [
                "fvn-ordinal",
                "fvn-slashed-zero",
                "fvn-figure",
                "fvn-spacing",
                "fvn-fraction"
            ],
            "fvn-ordinal": [
                "fvn-normal"
            ],
            "fvn-slashed-zero": [
                "fvn-normal"
            ],
            "fvn-figure": [
                "fvn-normal"
            ],
            "fvn-spacing": [
                "fvn-normal"
            ],
            "fvn-fraction": [
                "fvn-normal"
            ],
            "line-clamp": [
                "display",
                "overflow"
            ],
            rounded: [
                "rounded-s",
                "rounded-e",
                "rounded-t",
                "rounded-r",
                "rounded-b",
                "rounded-l",
                "rounded-ss",
                "rounded-se",
                "rounded-ee",
                "rounded-es",
                "rounded-tl",
                "rounded-tr",
                "rounded-br",
                "rounded-bl"
            ],
            "rounded-s": [
                "rounded-ss",
                "rounded-es"
            ],
            "rounded-e": [
                "rounded-se",
                "rounded-ee"
            ],
            "rounded-t": [
                "rounded-tl",
                "rounded-tr"
            ],
            "rounded-r": [
                "rounded-tr",
                "rounded-br"
            ],
            "rounded-b": [
                "rounded-br",
                "rounded-bl"
            ],
            "rounded-l": [
                "rounded-tl",
                "rounded-bl"
            ],
            "border-spacing": [
                "border-spacing-x",
                "border-spacing-y"
            ],
            "border-w": [
                "border-w-s",
                "border-w-e",
                "border-w-t",
                "border-w-r",
                "border-w-b",
                "border-w-l"
            ],
            "border-w-x": [
                "border-w-r",
                "border-w-l"
            ],
            "border-w-y": [
                "border-w-t",
                "border-w-b"
            ],
            "border-color": [
                "border-color-t",
                "border-color-r",
                "border-color-b",
                "border-color-l"
            ],
            "border-color-x": [
                "border-color-r",
                "border-color-l"
            ],
            "border-color-y": [
                "border-color-t",
                "border-color-b"
            ],
            "scroll-m": [
                "scroll-mx",
                "scroll-my",
                "scroll-ms",
                "scroll-me",
                "scroll-mt",
                "scroll-mr",
                "scroll-mb",
                "scroll-ml"
            ],
            "scroll-mx": [
                "scroll-mr",
                "scroll-ml"
            ],
            "scroll-my": [
                "scroll-mt",
                "scroll-mb"
            ],
            "scroll-p": [
                "scroll-px",
                "scroll-py",
                "scroll-ps",
                "scroll-pe",
                "scroll-pt",
                "scroll-pr",
                "scroll-pb",
                "scroll-pl"
            ],
            "scroll-px": [
                "scroll-pr",
                "scroll-pl"
            ],
            "scroll-py": [
                "scroll-pt",
                "scroll-pb"
            ],
            touch: [
                "touch-x",
                "touch-y",
                "touch-pz"
            ],
            "touch-x": [
                "touch"
            ],
            "touch-y": [
                "touch"
            ],
            "touch-pz": [
                "touch"
            ]
        },
        conflictingClassGroupModifiers: {
            "font-size": [
                "leading"
            ]
        }
    };
}
/**
 * @param baseConfig Config where other config will be merged into. This object will be mutated.
 * @param configExtension Partial config to merge into the `baseConfig`.
 */ function mergeConfigs(baseConfig, { cacheSize , prefix , separator , extend ={} , override ={}  }) {
    overrideProperty(baseConfig, "cacheSize", cacheSize);
    overrideProperty(baseConfig, "prefix", prefix);
    overrideProperty(baseConfig, "separator", separator);
    for(const configKey in override)overrideConfigProperties(baseConfig[configKey], override[configKey]);
    for(const key in extend)mergeConfigProperties(baseConfig[key], extend[key]);
    return baseConfig;
}
function overrideProperty(baseObject, overrideKey, overrideValue) {
    if (overrideValue !== undefined) baseObject[overrideKey] = overrideValue;
}
function overrideConfigProperties(baseObject, overrideObject) {
    if (overrideObject) for(const key in overrideObject)overrideProperty(baseObject, key, overrideObject[key]);
}
function mergeConfigProperties(baseObject, mergeObject) {
    if (mergeObject) for(const key in mergeObject){
        const mergeValue = mergeObject[key];
        if (mergeValue !== undefined) baseObject[key] = (baseObject[key] || []).concat(mergeValue);
    }
}
function extendTailwindMerge(configExtension, ...createConfig) {
    return typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(()=>mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
}
const twMerge = /*#__PURE__*/ createTailwindMerge(getDefaultConfig);
exports.createTailwindMerge = createTailwindMerge;
exports.extendTailwindMerge = extendTailwindMerge;
exports.fromTheme = fromTheme;
exports.getDefaultConfig = getDefaultConfig;
exports.mergeConfigs = mergeConfigs;
exports.twJoin = twJoin;
exports.twMerge = twMerge;
exports.validators = validators;

},{}],"2kxMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Input", ()=>Input);
var _web = require("solid-js/web");
var _solidJs = require("solid-js");
var _utils = require("~/lib/utils");
var _tmpl$ = /*#__PURE__*/ (0, _web.template)(`<input>`);
const Input = (props)=>{
    const [, rest] = (0, _solidJs.splitProps)(props, [
        "type",
        "class"
    ]);
    return (()=>{
        var _el$ = _tmpl$();
        (0, _web.spread)(_el$, (0, _web.mergeProps)({
            get type () {
                return props.type;
            },
            get ["class"] () {
                return (0, _utils.cn)("border-input ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-full rounded-md border bg-transparent px-3 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", props.class);
            }
        }, rest), false, false);
        return _el$;
    })();
};

},{"solid-js/web":"eGRlU","solid-js":"f1z31","~/lib/utils":"duS4E","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}]},["aeHed","BMEKY"], "BMEKY", "parcelRequire2bc7")

</script>
</body>
</html>
